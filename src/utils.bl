Animation :: struct {
	start:  f32;
	end:    f32;
	t:      f32;
	speed:  f32;
	interp: AnimationInterpolation;
}

AnimationInterpolation :: enum { SMOOTH_STEP; LINEAR };

start_animation :: fn (anim: *Animation, start: f32, end: f32, speed: f32, interp := AnimationInterpolation.SMOOTH_STEP) #inline {
	@anim = .{
		start,
		end,
		0.f,
		speed,
		interp
	};
}

animate :: fn (anim: *Animation) f32 #inline {
	anim.t += frame_delta_time * anim.speed;
	if anim.t >= 1.f then return anim.end;
	anim.t = math.clamp(anim.t, 0.f, 1.f);

	using AnimationInterpolation;
	switch anim.interp {
		SMOOTH_STEP { return math.smooth_step(anim.start, anim.end, anim.t); }
		LINEAR      { return math.lerp(anim.start, anim.end, anim.t);        }
	}

	unreachable;
	return 0.f;
}

is_animating :: fn (anim: *Animation) bool #inline {
	return anim.t < 1.f;
}

TokenizerBase :: struct {
	bytes: []u8;
	index: s32;
}

tok_peek :: fn (ctx: *TokenizerBase, char: *u8) bool #inline {
	if ctx.index >= ctx.bytes.len then return false;
	@char = ctx.bytes[ctx.index];
	return true;
}

eat_whitespace :: fn (ctx: *TokenizerBase) s32 #inline {
	n := 0;
	loop ctx.index < ctx.bytes.len {
		c :: ctx.bytes[ctx.index];
		if c != ' ' && c != '\t' { break; }
		ctx.index += 1;
		n += 1;
	}
	return n;
}

eat_till_whitespace :: fn (ctx: *TokenizerBase) string_view {
	start_index :: ctx.index;
	len := 0;
	loop ctx.index < ctx.bytes.len {
		c :: ctx.bytes[ctx.index];
		switch c {
			'\n', '\r', '\t', ' ' { break; }
			default;
		}
		len       += 1;
		ctx.index += 1;
	}

	return string_view.{ len, &ctx.bytes[start_index] };
}

eat_string_in_quotes :: fn (ctx: *TokenizerBase, trim_quotes := false) (str: string_view, valid: bool) {
	// Index out of range.
	if ctx.index >= ctx.bytes.len   { return "", false; }
	// Missing first quote.
	if ctx.bytes[ctx.index] != '\"' { return "", false; }
	start_index :: ctx.index;
	len := 0;

	pc: u8;
	sc, qc: s32;
	in_string := true;
	loop in_string && ctx.index < ctx.bytes.len {
		c :: ctx.bytes[ctx.index];
		if pc == '\\' {
			sc += 1;
		} else {
			sc = 0;
		}
		escape :: sc > 0 && (sc % 2 > 0);
		if c == '\"' && escape == false {
			qc += 1;
			in_string = qc != 2;
		}
		len       += 1;
		ctx.index += 1;
		pc = c;
	}
	if in_string {
		// Unterminated string.
		return "", false;
	}
	str :: string_view.{ len, &ctx.bytes[start_index] };
	if !trim_quotes { return str, true; }
	return trim_left(trim_right(str, "\""), "\""), true;
}

eat_line_and_trim_eol :: fn (ctx: *TokenizerBase) string_view {
	line :: eat_line(ctx);
	return trim_right(line, "\r\n");
}

eat_line :: fn (ctx: *TokenizerBase) string_view {
	start_index :: ctx.index;
	len := 0;
	loop ctx.index < ctx.bytes.len {
		c :: ctx.bytes[ctx.index];
		len       += 1;
		ctx.index += 1;
		if c == '\n' { break; }
	}

	return string_view.{ len, &ctx.bytes[start_index] };
}

eat_till_new_line :: fn (ctx: *TokenizerBase) string_view {
	start_index :: ctx.index;
	len := 0;
	loop ctx.index < ctx.bytes.len {
		c :: ctx.bytes[ctx.index];
		if c == '\n' || c == '\r' { break; }
		len       += 1;
		ctx.index += 1;
	}

	return string_view.{ len, &ctx.bytes[start_index] };
}

// -, _ or alpha characters
eat_word :: fn (ctx: *TokenizerBase) string_view {
	start_index :: ctx.index;
	len := 0;
	loop ctx.index < ctx.bytes.len {
		c :: ctx.bytes[ctx.index];
		if c != '_' && c != '-' && is_alpha(c) == false { break; }
		len       += 1;
		ctx.index += 1;
	}
	return string_view.{ len, &ctx.bytes[start_index] };
}

eat_till :: fn (ctx: *TokenizerBase, delimiters: []u8) string_view {
	start_index :: ctx.index;
	len := 0;
	br := false;
	loop ctx.index < ctx.bytes.len && br == false {
		c :: ctx.bytes[ctx.index];
		loop i := 0; i < delimiters.len; i += 1 {
			if c == delimiters[i] {
				br = true;
				break;
			}
		}
		if br { break; }
		len       += 1;
		ctx.index += 1;
	}
	return string_view.{ len, &ctx.bytes[start_index] };
}

eat_if_one_of :: fn (ctx: *TokenizerBase, chars: []u8) bool #inline {
	c: u8 #noinit;
	if tok_peek(ctx, &c) && is_one_of(c, chars) {
		ctx.index += 1;
		return true;
	}
	return false;
}

eat_if_alpha :: fn (ctx: *TokenizerBase) bool #inline {
	c: u8 #noinit;
	if tok_peek(ctx, &c) && is_alpha(c) {
		ctx.index += 1;
		return true;
	}
	return false;
}

eat_number :: fn (ctx: *TokenizerBase, n: *s64) bool #inline {
	str := string_view.{ 0, &ctx.bytes[ctx.index] };
	c: u8 #noinit;
	loop tok_peek(ctx, &c) {
		if !is_digit(c) then break;
		str.len   += 1;
		ctx.index += 1;
	}
	if str.len == 0 {
		return false;
	}
	tmp :: strtos64(str);
	@n = tmp;
	return true;
}

parse_valid_clang_like_file_link :: fn (subject: string_view) []FileLink {

	allocator :: application_context.temporary_allocator;

	result: [..]FileLink;
	array_init(&result, 8, allocator);

	{
		re :: &project.file_link_regex;
		if !re.is_valid then return .{};

		defer regex_done(&re.expr);

		loop regex_match(&re.expr, subject) {
			matches :: regex_get_match(&re.expr);
			if matches.len == 0 then continue;

			path :: string_view.{ matches[0].end - matches[0].start, &subject[matches[0].start] };

			fullpath := str_make(path, allocator);

			path_normalize(&fullpath) catch {
				continue;
			};

			is_dir, is_dir_err :: is_directory(fullpath);
			if is_dir || is_dir_err {
				continue;
			}

			link: FileLink;

			link.start    = matches[0].start;
			link.end      = matches[0].end;
			link.filepath = fullpath;
			link.ln       = 1;
			link.cl       = 1;

			array_push(&result, link);
		}
	}

	{ // locations
		re :: &project.file_loc_regex;
		if !re.is_valid then return .{};

		defer regex_done(&re.expr);

		loop i := 0; i < result.len; i += 1 {
			link :: &result[i];
			after_link :: string_view.{ subject.len - link.end, &subject[link.end] };

			if regex_match(&re.expr, after_link) {
				matches :: regex_get_match(&re.expr);
				if matches.len < 2 then continue;
				ln :: strtos64(.{ matches[1].end - matches[1].start, &after_link[matches[1].start] });
				link.ln = math.max(1, auto ln);
				if matches.len == 3 {
					cl :: strtos64(.{ matches[2].end - matches[2].start, &after_link[matches[2].start] });
					link.cl = math.max(1, auto cl);
				}
			}
		}
	}

	return result;
}

get_enum_variants_as_redable_list :: fn (TEnum: type #comptime, replace_underscore := true) [type_utils.enum_variant_count(TEnum)]string_view #comptime {
	tmp: [type_utils.enum_variant_count(TEnum)]string_view #noinit;
	info :: cast(*TypeInfoEnum) typeinfo(TEnum);
	loop i := 0; i < tmp.len; i += 1 {
		name :: str_make(info.variants[i].name);
		str_lower(&name);
		if replace_underscore {
			str_replace_all(&name, '_', '-');
		}

		tmp[i] = name;
	}
	return tmp;
}

get_struct_members_as_list :: fn (TStruct: type #comptime) [type_utils.struct_member_count(TStruct)]string_view #comptime {
	tmp: [type_utils.struct_member_count(TStruct)]string_view #noinit;
	info :: cast(*TypeInfoStruct) typeinfo(TStruct);
	loop i := 0; i < tmp.len; i += 1 {
		name :: str_make(info.members[i].name);
		str_lower(&name);
		//str_replace_all(&name, '_', '-');

		tmp[i] = name;
	}
	return tmp;
}

rgb :: fn (c: u32) v4 #comptime {
	T :: union {
		v: u32;
		ch: [4]u8;
	};
	tmp: T #noinit;
	tmp.v = c;

	result: v4 #noinit;
	result.x = cast(f32) tmp.ch[2] / 255.f;
	result.y = cast(f32) tmp.ch[1] / 255.f;
	result.z = cast(f32) tmp.ch[0] / 255.f;
	result.w = 1.f;
	return result;
}

rgb2 :: fn (c: u32) v4 {
	T :: union {
		v: u32;
		ch: [4]u8;
	};
	tmp: T #noinit;
	tmp.v = c;

	result: v4 #noinit;
	result.x = cast(f32) tmp.ch[2] / 255.f;
	result.y = cast(f32) tmp.ch[1] / 255.f;
	result.z = cast(f32) tmp.ch[0] / 255.f;
	result.w = 1.f;
	return result;
}

rgba :: fn (c: u32) v4 #comptime {
	T :: union {
		v: u32;
		ch: [4]u8;
	};
	tmp: T #noinit;
	tmp.v = c;

	result: v4 #noinit;
	result.x = cast(f32) tmp.ch[3] / 255.f;
	result.y = cast(f32) tmp.ch[2] / 255.f;
	result.z = cast(f32) tmp.ch[1] / 255.f;
	result.w = cast(f32) tmp.ch[0] / 255.f;
	return result;
}

// Converts the unicode icone ID to utf8 string in the compile time.
icon :: fn (unicode: u32) string_view #inline #comptime {
	tmp: string;
	err :: utf32_to_utf8_single_char(unicode, &tmp);
	if err { panic(err); }
	return tmp;
}

load_whole_file :: fn (dest: *[..]u8, stream: *io.Stream, size_limit_bytes : s64 = -1) Error {
	using io;
	using StreamLocator;

	prev_location, err1  :: seek(stream, CURRENT);
	if err1 { return err1; }
	defer seek(stream, CURRENT, prev_location);

	_, err2 :: seek(stream, BEGIN);
	if err2 { return err2; }

	size, err3 :: seek(stream, END);
	if err3 { return err3; }

	_, err4 :: seek(stream, BEGIN);
	if err4 { return err4; }

	if size_limit_bytes != -1 && size > size_limit_bytes {
		return error(-1, "File bigger than specified limit %B.", size_limit_bytes);
	}

	assert(dest.len == 0, "Expected to be cleared out to reduce copying!");
	array_resize(dest, size);

	return read_all(stream, dest.ptr, size, 2048);
}

string_to_url :: fn (src: string_view) string_view {
	url := str_make(src.len * 2, application_context.temporary_allocator);
	start := 0;
	len   := 0;
	loop j := 0; j < src.len; j += 1 {
		c :: src[j];
		if c >= 'a' && c <= 'z' { len += 1; continue; }
		if c >= 'A' && c <= 'Z' { len += 1; continue; }

		str_append(&url, string_view.{ len, &src[start] });
		start = j + 1;
		len   = 0;

		// eh...
		replacement := tprint("%", fmt_int(c, FmtIntBase.HEX, false));
		assert(replacement.len < 3);
		if replacement.len == 1 {
			str_concat(&url, "%0", replacement);
		} else {
			str_concat(&url, "%", replacement);
		}
	}

	if len > 0 { str_append(&url, string_view.{ len, &src[start] }); }
	return url;
}

open_path :: fn (path: string_view) {
	#if PLATFORM == Platform.WINDOWS {
		ShellExecuteA(null, strtoc("open"), strtoc(path), null, null, SW_SHOWDEFAULT);
	} else {
		// @Incomplete: Maybe something else on Linux?
		os_execute(tprint("open \"%\"", path));
	}
}

trim_right :: fn (str: string_view, chars: []u8) string_view #inline {
	result := str;
	loop i := str.len-1; i >= 0; i -= 1 {
		c :: str[i];
		stop := true;
		loop j := 0; j < chars.len; j += 1 {
			if c == chars[j] {
				result.len -= 1;
				stop        = false;
				break;
			}
		}
		if stop { break; }
	}
	return result;
}

trim_left :: fn (str: string_view, chars: []u8, max_num := math.S32_MAX) string_view #inline {
	start  := 0;
	len    := str.len;
	loop i := 0; i < str.len && i < max_num; i += 1 {
		c :: str[i];
		stop := true;
		loop j := 0; j < chars.len; j += 1 {
			if c == chars[j] {
				len   -= 1;
				start += 1;
				stop   = false;
				break;
			}
		}
		if stop { break; }
	}
	assert(len >= 0 && len <= str.len);
	return string_view.{ len, &str[start] };
}

find_matching_subject_in_data :: fn (data: []u8, subject: string_view, start_position : s64 = 0, row: *s32 = null, col: *s32 = null) s64 #inline {
	assert(subject.len > 0);
	if subject.len > data.len then return -1;
	if start_position >= data.len then return -1;

	is_utf8_start :: fn (byte: u8) bool #inline {
		return (byte & 0xC0) != 0x80;
	};

	first_byte_mask :: cast(u64)subject[0] * 0x0101010101010101;
	i: s64 = start_position;
	loop ;i + 8 < data.len; i += 8 {
		chunk :: @(cast(*u64)&data[i]);

		found_new_line := false;
		if row {
			cmp :: (chunk ^ 0x0a0a0a0a0a0a0a0a);
			found_new_line = ((cmp - 0x0101010101010101) & (~cmp) & 0x8080808080808080) > 0;
		}

		cmp   :: chunk ^ first_byte_mask;
		found :: ((cmp - 0x0101010101010101) & (~cmp) & 0x8080808080808080) > 0;

		if !(found || found_new_line) then continue;

		loop j := 0; j < 8; j += 1 {
			match_start := i+j;
			if data[match_start] == subject[0] && is_utf8_start(data[match_start]) {

				match_found := true;
				loop k := 1; k < subject.len; k += 1 {
					if match_start + k >= data.len then return -1;
					if data[match_start+k] != subject[k] {
						match_found = false;
						break;
					}
				}

				if match_found {
					if col {
						loop k := match_start-1; k >= start_position; k -= 1 {
							if !is_utf8_start(data[k]) then continue;
							if data[k] == '\n' then break;
							@col += 1;
						}
					}
					return match_start;
				}

			} else if row && data[match_start] == '\n' && is_utf8_start(data[match_start]) {
				if col then @col = 0;
				@row += 1;
			}

		}
	}

	// tail
	loop ; i <= data.len - subject.len; i += 1 {

		if data[i] == subject[0] {

			// Check if we're not in the middle of utf8 character.
			if !is_utf8_start(data[i]) then continue;

			match_found := true;
			loop k := 1; k < subject.len; k += 1 {
				if data[i+k] != subject[k] {
					match_found = false;
					break;
				}
			}

			if match_found {
				if col {
					loop k := i-1; k >= start_position; k -= 1 {
						if !is_utf8_start(data[k]) then continue;
						if data[k] == '\n' then break;
						@col += 1;
					}
				}
				return i;
			}

		} else if row && data[i] == '\n' {
			if col then @col = 0;
			@row += 1;
		}

	}

	return -1;
}

/*
find_matching_subject_in_data :: fn (data: []u8, subject: string_view, start_position : s64 = 0, row: *s32 = null, col: *s32 = null) s64 #inline {
	assert(subject.len > 0);
	match_start : s64 = -1;
	match_col: s32;
	subject_index: s32;
	position := start_position;
	found := false;
	loop position < data.len {
		a :: data[position];
		b :: subject[subject_index];

		al :: get_character_len(a);
		if al == 0 { return -1; }
		bl :: get_character_len(b);

		if al == bl && (a == b || (bl == 1 && a == cast(u8) C.toupper(cast(s32) b))) {
			if subject_index == 0 {
				match_start = position;
				if col { match_col = @col; }
			}
			subject_index += bl;
			if subject_index >= subject.len {
				found = true;
				break;
			}
		} else {
			subject_index =  0;
			match_start   = -1;
		}

		position += al;

		if a == '\n' {
			if row { @row += 1; }
			if col { @col = 0;  }
		} else if col {
			@col += 1; // We have to count unicode characters here!
		}
	}

	if found {
		if col then @col = match_col;

		assert(match_start != -1);
		return match_start;
	}
	// Note that match_start here might not be -1, but result match is supposed to be incomplete here.
	return -1;
}
*/

// Does not support new lines (might be OK in some cases).
count_unicode_characters :: fn (str: string_view) s32 {
	count: s32;
	loop i := 0; i < str.len; {
		l :: get_character_len(str[i]);
		i += math.max(1, l); // To prevent looping!
		count += 1;
	}
	return count;
}

get_default_line_ending_for_platform :: fn () string_view #inline {
#if PLATFORM == Platform.WINDOWS {
	return "\r\n";
} else {
	return "\n";
}
}

is_under_directory :: fn (directory: string_view, filepath: string_view) bool #inline {
	root :: string_view.{ math.min(filepath.len, directory.len), filepath.ptr };
	return str_match(root, directory);
}

get_timestamp :: fn () s64 {
	c_time :: fn (destTime: *s64) s64 #extern "time";
	return c_time(null);
}

unicode_char_to_utf8_with_fallback :: fn (c: u32, fallback: string_view = "?") string_view #inline {
	tmp :: str_make(4, application_context.temporary_allocator);
	err :: utf32_to_utf8_single_char(c, &tmp);
	if err {
		print_err(err);
		return fallback;
	}
	return tmp;
}

get_file_hash :: fn (filepath: string_view) u32 {
	tmp :: str_make(filepath, application_context.temporary_allocator);
	#if PLATFORM == Platform.WINDOWS {
		str_lower(&tmp);
	}
	str_replace_all(&tmp, '\\', '/');
	return str_hash(tmp);
}

ShadowMode :: enum {
	NONE;
	ALL;
	TOP;
	BOTTOM;
}

draw_shadow :: fn (x: f32, y: f32, w: f32, h: f32, mode := ShadowMode.ALL) {
	using draw;
	r :: metrics[auto Metric.CORNER_ROUNDING];
	s :: metrics[auto Metric.SHADOW_SIZE];

	set_shader_color();
	inner_color :: rgba(0x00000060);
	outer_color :: rgba(0x0);
	using ShadowMode;
	switch mode {
		NONE { return; }
		ALL {
			rect_rounded(x - s + r, y - s + r, w + s * 2.f - r * 2.f, h + s * 2.f - r * 2.f, s, inner_color, outer_color);
		}
		TOP {
			rect_rounded(x - s, y - s, w + s * 2.f, h + s, s, inner_color, outer_color);
		}
		BOTTOM {
			rect_rounded(x - s, y, w + s * 2.f, h + s, s, inner_color, outer_color);
		}
	}
}

is_ident :: fn (buf: *Buffer, char: string_view) bool #inline {
	NON_IDENT_CHARS :: " ()[]{}.-+:;\"\',!@#$%^&*~`<>/?\t\r\n";

	if char.len == 0              { return false; }
	if is_line_end(buf, char) > 0 { return false; }
	loop i := 0; i < NON_IDENT_CHARS.len; i += 1 {
		if char[0] == NON_IDENT_CHARS[i] { return false; }
	}
	return true;
}

is_number :: fn (buf: *Buffer, char: string_view, base := FmtIntBase.DEC) bool #inline {
	NUMERIC_CHARS := "0123456789";
	using FmtIntBase;
	switch base {
		HEX { NUMERIC_CHARS = "0123456789abcdefABCDEF"; }
		OCT { NUMERIC_CHARS = "012345"; }
		BIN { NUMERIC_CHARS = "01"; }
		default;
	}

	if char.len == 0              { return false; }
	if is_line_end(buf, char) > 0 { return false; }
	loop i := 0; i < NUMERIC_CHARS.len; i += 1 {
		if char[0] == NUMERIC_CHARS[i] then return true;
	}
	return false;
}

is_whitespace :: fn (char: u8) bool #inline {
	WHITESPACE :: " \t\n\r";
	loop i := 0; i < WHITESPACE.len; i += 1 {
		if char == WHITESPACE[i] { return true; }
	}
	return false;
}

is_one_of :: fn (char: u8, other: string_view) bool #inline {
	loop i := 0; i < other.len; i += 1 {
		if char == other[i] then return true;
	}
	return false;
}

insert_all :: fn (tbl: *?T, v: []string_view) #inline {
	loop i := 0; i < v.len; i += 1 {
		tbl_insert(tbl, v[i], 0);
	}
}

str_match_ignore_case :: fn (a: string_view, b: string_view) bool {
	if a.len != b.len { return false; }
	loop i := 0; i < a.len; i += 1 {
		if a[i] == b[i] { continue; }
		if C.tolower(auto a[i]) == C.tolower(auto b[i]) { continue; }
		return false;
	}
	return true;
}

is_point_in_rect :: fn (rx: f32, ry: f32, rw: f32, rh: f32, px: f32, py: f32) bool #inline {
	rxw :: rx + rw;
	ryh :: ry + rh;
	return px > rx && px < rxw && py > ry && py < ryh;
}

get_icon_for_buffer :: fn (buf: *Buffer) string_view {
	if buf.index == shell.buffer_index {
		return icon(ICON_SHELL);
	} else if buf.index == messages_buffer_index {
		return icon(ICON_MESSAGES);
	}
	return get_icon_for_file_type(buf.file_type);
}

expand_position_to_whole_line :: fn (buf: string_view, index: s64, max_distance := 120) string_view {
	begin := index;
	end   := index;
	distance := 0;
	loop i := index; i > 0 && distance < max_distance; i -= 1 {
		c :: buf[i-1];
		if c == '\n' { break; }
		begin    -= 1;
		distance += 1;
	}
	loop i := index; i < buf.len && distance < max_distance; i += 1 {
		c :: buf[i];
		if c == '\n' || c == '\r' { break; }
		end      += 1;
		distance += 1;
	}
	return string_view.{ end - begin, &buf[begin] };
}

get_character_len :: fn (c: u8) s32 #inline {
	if c < 0x80           { return 1; }
	if (c & 0xE0) == 0xC0 { return 2; }
	if (c & 0xE0) == 0xE0 { return 3; }
	if (c & 0xF8) == 0xF0 { return 4; }
	return 0;
}

// Check whether the 'str' content is multiline, might optionaly return the first line of 'str' in 'first_line'.
is_multiline :: fn (str: string_view, first_line: *string_view = null) bool #inline {
	multiline      := false;
	loop index := 0; index < str.len; index += 1 {
		if str[index] == '\n' || str[index] == '\r' {
			multiline = true;
			if first_line {
				(@first_line) = string_view.{ len = index, ptr = str.ptr };
			}
			break;
		}
	}
	if first_line && multiline == false {
		(@first_line) = str;
	}
	return multiline;
}

get_keybinding_for_command :: fn (cmd: Command, missing := "<no binding>") string_view #inline {
	tmp :: str_make(application_context.temporary_allocator);
	loop keymap_index := 0;; keymap_index += 1 {
		keymap_index = lookup_command_keymap_index(cmd, keymap_index);
		if keymap_index == -1 then break;

		if tmp.len > 0 then str_append(&tmp, " | ");
		str_append(&tmp, keymap_entry_to_string(keymap_index));
	}

	if tmp.len == 0 then return missing;
	return tmp;
}

unify_line_endings :: fn (data: []u8, line_ending:  LineEnding) string_view {
	if detect_line_ending(data) == line_ending then return data;

	buf: string;
	if line_ending == LineEnding.LF {
		print_log("Convert to LF");
		buf = str_make(data, application_context.temporary_allocator);
		str_replace_all(&buf, '\r');
	} else {
		print_log("Convert to CRLF");
		buf = str_make(data.len, application_context.temporary_allocator);
		loop i := 0; i < data.len; i += 1 {
			c :: data[i];
			if c == '\n' {
				str_append(&buf, "\r\n");
				continue;
			}
			str_append(&buf, string_view.{ 1, &c });
		}
	}

	return buf;
}

// The args might be modified in case some escape characters are present. Resulting array points to original args, so keep
// the args alive as long as parsed version is needed!
split_command_line_arguments :: fn (args: *string, allocator: *Allocator = null)  [..]string_view {
	result: [..]string_view;
	array_init(&result, 0, allocator);

	in_quotes: u8;
	loop i := 0; i < args.len; {
		c :: (@args)[i];
		if is_whitespace(c) {
			i += 1;
			continue;
		}

		len := 0;

		if c == '\"' || c == '\'' {
			in_quotes = c;
			i += 1;
			start_index :: i;

			// Quoted argument.
			loop ;i < args.len && (@args)[i] != in_quotes; i += 1 {
				len += 1;
			}

			array_push(&result, .{ len, &(@args)[start_index] });
		} else {
			start_index := i;
			loop ;i < args.len && !is_whitespace((@args)[i]); {
				if (@args)[i] == '\\' && i+1 < args.len {
					str_erase(args, i);
				}
				len += 1;
				i += 1;
			}
			array_push(&result, .{ len, &(@args)[start_index] });
		}

		i += 1;
	}

	return result;
}

contains_any_of :: fn (str: string_view, chars: string_view) bool #inline {
	loop i := 0; i < str.len; i += 1 {
		loop j := 0; j < chars.len; j += 1 {
			if str[i] == chars[j] then return true;
		}
	}
	return false;
}


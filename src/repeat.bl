last_command_repeat_count: s32;

repeat_mode_init :: fn () {
	// Activate command buffer.
	active_editor = command_editor;
	buf :: get_active_buffer_and_editor();
	clear_buffer(buf);

	input_mode               = InputMode.NUMBERS;
	notify_changes_to_buffer = buf.index;
	
	if settings.show_hints {
		run_command_binding :: get_keybinding_for_command(Command.RUN_COMMAND);
		cancel_binding :: get_keybinding_for_command(Command.CANCEL_MODE);
		
		hint :: tprint("[%] list commands\t[%] cancel\tOr execute any command using shortcut.", run_command_binding, cancel_binding);
		print_info(hint);
	}
}

draw_repeat_mode :: fn () {
	assert(active_editor == command_editor);

	w, h :: get_command_editor_size();
	draw_command_editor(command_editor, 0.f, 0.f, w, h, "Repeat Next Command: ");
	draw_last_status_message(0.f, h, w);
}

//
// Commands
//

invoke_command_repeat_line_mode :: fn (buf: *Buffer, cmd: Command) bool {
	using Command;
	assert(active_editor == command_editor);
	assert(editors[active_editor].buffer_index == buf.index);

	line_str :: peek_row(buf, 0);
	num := strtos64(line_str);

	if num < 1 {
		set_mode(Mode.TEXT_EDIT);
		return true;
	}

	switch cmd {
		CANCEL_MODE { return false; }
		RUN_COMMAND {
			last_command_repeat_count = auto num;
			set_mode(Mode.RUN_COMMAND);
		}

		default {
			set_mode(Mode.TEXT_EDIT);
			if is_command_valid_for_repeating(cmd) {
				target_buf, target_editor :: get_active_buffer_and_editor();
				start_time := glfw.GetTime();
				loop i := 0; i < num; i += 1 {
					if glfw.GetTime() - start_time > 5. {
						print_warn("Execution took too long, stopping now.");
						break;
					}
					invoke_command(target_editor, target_buf, cmd);
				}
			} else {
				print_err("Command '%' cannot be repeated.", COMMAND_NAMES[auto cmd]);
			}
		}
	}

	return true;
}

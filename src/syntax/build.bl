highlight_build_syntax :: fn (buf: *Buffer) {
	assert(buf.dirty_syntax == true, "This should be called only if syntax is dirty!");

	clear_error_list();

	if settings.shell_enable_error_location_colors {
		array_resize(&buf.colors, buf.bytes.len);
	}

	ctx :: Tokenizer.{
		base = TokenizerBase.{
			bytes = buf.bytes,
		},
	};

	loop {
		using Token.kind;

		token :: next_token(&ctx);
		if token.kind == EOF { break; }

		if token.len > 0 && settings.shell_enable_error_location_colors {
			memset(&buf.colors[token.index], auto token.kind, auto token.len);
		}
	}
}

#scope_private

Tokenizer :: struct #base TokenizerBase {
}

Token :: struct {
	kind: enum u8 {
		EOF = -1;

		ERROR   = ANSI_COLOR_RED_INDEX;
		WARNING = ANSI_COLOR_YELLOW_INDEX;
	};

	index: s32;
	len:   s32;
}

next_token :: fn (ctx: *Tokenizer) Token {
	using Token.kind;

	loop ctx.index < ctx.bytes.len {
		eat_whitespace(ctx);
		t :: Token.{
			kind  = EOF,
			index = ctx.index,
		};

		if parse_line(ctx, &t) { return t; }
	}

	return Token.{ kind = EOF };
}

parse_line :: fn (ctx: *Tokenizer, t: *Token) bool {
	using Token.kind;

	line := eat_line_and_trim_eol(ctx);
	orig_len :: line.len;

	loc: ErrorLocation;

	valid := try_location_clang_like(line, &loc, &line);
	if !valid { valid = try_location_cl_like(line, &loc, &line); }

	if !valid { return false; }

	line = trim_left(line, " ");
	if line.len == 0 { return false; }

	if str_match(string_view.{ 5, &line[0] }, "error") {
		t.kind = ERROR;
		t.len  = auto orig_len;

		loc.kind      = ErrorLocation.kind.ERROR;
		loc.message   = line;
		loc.file_hash = get_file_hash(loc.file);

		array_push(&error_list, loc);
		return true;
	} else if str_match(string_view.{ 7, &line[0] }, "warning") {
		t.kind = WARNING;
		t.len  = auto orig_len;

		loc.kind      = ErrorLocation.kind.WARNING;
		loc.message   = line;
		loc.file_hash = get_file_hash(loc.file);

		array_push(&error_list, loc);
		return true;
	}
	return false;
}

try_location_clang_like :: fn (line: string_view, loc: *ErrorLocation, rest_of_the_line: *string_view) bool #inline {
	l := line;

	lhs: string_view;
	if !str_split_by_first(l, ':', &lhs, &l) { return false; }
	// Special case on Windows if we have the full file path...
	if lhs.len == 1 && is_alpha(lhs[0]) && str_split_by_first(l, ':', &lhs, &l) {
		lhs.len += 2; // C:
		lhs.ptr  = line.ptr;
	}

	// lsh filename
	file :: lhs;

	if !str_split_by_first(l, ':', &lhs, &l) { return false; }
	// lhs line
	ln, err_line :: strtos64(lhs);
	if err_line { return false; }

	if !str_split_by_first(l, ':', &lhs, &l) { return false; }
	// lhs column
	col :: strtos64(lhs);

	loc.file = file;
	loc.line = auto ln;
	loc.col  = auto col;
	@rest_of_the_line = l;

	return true;
}

try_location_cl_like :: fn (line: string_view, loc: *ErrorLocation, rest_of_the_line: *string_view) bool #inline {
	l := line;

	lhs: string_view;
	if !str_split_by_first(l, ':', &lhs, &l) then return false;
	// Special case on Windows if we have the full file path...
	if lhs.len == 1 && is_alpha(lhs[0]) && str_split_by_first(l, ':', &lhs, &l) {
		lhs.len += 2; // C:
		lhs.ptr  = line.ptr;
	}

	if lhs.len == 0          then return false;
	if lhs[lhs.len-1] != ')' then return false;
	@rest_of_the_line = l;

	if !str_split_by_last(lhs, '(', &lhs, &l) then return false;

	// lsh filename
	loc.file = lhs;
	if !str_split_by_last(l, ')', &lhs, &l) then return false;

	line_str, col_str: string_view;
	str_split_by_first(lhs, ',', &line_str, &col_str);

	if line_str.len > 0 {
		ln :: strtos64(line_str) catch return false;
		loc.line = auto ln;
	}

	if col_str.len > 0 {
		col, err :: strtos64(col_str);
		loc.col = if err then 0 else auto col;
	} else {
		loc.col = 0;
	}

	return true;
}
highlight_build_syntax :: fn (buf: *Buffer) {
	assert(buf.dirty_syntax == true, "This should be called only if syntax is dirty!");

	clear_error_list();
	buf.file_links.len = 0;

	if settings.shell_enable_error_location_colors {
		array_resize(&buf.colors, buf.bytes.len);
	}

	ctx :: Tokenizer.{
		base = TokenizerBase.{
			bytes = buf.bytes,
		},
	};
	
	regex_init(&regex, "^((?:[a-zA-Z]:[/\\\\]|\\.?[/\\\\]?|/)[^:\\n]+):(\\d+):(\\d+)") catch print_err($);
	defer regex_terminate(&regex);

	loop {
		using Token.kind;

		token :: next_token(buf, &ctx);
		if token.kind == EOF { break; }

		if token.len > 0 && settings.shell_enable_error_location_colors {
			memset(&buf.colors[token.index], auto token.kind, auto token.len);
		}
	}
}

#scope_private

regex: Regex;

Tokenizer :: struct #base TokenizerBase {
}

Token :: struct {
	kind: enum u8 {
		EOF = -1;

		ERROR   = ANSI_COLOR_RED_INDEX;
		WARNING = ANSI_COLOR_YELLOW_INDEX;
	};

	index: s32;
	len:   s32;
}

next_token :: fn (buf: *Buffer, ctx: *Tokenizer) Token {
	using Token.kind;

	loop ctx.index < ctx.bytes.len {
		eat_whitespace(ctx);
		t :: Token.{
			kind  = EOF,
			index = ctx.index,
		};

		if parse_line(buf, ctx, &t) { return t; }
	}

	return Token.{ kind = EOF };
}

parse_line :: fn (buf: *Buffer, ctx: *Tokenizer, t: *Token) bool {
	using Token.kind;

	start_index :: ctx.index;
	line := eat_line_and_trim_eol(ctx);

	if regex_match(&regex, line) {
		defer regex_done(&regex);
		matching :: regex_get_match(&regex);
		if matching.len != 4 then return false;

		t.kind = ERROR;
		t.len  = auto matching[0].end - matching[0].start;
		
		filepath :: string_view.{ matching[1].end - matching[1].start, &line[matching[1].start] };
		ln       :: string_view.{ matching[2].end - matching[2].start, &line[matching[2].start] };
		col      :: string_view.{ matching[3].end - matching[3].start, &line[matching[3].start] };
		
		// print_log("file: %", filepath);
		// print_log("    line: %", ln);
		// print_log("    col:  %", col);
		
		array_push(&buf.file_links, FileLocation.{
				start = start_index + matching[0].start,
				end   = start_index + matching[0].end
			});
		
		return true;
	}

	return false;

	/*
	orig_len :: line.len;

	loc: ErrorLocation;

	valid := try_location_clang_like(line, &loc, &line);
	if !valid { valid = try_location_cl_like(line, &loc, &line); }

	if !valid { return false; }

	line = trim_left(line, " ");
	if line.len == 0 { return false; }

	if str_match(string_view.{ 5, &line[0] }, "error") {
		t.kind = ERROR;
		t.len  = auto orig_len;

		loc.kind      = ErrorLocation.kind.ERROR;
		loc.message   = line;
		loc.file_hash = get_file_hash(loc.file);

		array_push(&error_list, loc);
		return true;
	} else if str_match(string_view.{ 7, &line[0] }, "warning") {
		t.kind = WARNING;
		t.len  = auto orig_len;

		loc.kind      = ErrorLocation.kind.WARNING;
		loc.message   = line;
		loc.file_hash = get_file_hash(loc.file);

		array_push(&error_list, loc);
		return true;
	}
	return false;
	*/
}

try_location_clang_like :: fn (line: string_view, loc: *ErrorLocation, rest_of_the_line: *string_view) bool #inline {
	l := line;

	lhs: string_view;
	if !str_split_by_first(l, ':', &lhs, &l) { return false; }
	// Special case on Windows if we have the full file path...
	if lhs.len == 1 && is_alpha(lhs[0]) && str_split_by_first(l, ':', &lhs, &l) {
		lhs.len += 2; // C:
		lhs.ptr  = line.ptr;
	}

	// lsh filename
	file :: lhs;

	if !str_split_by_first(l, ':', &lhs, &l) { return false; }
	// lhs line
	ln, err_line :: strtos64(lhs);
	if err_line { return false; }

	if !str_split_by_first(l, ':', &lhs, &l) { return false; }
	// lhs column
	col :: strtos64(lhs);

	loc.file = file;
	loc.line = auto ln;
	loc.col  = auto col;
	@rest_of_the_line = l;

	return true;
}

try_location_cl_like :: fn (line: string_view, loc: *ErrorLocation, rest_of_the_line: *string_view) bool #inline {
	l := line;

	lhs: string_view;
	if !str_split_by_first(l, ':', &lhs, &l) { return false; }
	// Special case on Windows if we have the full file path...
	if lhs.len == 1 && is_alpha(lhs[0]) && str_split_by_first(l, ':', &lhs, &l) {
		lhs.len += 2; // C:
		lhs.ptr  = line.ptr;
	}

	if lhs.len == 0          { return false; }
	if lhs[lhs.len-1] != ')' { return false; }
	@rest_of_the_line = l;

	if !str_split_by_last(lhs, '(', &lhs, &l) { return false; }

	// lsh filename
	file :: lhs;
	if !str_split_by_last(l, ')', &lhs, &l) { return false; }

	ln, err_line :: strtos64(lhs);
	if err_line { return false; }

	col :: 0; // No such information in the string.

	loc.file = file;
	loc.line = auto ln;
	loc.col  = auto col;

	return true;
}
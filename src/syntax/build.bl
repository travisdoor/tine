highlight_build_syntax :: fn (buf: *Buffer) {
	assert(buf.dirty_syntax == true, "This should be called only if syntax is dirty!");
}

#scope_private

/*
Tokenizer :: struct #base TokenizerBase {
}

Token :: struct {
	kind: enum u8 {
		EOF = -1;

		ERROR   = ANSI_COLOR_RED_INDEX;
		WARNING = ANSI_COLOR_YELLOW_INDEX;
	};

	index: s32;
	len:   s32;
}

next_token :: fn (buf: *Buffer, ctx: *Tokenizer) Token {
	using Token.kind;

	loop ctx.index < ctx.bytes.len {
		eat_whitespace(ctx);
		t :: Token.{
			kind  = EOF,
			index = ctx.index,
		};

		if parse_line(buf, ctx, &t) { return t; }
	}

	return Token.{ kind = EOF };
}

parse_line :: fn (buf: *Buffer, ctx: *Tokenizer, t: *Token) bool {
	using Token.kind;

	start_index :: ctx.index;
	line := eat_line_and_trim_eol(ctx);

	if regex_match(&regex, line) {
		defer regex_done(&regex);
		matching :: regex_get_match(&regex);
		if matching.len < 3 then return false;

		t.kind = ERROR;
		t.len  = auto matching[0].end - matching[0].start;

		filepath :: string_view.{ matching[1].end - matching[1].start, &line[matching[1].start] };
		ln_str   :: string_view.{ matching[2].end - matching[2].start, &line[matching[2].start] };
		cl_str   :: if matching.len > 3 then string_view.{ matching[3].end - matching[3].start, &line[matching[3].start] } else "0";

		ln :: strtos64(ln_str);
		cl :: strtos64(cl_str);

		array_push(&buf.file_links, FileLink.{
				start    = start_index + matching[0].start,
				end      = start_index + matching[0].end,
				filepath = filepath,
				ln       = auto math.max(ln, 1),
				cl       = auto math.max(cl, 1)
			});

		return true;
	}

	return false;

	orig_len :: line.len;

	loc: ErrorLocation;

	valid := try_location_clang_like(line, &loc, &line);
	if !valid { valid = try_location_cl_like(line, &loc, &line); }

	if !valid { return false; }

	line = trim_left(line, " ");
	if line.len == 0 { return false; }

	if str_match(string_view.{ 5, &line[0] }, "error") {
		t.kind = ERROR;
		t.len  = auto orig_len;

		loc.kind      = ErrorLocation.kind.ERROR;
		loc.message   = line;
		loc.file_hash = get_file_hash(loc.file);

		array_push(&error_list, loc);
		return true;
	} else if str_match(string_view.{ 7, &line[0] }, "warning") {
		t.kind = WARNING;
		t.len  = auto orig_len;

		loc.kind      = ErrorLocation.kind.WARNING;
		loc.message   = line;
		loc.file_hash = get_file_hash(loc.file);

		array_push(&error_list, loc);
		return true;
	}
	return false;
}

try_location_clang_like :: fn (line: string_view, loc: *ErrorLocation, rest_of_the_line: *string_view) bool #inline {
	l := line;

	lhs: string_view;
	if !str_split_by_first(l, ':', &lhs, &l) { return false; }
	// Special case on Windows if we have the full file path...
	if lhs.len == 1 && is_alpha(lhs[0]) && str_split_by_first(l, ':', &lhs, &l) {
		lhs.len += 2; // C:
		lhs.ptr  = line.ptr;
	}

	// lsh filename
	file :: lhs;

	if !str_split_by_first(l, ':', &lhs, &l) { return false; }
	// lhs line
	ln, err_line :: strtos64(lhs);
	if err_line { return false; }

	if !str_split_by_first(l, ':', &lhs, &l) { return false; }
	// lhs column
	col :: strtos64(lhs);

	loc.file = file;
	loc.line = auto ln;
	loc.col  = auto col;
	@rest_of_the_line = l;

	return true;
}

try_location_cl_like :: fn (line: string_view, loc: *ErrorLocation, rest_of_the_line: *string_view) bool #inline {
	l := line;

	lhs: string_view;
	if !str_split_by_first(l, ':', &lhs, &l) { return false; }
	// Special case on Windows if we have the full file path...
	if lhs.len == 1 && is_alpha(lhs[0]) && str_split_by_first(l, ':', &lhs, &l) {
		lhs.len += 2; // C:
		lhs.ptr  = line.ptr;
	}

	if lhs.len == 0          { return false; }
	if lhs[lhs.len-1] != ')' { return false; }
	@rest_of_the_line = l;

	if !str_split_by_last(lhs, '(', &lhs, &l) { return false; }

	// lsh filename
	file :: lhs;
	if !str_split_by_last(l, ')', &lhs, &l) { return false; }

	ln, err_line :: strtos64(lhs);
	if err_line { return false; }

	col :: 0; // No such information in the string.

	loc.file = file;
	loc.line = auto ln;
	loc.col  = auto col;

	return true;
}
*/
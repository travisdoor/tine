Command :: enum {
	UNKNOWN;
	_PUBLIC;

	DEBUG_REPORT;

	// Navigation
	MOVE_RIGHT;
	MOVE_LEFT;
	MOVE_UP;
	MOVE_DOWN;
	JUMP_BEGIN;
	JUMP_END;
	JUMP_NEXT_PARAGRAPH;
	JUMP_PREV_PARAGRAPH;
	JUMP_LINE_END;
	JUMP_LINE_BEGIN;
	JUMP_INDENT_BEGIN;
	JUMP_NEXT_WORD;
	JUMP_PREV_WORD;
	JUMP_PAGE_UP;
	JUMP_PAGE_DOWN;
	CENTER_VIEW;
	NEXT_ERROR;
	PREV_ERROR;
	NEXT_LOCATION;
	PREV_LOCATION;
	LSP_GOTO_DECLARATION;
	LSP_GOTO_DECLARATION_OTHER_SPLIT;
	LSP_OTHER_FILE;
	LSP_OTHER_FILE_OTHER_SPLIT;

	// Editation
	INSERT_NEW_LINE;
	INSERT_TAB;
	DELETE_CHAR_LEFT;
	DELETE_CHAR_RIGHT;
	DELETE_WORD_LEFT;
	DELETE_LINE;
	DUPLICATE_LINE;
	SET_SELECTION_MARKER;
	SMART_SELECTION;
	SELECT_ALL;
	SELECT_WORD;
	SELECT_LINE;
	SELECT_WHOLE_LINE;
	SELECT_PARAGRAPH;
	COPY;
	PASTE;
	CUT;
	TRIM_TRAILING_WHITESPACE;
	TO_LOWER;
	TO_UPPER;
	INDENT;
	CLANG_FORMAT;
	TOGGLE_COMMENT;
	SORT;
	INCREASE_NUMBER;
	DECREASE_NUMBER;

	// Splits
	OTHER_SPLIT;
	CLOSE_SPLIT;
	CLOSE_OTHER_SPLIT;

	// Buffers
	CLOSE_BUFFER;
	FORCE_CLOSE_BUFFER;
	SAVE;
	SAVE_ALL;
	NEW_BUFFER;

	// Modes
	OPEN_FILE;
	QUICK_OPEN;
	SAVE_AS;
	GOTO_LINE;
	CANCEL_MODE;
	RUN_COMMAND;
	SEARCH_FILE;
	OPEN_PROJECT;
	SEARCH_IN_PROJECT;
	SEARCH_REPLACE;
	PEEK_ERROR;
	LIST_FUNCTIONS;
	REPEAT;
	SHELL;

	// MISC
	BREAK_IN_REMEDYBG;
	BREAK_IN_RADDBG;
	BUILD;
	BUILD_KILL;
	SHELL_KILL;
	CLEAR_MESSAGES;
	DEBUG_IN_REMEDYBG;
	DEBUG_IN_RADDBG;
	DECREASE_FONT_SIZE;
	GOOGLE_SELECTION;
	HELP;
	INCREASE_FONT_SIZE;
	KILL_ASYNC_JOBS;
	LSP_COMPLETION;
	LSP_KILL_SERVER;
	LSP_RESTART_SERVER;
	OPEN_DEFAULT_CONFIG;
	OPEN_IN_REMEDYBG;
	OPEN_IN_RADDBG;
	OPEN_IN_VISUAL_STUDIO;
	OPEN_MESSAGES;
	OPEN_PROJECTS_DIRECTORY;
	OPEN_PROJECT_CONFIG;
	REDO;
	SEARCH_TO_BUFFER;
	UNDO;
	OPEN_FILE_LOCATION;
	DATE;
	TOGGLE_MACRO_RECORDING;
	REPLAY_MACRO;

	SUPPORT_ME;
}

COMMAND_NAMES :: get_enum_variants_as_redable_list(Command);
COMMAND_HELP  :: make_command_help();

make_command_help :: fn () [enum_count(Command)]string_view #comptime {
	using Command;
	help: [enum_count(Command)]string_view;

	help[auto MOVE_RIGHT]          = "Move cursor one character right.";
	help[auto MOVE_LEFT]           = "Move cursor one character left.";
	help[auto MOVE_UP]             = "Move cursor one line up.";
	help[auto MOVE_DOWN]           = "Move cursor one line down.";
	help[auto JUMP_BEGIN]          = "Move cursor at the document begin.";
	help[auto JUMP_END]            = "Move cursor at the document end.";
	help[auto JUMP_NEXT_PARAGRAPH] = "Move cursor at the beginning of the next paragraph.";
	help[auto JUMP_PREV_PARAGRAPH] = "Move cursor at the end of the previous paragraph.";
	help[auto JUMP_LINE_END]       = "Move cursor at the end of the current line.";
	help[auto JUMP_LINE_BEGIN]     = "Move cursor at the begin of the current line.";
	help[auto JUMP_INDENT_BEGIN]   = "Move cursor at the begin of the current line content (skipping whitespace).";
	help[auto JUMP_NEXT_WORD]      = "Move cursor to the next word begin.";
	help[auto JUMP_PREV_WORD]      = "Move cursor to the previous word end.";
	help[auto JUMP_PAGE_UP]        = "Move cursor one page up.";
	help[auto JUMP_PAGE_DOWN]      = "Move cursor one page down.";
	help[auto CENTER_VIEW]         = "Center current view to the cursor.";
	help[auto NEXT_ERROR]          = "Jump to the next error in the error list.";
	help[auto PREV_ERROR]          = "Jump to the previous error in the error list.";
	help[auto NEXT_LOCATION]       = "Jump to the next location.";
	help[auto PREV_LOCATION]       = "Jump to the previous location.";

	// LSP
	help[auto LSP_GOTO_DECLARATION]             = "Go to delaration of the current symbol under cursor using LSP.";
	help[auto LSP_GOTO_DECLARATION_OTHER_SPLIT] = "Go to delaration of the current symbol under cursor using LSP and open the location in other split.";
	help[auto LSP_OTHER_FILE]                   = "Try to open related header file.";
	help[auto LSP_OTHER_FILE_OTHER_SPLIT]       = "Try to open related header file in other split.";

	help[auto INSERT_NEW_LINE]          = "Insert new line into current document.";
	help[auto INSERT_TAB]               = "Insert tab into current document.";
	help[auto DELETE_CHAR_LEFT]         = "Delete one character before cursor.";
	help[auto DELETE_CHAR_RIGHT]        = "Delete one character after cursor.";
	help[auto DELETE_WORD_LEFT]         = "Delete one word before cursor.";
	help[auto DELETE_LINE]              = "Delete current line.";
	help[auto DUPLICATE_LINE]           = "Duplicate current line.";
	help[auto SET_SELECTION_MARKER]     = "Start selection.";
	help[auto SMART_SELECTION]          = "Each invocation in row selects word, line content, whole line and whole paragraph.";
	help[auto SELECT_ALL]               = "Select whole document.";
	help[auto SELECT_WORD]              = "Select current word.";
	help[auto SELECT_LINE]              = "Select current line content.";
	help[auto SELECT_WHOLE_LINE]        = "Select current line.";
	help[auto SELECT_PARAGRAPH]         = "Select current paragraph.";
	help[auto COPY]                     = "Copy current selection to the clipboard.";
	help[auto PASTE]                    = "Paste clipboard content to the document.";
	help[auto CUT]                      = "Cut current selection to the clipboard.";
	help[auto TRIM_TRAILING_WHITESPACE] = "Remove trailing whitespace from whole document.";
	help[auto TO_LOWER]                 = "Convert current selection to lower case.";
	help[auto TO_UPPER]                 = "Convert current selection to upper case.";
	help[auto INDENT]                   = "Indent current line or selection based on indentation rules for current file type.";
	help[auto CLANG_FORMAT]             = "Invoke clang format on current document.";
	help[auto TOGGLE_COMMENT]           = "Comment or uncomment current selection or line based on current file type.";
	help[auto SORT]                     = "Alphabetically sort selected lines.";

	help[auto OTHER_SPLIT]       = "Switch focus to other split.";
	help[auto CLOSE_SPLIT]       = "";
	help[auto CLOSE_OTHER_SPLIT] = "";

	help[auto CLOSE_BUFFER]       = "";
	help[auto FORCE_CLOSE_BUFFER] = "Close current buffer without saving.";
	help[auto SAVE]               = "";
	help[auto SAVE_ALL]           = "";
	help[auto NEW_BUFFER]         = "Create new scratch buffer.";

	help[auto OPEN_FILE]         = "Activate open file mode.";
	help[auto QUICK_OPEN]        = "Activate open file mode with recursive search in current project.";
	help[auto SAVE_AS]           = "";
	help[auto GOTO_LINE]         = "";
	help[auto CANCEL_MODE]       = "";
	help[auto RUN_COMMAND]       = "";
	help[auto SEARCH_FILE]       = "";
	help[auto OPEN_PROJECT]      = "";
	help[auto SEARCH_IN_PROJECT] = "";
	help[auto SEARCH_REPLACE]    = "";
	help[auto PEEK_ERROR]        = "Peek full error message on current line if there is one.";
	help[auto LIST_FUNCTIONS]    = "List functions in current buffer. This information might not be available for all file types.";
	help[auto REPEAT]            = "Activate repeat mode (execute next comand N times).";
	help[auto SHELL]             = "Execute shell command in current working directory.";

	help[auto BREAK_IN_REMEDYBG]       = "Set current file location as breakpoint in RemedyBG.";
	help[auto BREAK_IN_RADDBG]         = "Set current file location as breakpoint in RAD Debugger.";
	help[auto BUILD]                   = "Try to execute `build.bat` script if found in current project root directory and output in the 'build' buffer.";
	help[auto BUILD_KILL]              = "Try to kill running build script.";
	help[auto SHELL_KILL]              = "Try to kill running shell script.";
	help[auto CLEAR_MESSAGES]          = "Clear 'messages' buffer.";
	help[auto DEBUG_IN_REMEDYBG]       = "Start debugging in running RemedyBG instance.";
	help[auto DEBUG_IN_RADDBG]         = "Start debugging in running RAD Debugger instance.";
	help[auto DECREASE_FONT_SIZE]      = "";
	help[auto GOOGLE_SELECTION]        = "Pass the current selection to the google.com search in default system browser.";
	help[auto HELP]                    = "";
	help[auto INCREASE_FONT_SIZE]      = "";
	help[auto KILL_ASYNC_JOBS]         = "Kill all running async jobs.";
	help[auto LSP_COMPLETION]          = "Activate LSP completion mode on current subject under cursor.";
	help[auto LSP_KILL_SERVER]         = "";
	help[auto LSP_RESTART_SERVER]      = "";
	help[auto OPEN_DEFAULT_CONFIG]     = "";
	help[auto OPEN_IN_REMEDYBG]        = "Open current file location in RemedyBG.";
	help[auto OPEN_IN_RADDBG]          = "Open current file location in RAD Debugger.";
	help[auto OPEN_IN_VISUAL_STUDIO]   = "Open current file location in Visual Studio.";
	help[auto OPEN_MESSAGES]           = "";
	help[auto OPEN_PROJECTS_DIRECTORY] = "";
	help[auto OPEN_PROJECT_CONFIG]     = "Open configuration file of current project.";
	help[auto REDO]                    = "Open configuration file of current project.";
	help[auto SEARCH_TO_BUFFER]        = "Redirect search results into separate buffer.";
	help[auto UNDO]                    = "Undo latest chages.";
	help[auto OPEN_FILE_LOCATION]      = "Open current file location in default system file manager.";
	help[auto DATE]                    = "Inserts current system date into focused buffer.";

	help[auto SUPPORT_ME]              = "Consider supporting this project via PayPal.";

	help[auto TOGGLE_MACRO_RECORDING]  = "Start/Stop macro sequence recording.";
	help[auto REPLAY_MACRO]            = "Replay last recorded macro sequence.";

	help[auto INCREASE_NUMBER]         = "Increase number under cursor by one.";
	help[auto DECREASE_NUMBER]         = "Decrease number under cursor by one.";

	return help;
}

KeyMapEntry :: struct {
	cmd:  Command;
	mods: s32;
	key:  s32;
};

key_binding: [..]KeyMapEntry;

invoke_command :: fn (editor: *Editor, buf: *Buffer, cmd: Command) {
	using Command;
	defer set_prev_executed_command(cmd);

	if prev_executed_command != cmd then commit_undo(buf);
	// print_log("Executed command: %", cmd);

	handled := false;

	switch mode {
		Mode.TEXT_EDIT         { handled = invoke_command_text_edit_mode         (buf, cmd); }
		Mode.GOTO_LINE         { handled = invoke_command_goto_line_mode         (buf, cmd); }
		Mode.OPEN_FROM_DRIVE   { handled = invoke_command_open_from_drive_mode   (buf, cmd); }
		Mode.QUICK_OPEN        { handled = invoke_command_quick_open_mode        (buf, cmd); }
		Mode.SAVE_TO_DRIVE     { handled = invoke_command_save_to_drive_mode     (buf, cmd); }
		Mode.RUN_COMMAND       { handled = invoke_command_run_command_mode       (buf, cmd); }
		Mode.SEARCH_FILE       { handled = invoke_command_search_mode            (buf, cmd); }
		Mode.OPEN_PROJECT      { handled = invoke_command_open_project_mode      (buf, cmd); }
		Mode.SEARCH_IN_PROJECT { handled = invoke_command_search_in_project_mode (buf, cmd); }
		Mode.COMPLETION        { handled = invoke_command_completion_mode        (buf, cmd); }
		Mode.REPLACE           { handled = invoke_command_replace_mode           (buf, cmd); }
		Mode.LIST_FUNCTIONS    { handled = invoke_command_list_functions_mode    (buf, cmd); }
		Mode.REPEAT            { handled = invoke_command_repeat_line_mode       (buf, cmd); }
		Mode.SHELL_RUN         { handled = invoke_command_shell_run_mode         (buf, cmd); }

		default;
	}

	// Command was handled by current mode.
	if !handled {

		// handle general commands used in all modes
		switch cmd {
			MOVE_LEFT            { move_left             (editor, buf); }
			MOVE_RIGHT           { move_right            (editor, buf); }
			JUMP_LINE_END        { jump_line_end         (editor, buf); }
			JUMP_LINE_BEGIN      { jump_line_begin       (editor, buf); }
			JUMP_NEXT_WORD       { jump_next_word        (editor, buf); }
			JUMP_PREV_WORD       { jump_prev_word        (editor, buf); }
			INSERT_TAB           { insert_tab            (editor, buf); }
			DELETE_CHAR_LEFT     { delete_left           (editor, buf); }
			DELETE_CHAR_RIGHT    { delete_right          (editor, buf); }
			DELETE_LINE          { delete_line           (editor, buf); }
			DUPLICATE_LINE       { duplicate_line        (editor, buf); }
			DELETE_WORD_LEFT     { delete_word_left      (editor, buf); }
			SMART_SELECTION      { smart_selection       (editor, buf); }
			SET_SELECTION_MARKER { start_selection       (buf, editor.cursor_index); }
			SELECT_ALL           { select_all            (editor, buf); }
			SELECT_WORD          { select_word           (editor, buf); }
			SELECT_LINE          { select_line           (editor, buf); }
			SELECT_WHOLE_LINE    { select_whole_line     (editor, buf); }
			SELECT_PARAGRAPH     { select_paragraph      (editor, buf); }
			COPY                 { copy_selection        (editor, buf); }
			PASTE                { paste                 (editor, buf); }
			CUT                  { cut_selection         (editor, buf); }
			GOOGLE_SELECTION     { google_selection      (editor, buf); }

			TO_LOWER {
				selection_to_upper_or_lower(editor, buf, ToUpperOrLower.LOWER);
			}

			TO_UPPER {
				selection_to_upper_or_lower(editor, buf, ToUpperOrLower.UPPER);
			}

			// Does nothing in case we're already in default mode (TEXT_EDIT).
			CANCEL_MODE {
				set_default_mode();
				clear_selection(buf, editor.cursor_index);
				// if !mode_changed && build.buffer_index != -1 {
				// 	buffer_index :: build.buffer_index;
				// 	assert(buffer_index >= 0 && buffer_index < buffers.len);
				// 	if !buffers[buffer_index].is_removed {
				// 		close_buffer(buffer_index);
				// 	}
				// }
			}

			// Not handled...
			default;
		}
	}

	if cmd != TOGGLE_MACRO_RECORDING && macros.is_recording then add_macro_record(cmd);
}

lookup_command_keymap_index :: fn (cmd: Command, start_index := 0) s32 {
	loop i := start_index; i < key_binding.len; i += 1 {
		if key_binding[i].cmd == cmd {
			return i;
		}
	}
	return -1;
}

keymap_entry_to_string :: fn (keymap_index: s32) string_view {
	if keymap_index < 0 { return ""; }
	e :: &key_binding[keymap_index];
	if e.key < 0 { return ""; }

	using glfw;

	tmp :: str_new(application_context.temporary_allocator);

	MODS :: [4]s32.{ MOD_CONTROL, MOD_ALT, MOD_SHIFT, MOD_SUPER };
	loop i := 0; i < MODS.len; i += 1 {
		name :: mod_name(e.mods & MODS[i]);
		if name.len == 0 { continue; }
		if tmp.len > 0 { str_append(&tmp, "+"); }
		str_append(&tmp, name);
	}

	if tmp.len > 0 { str_append(&tmp, "+"); }
	str_append(&tmp, key_name(e.key));
	return tmp;
}

// Just to make it deferable;
set_prev_executed_command :: fn (cmd: Command) #inline {
	prev_executed_command = cmd;
}

select_all :: fn (editor: *Editor, buf: *Buffer) {
	jump_begin(editor, buf);
	start_selection(buf, editor.cursor_index);
	jump_end(editor, buf);
}

copy_selection :: fn (editor: *Editor, buf: *Buffer) bool {
	text :: peek_selection(buf, editor.cursor_index);
	if text.len == 0 {
		return false;
	}
	write_clipboard(text);
	clear_selection(buf, editor.cursor_index);
	return true;
}

cut_selection :: fn (editor: *Editor, buf: *Buffer, copy_to_clipboard := true) {
	start, end :: get_selection_range(buf, editor.cursor_index);
	if start == end then return;
	if maybe_report_readonly(buf) then return;

	text :: string_view.{ end - start, &buf.bytes[start] };
	if str_match(text, get_line_ending(buf.line_ending)) == false && copy_to_clipboard {
		write_clipboard(text);
	}
	clear_selection(buf, editor.cursor_index);
	delete_range(buf, start, end);
}

paste :: fn (editor: *Editor, buf: *Buffer, record_as_single_undo_action := true) {
	text := read_clipboard();

	if text.len == 0 then return;
	if maybe_report_readonly(buf) then return;

	// @Cleanup: [travis] Factor out to function??? We already have is_row_empty but this cannot skip whitespace.
	cursor :: get_cursor(buf, editor.cursor_index);
	row := peek_row_without_new_line(buf, cursor.row);
	row = trim_left(row, "\t ");
	is_line_empty :: row.len == 0;

	text_first_row: string_view;
	is_multiline_text := is_multiline(text, &text_first_row);
	if editor.index == command_editor {
		// Pasted string might be multiline, this is not allowed for the single line command editor.
		text = text_first_row;
	}

	if text.len == 0 {
		// Might be empty in case we're inserting to the command buffer and first line of inserted
		// string is empty.
		return;
	}

	text = unify_line_endings(text, buf.line_ending);

	if record_as_single_undo_action { commit_undo(buf); }

	cut_selection(editor, buf, false);
	start :: get_cursor_position(buf, editor.cursor_index);
	insert_string(buf, start, text);

	if (is_line_empty || is_multiline_text) && has_indentation_info(buf) && settings.indent_on_paste {
		end :: get_cursor_position(buf, editor.cursor_index);
		indent_range(buf, start, end);
	}

	if record_as_single_undo_action { commit_undo(buf); }
	clear_selection(buf);
}

goto_line :: fn (editor: *Editor, buf: *Buffer, line: s64) {
	l := line;
	if l < 0 {
		l = 0;
	} else if l >= buf.lines.len {
		l = buf.lines.len-1;
	}
	set_cursor_position(buf, editor.cursor_index, buf.lines[l]);
}

move_right_by_num_characters :: fn (editor: *Editor, buf: *Buffer, char_num: s32) {
	loop i := 0; i < char_num; i += 1 {
		if !move_right(editor, buf) { break; }
	}
}

jump_line_begin :: fn (editor: *Editor, buf: *Buffer) bool {
	cursor :: get_cursor(buf, editor.cursor_index);
	_, start_position := peek_row(buf, cursor.row);
	set_cursor_position(buf, editor.cursor_index, start_position);
	return true;
}

jump_line_end :: fn (editor: *Editor, buf: *Buffer) bool {
	cursor :: get_cursor(buf, editor.cursor_index);
	row, start_position :: peek_row_without_new_line(buf, cursor.row);
	if row.len == 0 { return false; }
	set_cursor_position(buf, editor.cursor_index, start_position + row.len);
	return true;
}

select_word :: fn (editor: *Editor, buf: *Buffer) {
	position :: get_cursor_position(buf, editor.cursor_index);
	prev_char :: peek_before_position(buf, position);
	if is_ident(buf, prev_char) {
		jump_prev_word(editor, buf);
	}
	start_selection(buf, editor.cursor_index);
	jump_next_word(editor, buf);
}

select_line :: fn (editor: *Editor, buf: *Buffer) {
	jump_indent_begin(editor, buf);
	start_selection(buf, editor.cursor_index);
	jump_line_end(editor, buf);
}

select_whole_line :: fn (editor: *Editor, buf: *Buffer) {
	jump_line_begin(editor, buf);
	start_selection(buf, editor.cursor_index);
	jump_line_end(editor, buf);
}

select_paragraph :: fn (editor: *Editor, buf: *Buffer) {
	jump_prev_paragraph(editor, buf);
	start_selection(buf, editor.cursor_index);
	jump_next_paragraph(editor, buf);
}

// The range is expanded to cover whole line.
indent_range :: fn (buf: *Buffer, start: s64, end: s64) bool {
	if maybe_report_readonly(buf) { return false; }
	assert(end >= start);

	if (end-start) > MAX_INDENTATION_RANGE_BYTES {
		print_warn("Indentation range in the buffer '%' is too large.", buf.name);
		return false;
	}

	// Update the indentation info, note that this is internally skipped in case the buffer syntax
	// is not dirty...
	rebuild_coloring_and_indentation_info(buf);

	s, e :: expand_range_to_whole_rows(buf, start, end);

	str       :: peek_range(buf, s, e);
	new_line  :: get_line_ending(buf.line_ending);

	// we assume new line everytime ending with '\n'.
	assert(new_line[new_line.len-1] == '\n');
	lines :: str_split_by(str, '\n', application_context.temporary_allocator);

	indented := str_new(math.max(str.len, 32)); // 0 cause assertion and we can indent empty lines.
	defer str_delete(&indented);

	if lines.len == 0 {
		// This function might be used also for indentation of cursor on the newly created empty line,
		// in such a case the 'str' is empty, so no lines are creates.
		array_push(&lines, "");
	}

	position := s;
	loop i := 0; i < lines.len; i += 1 {
		line :: lines[i];
		trimmed_line := trim_left(line, " \t");
		trimmed_line  = trim_right(trimmed_line, " \t\r");

		nesting :: find_indentation_for_range(buf, position, position + line.len);
		if trimmed_line.len > 0 || i == 0 {
			append_indentation(&indented, nesting);
			str_append(&indented, trimmed_line);
		}
		if i + 1 < lines.len {
			str_append(&indented, new_line);
		}

		position += line.len + 1; // +1 \n
	}

	if indented.len == 0 || str_match(indented, str) { return false; }

	batch_begin(buf);
	delete_range(buf, s, s + str.len);
	insert_string(buf, s, indented);
	batch_end(buf);

	return true;
}

help :: fn () {
	if help_buffer_index == -1 {
		help_buffer_index = add_implicit_file_buffer("Help", HELP_FILE_DATA, FileType.MD);
	}
	active_editor = find_or_create_editor_in_split(get_active_split(), help_buffer_index);
}

is_command_valid_for_repeating :: fn (cmd: Command) bool {
	using Command;
	switch cmd {
		MOVE_RIGHT,
		MOVE_LEFT,
		MOVE_UP,
		MOVE_DOWN,
		JUMP_NEXT_PARAGRAPH,
		JUMP_PREV_PARAGRAPH,
		JUMP_NEXT_WORD,
		JUMP_PREV_WORD,
		JUMP_PAGE_UP,
		JUMP_PAGE_DOWN,
		NEXT_ERROR,
		PREV_ERROR,
		NEXT_LOCATION,
		PREV_LOCATION,
		INSERT_NEW_LINE,
		INSERT_TAB,
		DELETE_CHAR_LEFT,
		DELETE_CHAR_RIGHT,
		DELETE_WORD_LEFT,
		DELETE_LINE,
		DUPLICATE_LINE,
		PASTE,
		INCREASE_NUMBER,
		DECREASE_NUMBER,
		REDO,
		UNDO,
		REPLAY_MACRO,
		DATE { return true; }
		default;
	}
	return false;
}

#scope_private

SmartSelectionLevel :: enum {
	WORD;
	LINE;
	WHOLE_LINE;
	PARAGRAPH;
}

smart_selection_level: SmartSelectionLevel;

vertical_move_cursor_offset: s32;
prev_executed_command:       Command;

invoke_command_text_edit_mode :: fn (buf: *Buffer, cmd: Command) bool {
	_, editor :: get_active_buffer_and_editor();

	using Command;
	switch cmd {
		MOVE_UP             { move_up             (editor, buf);                           }
		MOVE_DOWN           { move_down           (editor, buf);                           }
		JUMP_BEGIN          { jump_begin          (editor, buf);                           }
		JUMP_END            { jump_end            (editor, buf);                           }
		JUMP_INDENT_BEGIN   { jump_indent_begin   (editor, buf);                           }
		JUMP_NEXT_PARAGRAPH { jump_next_paragraph (editor, buf);                           }
		JUMP_PREV_PARAGRAPH { jump_prev_paragraph (editor, buf);                           }
		JUMP_PAGE_UP        { jump_page_up        (editor, buf);                           }
		JUMP_PAGE_DOWN      { jump_page_down      (editor, buf);                           }
		CENTER_VIEW         { center_view         (editor);                                }
		NEXT_ERROR          { next_error          ();                                      }
		PREV_ERROR          { prev_error          ();                                      }
		NEXT_LOCATION       { jump_to_next_location();                                     }
		PREV_LOCATION       { jump_to_previous_location();                                 }
		LSP_GOTO_DECLARATION{ lsp_goto_declaration(editor, buf);                           }
		LSP_GOTO_DECLARATION_OTHER_SPLIT { lsp_goto_declaration(editor, buf, true);        }
		LSP_OTHER_FILE      { lsp_switch_header_source(buf);                               }
		LSP_OTHER_FILE_OTHER_SPLIT { lsp_switch_header_source(buf, true);                  }
		INSERT_NEW_LINE     { insert_new_line     (editor, buf);                           }
		INDENT              { indent              (editor, buf);                           }
		CLANG_FORMAT        { clang_format        (buf);                                   }
		TOGGLE_COMMENT      { toggle_comment      (editor, buf);                           }
		SORT                { alpha_sort_lines    (editor, buf);                           }
		INCREASE_NUMBER     { add_number_under_cursor(editor, buf,  1);                    }
		DECREASE_NUMBER     { add_number_under_cursor(editor, buf, -1);                    }
		OTHER_SPLIT         { other_split         (buf);                                   }
		CLOSE_SPLIT         { close_split         ();                                      }
		CLOSE_OTHER_SPLIT   { close_other_split   ();                                      }
		CLOSE_BUFFER        { close_buffer_command(buf);                                   }
		FORCE_CLOSE_BUFFER  { force_close_buffer  (buf);                                   }
		SAVE                { save_command        (buf);                                   }
		SAVE_ALL            { save_all            ();                                      }
		NEW_BUFFER          { create_new_buffer   ();                                      }
		INCREASE_FONT_SIZE  { increase_font_size  ();                                      }
		DECREASE_FONT_SIZE  { decrease_font_size  ();                                      }
		UNDO                { undo                (editor, buf);                           }
		REDO                { redo                (editor, buf);                           }
		OPEN_FILE           { set_mode            (Mode.OPEN_FROM_DRIVE);                  }
		QUICK_OPEN          { set_mode            (Mode.QUICK_OPEN);                       }
		SAVE_AS             { set_mode            (Mode.SAVE_TO_DRIVE);                    }
		GOTO_LINE           { set_mode            (Mode.GOTO_LINE);                        }
		REPEAT              { set_mode            (Mode.REPEAT);                           }
		SHELL               { set_mode            (Mode.SHELL_RUN);                        }
		RUN_COMMAND         { set_mode            (Mode.RUN_COMMAND);                      }
		SEARCH_FILE         { set_mode            (Mode.SEARCH_FILE);                      }
		OPEN_PROJECT        { set_mode            (Mode.OPEN_PROJECT);                     }
		SEARCH_IN_PROJECT   { set_mode            (Mode.SEARCH_IN_PROJECT);                }
		PEEK_ERROR          { set_mode            (Mode.PEEK_ERROR);                       }
		LIST_FUNCTIONS      { set_mode            (Mode.LIST_FUNCTIONS);                   }
		DEBUG_REPORT        { debug_report        ();                                      }
		OPEN_PROJECT_CONFIG { open_project_config ();                                      }
		OPEN_DEFAULT_CONFIG { open_default_config ();                                      }
		OPEN_MESSAGES       { open_messages       ();                                      }
		OPEN_IN_VISUAL_STUDIO { open_current_buffer_in_visual_studio(buf);                 }
		OPEN_IN_REMEDYBG    { open_current_buffer_in_remedybg(editor, buf);                }
		OPEN_IN_RADDBG      { open_current_buffer_in_raddbg(editor, buf);                  }
		BREAK_IN_REMEDYBG   { set_current_buffer_breakpoint_in_remedybg(editor, buf);      }
		BREAK_IN_RADDBG     { set_current_buffer_breakpoint_in_raddbg(editor, buf);        }
		DEBUG_IN_REMEDYBG   { debug_in_remedybg   ();                                      }
		DEBUG_IN_RADDBG     { debug_in_raddbg     ();                                      }
		KILL_ASYNC_JOBS     { kill_async_jobs     ();                                      }
		BUILD               { start_build         ();                                      }
		BUILD_KILL          { kill_build          ();                                      }
		SHELL_KILL          { kill_build          ();                                      }
		LSP_KILL_SERVER     { kill_lsp_server     ();                                      }
		LSP_RESTART_SERVER  { restart_lsp_server  ();                                      }
		LSP_COMPLETION      { lsp_completion      (editor, buf);                           }
		HELP                { help                ();                                      }
		CLEAR_MESSAGES      { clear_messages      ();                                      }
		OPEN_FILE_LOCATION  { open_file_location  (buf);                                   }
		DATE                { insert_current_date (editor, buf);                           }

		SEARCH_TO_BUFFER    {
			print_warn("Command 'search-to-buffer' is available only in search modes.");
		}

		OPEN_PROJECTS_DIRECTORY {
			open_path(tprint("\"%/%\"", data_dir, PROJECTS_DIRECTORY));
		}

		TRIM_TRAILING_WHITESPACE { trim_trailing_whitespace(buf); }
		SUPPORT_ME               { support_me();                  }

		TOGGLE_MACRO_RECORDING {
			if macros.is_recording {
				stop_macro_recording();
			} else {
				start_macro_recording();
			}
		}
		REPLAY_MACRO { replay_macro(); }


		// Not handled.
		default { return false; }
	}

	return true;
}

debug_report :: fn () bool {
	print_info("Debug-report:");

	print_info("Buffers:");
	loop i := 0; i < buffers.len; i += 1 {
		buf :: &buffers[i];
		if buf.is_removed {
			print_info("\t[%] (removed)", i);
			continue;
		}
		print_info("\t[%] Name: '%'; Undo records: %; Undo size: %B; Cursor count: %", i, buf.name, buf.undo.len, buf.undo.len * auto sizeof(Rec), buf.cursors.len);
	}

	print_info("\nEditors:");
	loop i := 0; i < editors.len; i += 1 {
		e :: &editors[i];
		if e.is_removed {
			print_info("\t[%] (removed)", i);
			continue;
		}
		print_info("\t[%] Buffer index: %", i, e.buffer_index);
	}

	print_info("\nJump history size: %B", recent_locations.stack.len * auto sizeof(s32));

	return true;
}

is_repeating_command :: fn (cmds: ...Command) bool #inline {
	loop i := 0; i < cmds.len; i += 1 {
		if prev_executed_command == cmds[i] { return true; }
	}
	return false;
}

save_command :: fn (buf: *Buffer) bool {
	if buf.filepath.len == 0 {
		set_mode(Mode.SAVE_TO_DRIVE);
		return false;
	}

	if settings.trim_trailing_whitespace_on_save {
		trim_trailing_whitespace(buf);
	}

	// Move this outside...
	if buf.saved_top == buf.undo_top {
		print_info("No changes to be saved.");
		return OK;
	}

	err :: save_buffer_to_file(buf, buf.filepath);
	if err {
		print_err(err);
		return false;
	}
	return true;
}

save_all :: fn () {
	print_info("Save all.");
	saved_num := 0;
	loop i := 0; i < buffers.len; i += 1 {
		buf :: &buffers[i];
		if buf.is_removed { continue; }
		if buf.filepath.len == 0 { continue; }
		if buf.saved_top == buf.undo_top { continue; }

		saved_num += 1;

		err :: save_buffer_to_file(buf, buf.filepath);
		if err {
			print_err(err);
		}
	}

	if saved_num == 0 {
		print_info("No changes needs to be saved.");
	}
}

undo :: fn (editor: *Editor, buf: *Buffer) bool {
	if (buf.flags & BufferFlags.NO_UNDO) == BufferFlags.NO_UNDO { return false; }
	if buf.undo_top == 0 {
		print_warn("No further undo change.");
		return false;
	}

	clear_selection(buf);

	batch_begin(buf);
	defer batch_end(buf);

	commit_count := 0;
	loop ; buf.undo_top > 0; buf.undo_top -= 1 {
		rec :: &buf.undo[buf.undo_top];
		using Rec.kind;
		switch rec.kind {
			DELETE {
				// transform to insert
				data :: rec.data.delete; // copy
				text :: peek_range(buf, data.start, data.end);
				assert(text.len > 0);

				if get_character_len(text[0]) == text.len {
					c :: utf8_to_utf32_single_char(text);
					rec.kind = INSERT_CHAR;
					rec.data.insert_char.position = data.start;
					rec.data.insert_char.char     = c;
				} else {
					rec.kind = INSERT;
					rec.data.insert.position = data.start;
					rec.data.insert.str      = str_new(text);
				}

				set_cursor_position(buf, editor.cursor_index, data.start);
				delete_range_impl(buf, data.start, data.end);
			}
			INSERT_CHAR {
				data :: rec.data.insert_char; // copy
				str :: unicode_char_to_utf8_with_fallback(data.char);
				set_cursor_position(buf, editor.cursor_index, data.position);
				insert_string_impl(buf, data.position, str);

				rec.kind = DELETE;
				rec.data.delete.start = data.position;
				rec.data.delete.end   = data.position + str.len;
			}
			INSERT {
				data :: rec.data.insert; // copy
				set_cursor_position(buf, editor.cursor_index, data.position);
				insert_string_impl(buf, data.position, data.str);

				rec.kind = DELETE;
				rec.data.delete.start = data.position;
				rec.data.delete.end   = data.position + data.str.len;

				str_delete(&data.str);
			}
			COMMIT   {
				if commit_count > 0 { break; }
				commit_count += 1;
			}
			default { panic(); }
		}
	}

	return true;
}

redo :: fn (editor: *Editor, buf: *Buffer) bool {
	if (buf.flags & BufferFlags.NO_UNDO) == BufferFlags.NO_UNDO { return false; }
	if buf.undo_top == buf.undo.len - 1 {
		print_warn("No further redo change.");
		return false;
	}

	clear_selection(buf);

	batch_begin(buf);
	defer batch_end(buf);

	commit_count := 0;
	loop ;buf.undo_top < buf.undo.len; buf.undo_top += 1 {
		rec :: &buf.undo[buf.undo_top];
		using Rec.kind;
		switch rec.kind {
			INSERT_CHAR {
				data :: rec.data.insert_char; // copy
				set_cursor_position(buf, editor.cursor_index, data.position);
				str :: unicode_char_to_utf8_with_fallback(data.char);
				insert_string_impl(buf, data.position, str);

				rec.kind = DELETE;
				rec.data.delete.start = data.position;
				rec.data.delete.end   = data.position + str.len;
			}
			INSERT {
				data :: rec.data.insert; // copy
				set_cursor_position(buf, editor.cursor_index, data.position);
				insert_string_impl(buf, data.position, data.str);

				rec.kind = DELETE;
				rec.data.delete.start = data.position;
				rec.data.delete.end   = data.position + data.str.len;

				str_delete(&data.str);
			}
			DELETE {
				data :: rec.data.delete; // copy
				text :: peek_range(buf, data.start, data.end);
				assert(text.len > 0);

				if get_character_len(text[0]) == text.len {
					c :: utf8_to_utf32_single_char(text);

					rec.kind = INSERT_CHAR;
					rec.data.insert_char.position = data.start;
					rec.data.insert_char.char     = c;
				} else {
					rec.kind = INSERT;
					rec.data.insert.position = data.start;
					rec.data.insert.str      = str_new(text);
				}

				set_cursor_position(buf, editor.cursor_index, data.start);
				delete_range_impl(buf, data.start, data.end);
			}
			COMMIT {
				if commit_count > 0 { break; }
				commit_count += 1;
			}
			default { panic(); }
		}
	}

	return true;
}

delete_left :: fn (editor: *Editor, buf: *Buffer) {
	if maybe_report_readonly(buf) { return; }
	if has_selection(buf, editor.cursor_index) {
		if editor.index == command_editor {
			start, end :: get_selection_range(buf, editor.cursor_index);
			delete_range(buf, start, end);
			clear_selection(buf);
		} else {
			cut_selection(editor, buf, false);
		}
		return;
	}

	position :: get_cursor_position(buf, editor.cursor_index);
	char :: peek_before_position(buf, position);
	if char.len == 0 { return; }
	delete_range(buf, position - char.len, position);
}

delete_right :: fn (editor: *Editor, buf: *Buffer) {
	if maybe_report_readonly(buf) { return; }
	if has_selection(buf, editor.cursor_index) {
		if editor.index == command_editor {
			start, end :: get_selection_range(buf, editor.cursor_index);
			delete_range(buf, start, end);
			clear_selection(buf);
		} else {
			cut_selection(editor, buf, false);
		}
		return;
	}

	position :: get_cursor_position(buf, editor.cursor_index);
	char :: peek_position(buf, position);
	if char.len == 0 { return; }
	delete_range(buf, position, position + char.len);
}

insert_new_line :: fn (editor: *Editor, buf: *Buffer) bool {
	if buf.index == search_buffer_index {
		cur :: get_cursor(buf, editor.cursor_index);
		line :: peek_row_without_new_line(buf, cur.row);
		filepath, row, col :: get_location_from_search_result_string(line);
		if filepath.len != 0 {
			other_split(buf);
			open_location(filepath, row-1, col-1);
			return true;
		}
	}

	if maybe_report_readonly(buf) { return false; }
	commit_undo(buf);

	if has_selection(buf, editor.cursor_index) {
		cut_selection(editor, buf, false);
	}

	position := get_cursor_position(buf, editor.cursor_index);
	insert_string(buf, position, get_line_ending(buf.line_ending));

	indent_enabled :: has_indentation_info(buf) && settings.indent_on_new_line;
	position = get_cursor_position(buf, editor.cursor_index);

	if indent_enabled {
		indent_range(buf, position, position);
		jump_indent_begin(editor, buf);
	}

	commit_undo(buf);
	return true;
}

indent :: fn (editor: *Editor, buf: *Buffer) {
	commit_undo(buf);
	defer commit_undo(buf);

	restore_position: s64 = -1;
	if has_selection(buf, editor.cursor_index) {
		// Reindent selection range
		start, end :: get_selection_range(buf, editor.cursor_index);
		clear_selection(buf, editor.cursor_index);
		if indent_range(buf, start, end) {
			restore_position = start;
		}
	} else {
		// Reindent current line if not empty, otherwise just append indentation chars.
		cursor :: get_cursor(buf, editor.cursor_index);
		line, start :: peek_row_without_new_line(buf, cursor.row);
		if indent_range(buf, start, start + cast(s32)line.len) {
			restore_position = start;
		}
	}

	if restore_position > 0 {
		set_cursor_position(buf, editor.cursor_index, restore_position);
		jump_indent_begin(editor, buf);
	}
}

move_left :: fn (editor: *Editor, buf: *Buffer) bool {
	position :: get_cursor_position(buf, editor.cursor_index);
	c :: peek_before_position(buf, position);
	if c.len == 0 { return false; }
	set_cursor_position(buf, editor.cursor_index, position - c.len);
	return true;
}

move_right :: fn (editor: *Editor, buf: *Buffer) bool {
	position :: get_cursor_position(buf, editor.cursor_index);
	c :: peek_position(buf, position);
	if c.len == 0 { return false; }
	set_cursor_position(buf, editor.cursor_index, position + c.len);
	return true;
}


// Note: We use "visual" columns to solve the problem with vertical navigation in case lines
// contains tabs, in general, each tab is represented as settings.tab_size column count. The
// vertical navigation is more visually stable then.
move_by_visual_cols :: fn (editor: *Editor, buf: *Buffer, num_cols: s64) {
	position := get_cursor_position(buf, editor.cursor_index);
	loop i := 0; i < num_cols; {
		char :: peek_position(buf, position);
		if char.len == 0              { break; }
		if is_line_end(buf, char) > 0 { break; }
		if char[0] == '\t' {
			i += settings.tab_size;
		} else {
			i += 1;
		}
		position += char.len;
	}
	set_cursor_position(buf, editor.cursor_index, position);
}

get_row_visual_indentation_cols :: fn (editor: *Editor, buf: *Buffer) s32 {
	cursor :: get_cursor(buf, editor.cursor_index);
	line :: peek_row_without_new_line(buf, cursor.row);
	num := 0;
	loop i := 0; i < line.len; i += 1 {
		c :: line[i];
		switch c {
			' '  { num += 1; }
			'\t' { num += settings.tab_size; }
			default { break; }
		}
	}
	return num;
}

move_down :: fn (editor: *Editor, buf: *Buffer) bool {
	using Command;
	if !is_repeating_command(MOVE_DOWN, MOVE_UP) {
		position :: get_cursor_position(buf, editor.cursor_index);
		vertical_move_cursor_offset = count_visual_cols_to_position(buf, position);
	}
	num_cols := vertical_move_cursor_offset;
	if !jump_next_line(editor, buf) { return false; }

	if settings.vertical_move_tries_follow_indentation {
		// Moves the cursor to the indentation in case we end up in whitespace.
		indent_cols :: get_row_visual_indentation_cols(editor, buf);
		num_cols = math.max(num_cols, indent_cols);
	}
	move_by_visual_cols(editor, buf, num_cols);
	return true;
}

move_up :: fn (editor: *Editor, buf: *Buffer) bool {
	using Command;
	if !is_repeating_command(MOVE_DOWN, MOVE_UP) {
		position :: get_cursor_position(buf, editor.cursor_index);
		vertical_move_cursor_offset = count_visual_cols_to_position(buf, position);
	}
	num_cols := vertical_move_cursor_offset;
	if !jump_prev_line(editor, buf) { return false; }
	if settings.vertical_move_tries_follow_indentation {
		// Moves the cursor to the indentation in case we end up in whitespace.
		indent_cols :: get_row_visual_indentation_cols(editor, buf);
		num_cols = math.max(num_cols, indent_cols);
	}
	move_by_visual_cols(editor, buf, num_cols);
	return true;
}

jump_page_down :: fn (editor: *Editor, buf: *Buffer) bool {
	jump_lines :: editor.visible_lines - 4;
	assert(jump_lines > 0);
	loop i := 0; i < jump_lines; i += 1 {
		if !move_down(editor, buf) { break; }
	}
	return true;
}

jump_page_up :: fn (editor: *Editor, buf: *Buffer) bool {
	jump_lines :: editor.visible_lines - 4;
	assert(jump_lines > 0);
	loop i := 0; i < jump_lines; i += 1 {
		if !move_up(editor, buf) { break; }
	}
	return true;
}

append_indentation :: fn (str: *string, n := 1) s64 {
	orig_len :: str.len;
	if settings.insert_spaces_instead_tabs {
		loop i := 0; i < settings.tab_size * n; i += 1 {
			str_append(str, " ");
		}
	} else {
		loop i := 0; i < n; i += 1 {
			str_append(str, "\t");
		}
	}
	return str.len - orig_len;
}

insert_tab :: fn (editor: *Editor, buf: *Buffer) {
	if maybe_report_readonly(buf) { return; }

	if has_indentation_info(buf) && settings.indent_on_tab {
		indent(editor, buf);
		return;
	}

	tmp :: str_new(64, application_context.temporary_allocator);
	append_indentation(&tmp);

	position :: get_cursor_position(buf, editor.cursor_index);
	insert_string(buf, position, tmp);
}

delete_line :: fn (editor: *Editor, buf: *Buffer) bool {
	if maybe_report_readonly(buf) then return false;
	jump_line_begin(editor, buf);
	start_selection(buf, editor.cursor_index);
	jump_next_line(editor, buf);
	cut_selection(editor, buf);
	return true;
}

duplicate_line :: fn (editor: *Editor, buf: *Buffer) bool {
	if maybe_report_readonly(buf) { return false; }

	commit_undo(buf);
	defer commit_undo(buf);

	jump_line_begin(editor, buf);
	start_selection(buf, editor.cursor_index);
	jump_line_end(editor, buf);
	do_paste :: copy_selection(editor, buf);

	position := get_cursor_position(buf, editor.cursor_index);
	insert_string(buf, position, get_line_ending(buf.line_ending));
	if do_paste { paste(editor, buf, false); }
	jump_indent_begin(editor, buf);

	return true;
}

delete_word_left :: fn (editor: *Editor, buf: *Buffer) bool {
	if maybe_report_readonly(buf) { return false; }
	start_selection(buf, editor.cursor_index);
	jump_prev_word(editor, buf);
	cut_selection(editor, buf, false);
	return true;
}

smart_selection :: fn (editor: *Editor, buf: *Buffer) {
	using SmartSelectionLevel;

	if prev_executed_command != Command.SMART_SELECTION {
		start_selection(buf, editor.cursor_index);
		smart_selection_level = WORD;
		return;
	}

	switch smart_selection_level {
		WORD {
			select_word(editor, buf);
			smart_selection_level = LINE;
		}
		LINE {
			select_line(editor, buf);

			start :: get_selection_range(buf, editor.cursor_index);
			cols :: count_cols_to_position(buf, start);
			if cols > 0 {
				smart_selection_level = WHOLE_LINE;
			} else {
				smart_selection_level = PARAGRAPH;
			}
		}
		WHOLE_LINE {
			select_whole_line(editor, buf);
			smart_selection_level = PARAGRAPH;
		}
		PARAGRAPH {
			start, end :: get_selection_range(buf, editor.cursor_index);
			if start == end {
				select_paragraph(editor, buf);
				return;
			}
			set_cursor_position(buf, editor.cursor_index, start);
			jump_prev_paragraph(editor, buf);
			start_selection(buf, editor.cursor_index);
			set_cursor_position(buf, editor.cursor_index, end);
			jump_next_paragraph(editor, buf);
		}
	}
}

jump_next_line :: fn (editor: *Editor, buf: *Buffer) bool {
	cursor :: get_cursor(buf, editor.cursor_index);
	row, start_position := peek_row(buf, cursor.row);
	if row.len == 0 { return false; }
	set_cursor_position(buf, editor.cursor_index, start_position + row.len);
	return true;
}


jump_prev_line :: fn (editor: *Editor, buf: *Buffer) bool {
	cursor :: get_cursor(buf, editor.cursor_index);
	if cursor.row == 0 { return false; }
	_, start_position := peek_row(buf, cursor.row-1);
	set_cursor_position(buf, editor.cursor_index, start_position);
	return true;
}

jump_begin :: fn (editor: *Editor, buf: *Buffer) bool {
	position :: get_cursor_position(buf, editor.cursor_index);
	if position == 0 {
		return false;
	}

	set_cursor_position(buf, editor.cursor_index, 0);
	return true;
}

jump_end :: fn (editor: *Editor, buf: *Buffer) bool {
	position :: get_cursor_position(buf, editor.cursor_index);
	end_position :: get_last_position_in_buffer(buf);
	if position == end_position {
		return false;
	}

	set_cursor_position(buf, editor.cursor_index, end_position);
	return true;
}

jump_indent_begin :: fn (editor: *Editor, buf: *Buffer) bool {
	if !jump_line_begin(editor, buf) { return false; }
	num_whitespace :: get_row_visual_indentation_cols(editor, buf);
	move_by_visual_cols(editor, buf, num_whitespace);
	return true;
}

jump_next_paragraph :: fn (editor: *Editor, buf: *Buffer) bool {
	cursor := get_cursor(buf, editor.cursor_index);
	orig_position :: cursor.position;

	// in case the current position is already empty line
	row, start_index, row_len :: peek_row_without_new_line(buf, cursor.row);
	position := start_index;
	if row.len == 0 {
		cursor.row += 1;
		position   += row_len;
	}

	loop row_index := cursor.row;; row_index += 1 {
		row, start_position :: peek_row_without_new_line(buf, row_index);
		if start_position < position { break; } // The end
		position = start_position;
		if row.len == 0 {
			break;
		}
	}

	if position == orig_position {
		return false;
	}

	set_cursor_position(buf, editor.cursor_index, position);
	return true;
}

jump_prev_paragraph :: fn (editor: *Editor, buf: *Buffer) bool {
	cursor := get_cursor(buf, editor.cursor_index);
	if cursor.row == 0 { return false; }
	orig_position :: cursor.position;

	// in case the current position is already empty line
	row, start_index :: peek_row_without_new_line(buf, cursor.row);
	position := start_index;
	if row.len == 0 {
		cursor.row -= 1;
	}
	loop row_index := cursor.row; row_index >= 0; row_index -= 1 {
		row, start_position :: peek_row_without_new_line(buf, row_index);
		position = start_position;
		if row.len == 0 {
			break;
		}
	}
	if position == orig_position {
		return false;
	}

	set_cursor_position(buf, editor.cursor_index, position);
	return true;
}

jump_next_word :: fn (editor: *Editor, buf: *Buffer) bool {
	position := get_cursor_position(buf, editor.cursor_index);
	defer set_cursor_position(buf, editor.cursor_index, position);
	if !is_ident(buf, peek_position(buf, position)) {
		loop {
			char :: peek_position(buf, position);
			if char.len == 0 { return true; } // End of the file...
			if !is_ident(buf, char) {
				position += char.len;
			} else {
				break;
			}
		}
		return true;
	}
	loop {
		char :: peek_position(buf, position);
		if char.len == 0 { return true; } // End of the file...
		if is_ident(buf, char) {
			position += char.len;
		} else {
			break;
		}
	}
	return true;
}

jump_prev_word :: fn (editor: *Editor, buf: *Buffer) bool {
	position := get_cursor_position(buf, editor.cursor_index);
	defer set_cursor_position(buf, editor.cursor_index, position);
	char := peek_before_position(buf, position);
	if !is_ident(buf, char) {
		loop {
			position -= char.len;
			char = peek_before_position(buf, position);
			if char.len == 0 { break; }
			if is_ident(buf, char) { break; }
		}
		return true;
	}
	loop {
		char :: peek_before_position(buf, position);
		if char.len == 0 { break; }
		if is_ident(buf, char) {
			position -= char.len;
		} else {
			break;
		}
	}
	return true;
}

increase_font_size :: fn () bool {
	settings.font_size = math.clamp(settings.font_size + FONT_RESIZE_STEP, MIN_FONT_SIZE, MAX_FONT_SIZE);
	rebuild_fonts();
	return true;
}

decrease_font_size :: fn () bool {
	settings.font_size = math.clamp(settings.font_size - FONT_RESIZE_STEP, MIN_FONT_SIZE, MAX_FONT_SIZE);
	rebuild_fonts();
	return true;
}

// Switch to other split or create one by duplicating current active editor and swith.
other_split :: fn (buf: *Buffer) bool {
	using Split;

	assert(left != -1);
	if right == -1 {
		// no right editor, create one!
		find_or_create_editor_in_split(RIGHT, buf.index);
		return true;
	}

	active_split :: get_active_split();
	switch active_split {
		LEFT    { active_editor = right; }
		RIGHT   { active_editor = left;  }
		default { panic();               }
	}
	assert(active_editor != -1);
	assert(active_editor != command_editor);
	return true;
}

// Close all editors in the current split and focus to the other split. Note this is not
// intended for closing buffers (files). All opened buffers stays open, also we must have
// a split active.
close_split :: fn () bool {
	if left != -1 && right != -1 {
		close_all_in_split(get_active_split());
		return true;
	}
	print_warn("No split active.");
	return false;
}

close_other_split :: fn () bool {
	using Split;
	if left != -1 && right != -1 {
		active_split :: get_active_split();
		close_split := RIGHT;
		if active_split == RIGHT { close_split = LEFT; }
		close_all_in_split(close_split);
		return true;
	}
	print_warn("No split active.");
	return true;
}

close_buffer_command :: fn (buf: *Buffer) bool {
	buffer_name :: tprint("%", buf.name); // make copy because we'll delete it later
	if buf.saved_top != buf.undo_top {
		print_warn("Buffer contains unsaved changes. Use [%] command to ignore it.", COMMAND_NAMES[auto Command.FORCE_CLOSE_BUFFER]);
		return false;
	}
	close_buffer(buf.index);

	print_info("Buffer '%' closed.", buffer_name);
	return true;
}

force_close_buffer :: fn (buf: *Buffer) bool {
	buffer_name :: tprint("%", buf.name);
	close_buffer(buf.index);

	print_info("Buffer '%' closed.", buffer_name);
	return true;
}

create_new_buffer :: fn () {
	set_default_mode();
	find_or_create_editor_in_split(get_active_split(), add_buffer("New File"));
}

google_selection :: fn (editor: *Editor, buf: *Buffer) {
	selection := peek_selection(buf, editor.cursor_index);
	if selection.len == 0 {
		print_warn("Nothing selected in the buffer.");
		return;
	}
	if selection.len > 1024 {
		print_warn("Selection too long!");
		selection.len = 1024;
	}
	url :: tprint("\"https://www.google.com/search?q=%\"", string_to_url(selection));
	open_path(url);
}

open_current_buffer_in_visual_studio :: fn (buf: *Buffer) {
	err :: execute_system_command(tprint("devenv /EDIT \"%\"", buf.filepath));
	if err {
		print_err(err);
	}
}

open_current_buffer_in_remedybg :: fn (editor: *Editor, buf: *Buffer) {
	cursor :: get_cursor(buf, editor.cursor_index);

	err :: execute_system_command(tprint("remedybg open-file \"%\" %", buf.filepath, cursor.row + 1));
	if err {
		print_err(err);
	} else {
		print_info("Current file openned in RemedyBG.");
	}
}

set_current_buffer_breakpoint_in_remedybg :: fn (editor: *Editor, buf: *Buffer) {
	cursor :: get_cursor(buf, editor.cursor_index);

	err :: execute_system_command(tprint("remedybg add-breakpoint-at-file \"%\" %", buf.filepath, cursor.row + 1));
	if err {
		print_err(err);
	} else {
		print_info("Breakpoint set in RemedyBG.");
	}
}

debug_in_remedybg :: fn () {
	err := execute_system_command("remedybg.exe stop-debugging");
	if err { print_err(err); return; }
	err = execute_system_command("remedybg.exe start-debugging");
	if err { print_err(err); return; }
	print_info("Debugging started in RemedyBG.");
}

open_current_buffer_in_raddbg :: fn (editor: *Editor, buf: *Buffer) {
	cursor :: get_cursor(buf, editor.cursor_index);
	err := OK;
	err = execute_system_command(tprint("raddbg --ipc find_code_location %:%", buf.filepath, cursor.row + 1));
	if err { print_err(err); return; }
	print_info("Current file openned in RAD Debugger.");
}

set_current_buffer_breakpoint_in_raddbg :: fn (editor: *Editor, buf: *Buffer) {
	cursor :: get_cursor(buf, editor.cursor_index);
	err := OK;
	err = execute_system_command(tprint("raddbg --ipc find_code_location %:%", buf.filepath, cursor.row + 1));
	if err { print_err(err); return; }
	err = execute_system_command(tprint("raddbg --ipc add_breakpoint %:%", buf.filepath, cursor.row + 1));
	if err { print_err(err); return; }
	print_info("Breakpoint set in RAD Debugger.");
}

debug_in_raddbg :: fn () {
	err := execute_system_command("raddbg --ipc kill_all");
	if err { print_err(err); return; }
	err = execute_system_command("raddbg --ipc launch_and_run");
	if err { print_err(err); return; }
	print_info("Debugging started in RAD Debugger.");
}

open_project_config :: fn () {
	if project.filepath.len == 0 || project.is_default {
		print_warn("No project is open. Use 'open-project' command first to open one.");
		return;
	}
	err :: open(project.filepath);
	if err {
		print_err("Cannot open project file with error: %", err);
	}
}

open_default_config :: fn () {
	err :: open(tprint("%/%", data_dir, DEFAULT_CONFIG_FILE));
	if err {
		print_err("Cannot open default config file with error: %", err);
	}
}

open_messages :: fn () {
	active_editor = find_or_create_editor_in_split(get_active_split(), messages_buffer_index);
}

ToUpperOrLower :: enum {
	UPPER;
	LOWER;
}

selection_to_upper_or_lower :: fn (editor: *Editor, buf: *Buffer, op: ToUpperOrLower) {
	using ToUpperOrLower;

	if maybe_report_readonly(buf) { return; }

	selection :: peek_selection(buf, editor.cursor_index);
	if selection.len == 0 {
		print_warn("Nothing selected in the buffer.");
		return;
	}

	temp :: application_context.temporary_allocator;
	// duplicate the selection first
	dup :: str_new(selection, temp);
	switch op {
		UPPER {
			if str_upper(&dup) == 0 { return; }
		}
		LOWER {
			if str_lower(&dup) == 0 { return; }
		}
	}

	commit_undo(buf);
	cut_selection(editor, buf, false);

	position :: get_cursor_position(buf, editor.cursor_index);
	insert_string(buf, position, dup);

	commit_undo(buf);
}

clang_format :: fn (buf: *Buffer) {
	err :: request_format(buf);
	if err { print_err(err); }
}

start_build :: fn () {
	if settings.save_all_before_build {
		save_all();
	}

	build_command :: if settings.build_command.len == 0 then BUILD_COMMAND else settings.build_command;

	err :: request_build(build_command);
	if err then print_err(err);
}

alpha_sort_lines :: fn (editor: *Editor, buf: *Buffer) {
	if maybe_report_readonly(buf) { return; }
	if !has_selection(buf, editor.cursor_index) { return; }

	s, e :: get_selection_range(buf, editor.cursor_index);
	clear_selection(buf, editor.cursor_index);
	start, end :: expand_range_to_whole_rows(buf, s, e);

	str      :: peek_range(buf, start, end);
	new_line :: get_line_ending(buf.line_ending);

	// we assume new line everytime ending with '\n'.
	assert(new_line[new_line.len-1] == '\n');
	lines :: str_split_by(str, '\n', application_context.temporary_allocator);

	if lines.len < 2 { return; }

	sort(lines, &fn (a: *string_view, b: *string_view) bool {
		return str_compare(@a, @b) < 0;
	});

	set_cursor_position(buf, editor.cursor_index, start);

	commit_undo(buf);

	sorted := str_new();
	defer str_delete(&sorted);

	loop i := 0; i < lines.len; i += 1 {
		line :: trim_right(lines[i], "\r\n");
		if line.len == 0 { continue; }
		str_append(&sorted, line);
		if i+1 < lines.len {
			str_append(&sorted, new_line);
		}
	}

	batch_begin(buf);
	delete_range(buf, start, start + str.len);
	insert_string(buf, start, sorted);
	batch_end(buf);

	commit_undo(buf);
}

get_number_under_cursor :: fn (editor: *Editor, buf: *Buffer) (start_index: s64, end_index: s64, base: FmtIntBase, is_negative: bool, uppercase: bool) {
	position := get_cursor_position(buf, editor.cursor_index);

	using FmtIntBase;
	base := FmtIntBase.DEC;

	curr_char, prev_char := " ";

	end_position := position;
	loop {
		curr_char = peek_position(buf, position);
		if curr_char.len != 1 then break;
		if is_line_end(buf, curr_char) > 0 then break;
		if !is_digit(curr_char[0], FmtIntBase.HEX) && !is_one_of(curr_char[0], "xXbB") then break;
		end_position = position;
		position    += curr_char.len;
	}

	// Try to find the prefix 0x/0b.
	position = end_position;
	start_position := position;
	loop {
		prev_char = curr_char;
		curr_char = peek_position(buf, position);
		if curr_char.len != 1 then break;
		if is_line_end(buf, curr_char) > 0 then break;
		if curr_char[0] == '0' && (prev_char[0] == 'x' || prev_char[0] == 'X') {
			base = HEX; // 0x
			// start_position = position;
		}
		if curr_char[0] == '0' && (prev_char[0] == 'b' || prev_char[0] == 'B') {
			base = BIN; // 0b
			// start_position = position;
		}
		if curr_char[0] == '0' && is_digit(prev_char[0], FmtIntBase.OCT) {
			base = OCT; // 0
			// start_position = position;
		}
		if !is_digit(curr_char[0], FmtIntBase.HEX) && !is_one_of(curr_char[0], "xXbB") then break;
		start_position = position;
		position      -= curr_char.len;
	}

	is_hex_uppercase := false;
	end_position = start_position;
	switch base {
		HEX, BIN { end_position += 2; }
		OCT      { end_position += 1; }
		default;
	}
	loop {
		curr_char = peek_position(buf, end_position);
		if curr_char.len != 1 then break;
		if is_line_end(buf, curr_char) > 0 then break;
		if !is_digit(curr_char[0], base) then break;
		if base == HEX && !is_hex_uppercase && is_one_of(curr_char[0], "ABCDEF") then is_hex_uppercase = true;
		end_position += curr_char.len;
	}

	is_negative := false;
	negative_char :: peek_before_position(buf, start_position);
	if negative_char.len == 1 && negative_char[0] == '-' then is_negative = true;

	return start_position, end_position, base, is_negative, is_hex_uppercase;
}

add_number_under_cursor :: fn (editor: *Editor, buf: *Buffer, v : s64) {
	start_index, end_index, base, is_negative, uppercase := get_number_under_cursor(editor, buf);

	number_text: string_view;

	using FmtIntBase;
	switch base {
		HEX, BIN { number_text = peek_range(buf, start_index+2, end_index); }
		OCT      { number_text = peek_range(buf, start_index+1, end_index); }
		DEC      { number_text = peek_range(buf, start_index, end_index);   }
	}

	if number_text.len == 0 {
		print_err("No number under current cursor.");
		return;
	}

	n, err := strtos64(number_text, base);
	if err {
		print_err("Cannot convert to number.");
		return;
	}
	if is_negative then n *= -1;
	n += v;

	set_cursor_position(buf, editor.cursor_index, if is_negative then start_index - 1 else start_index);
	start_selection(buf, editor.cursor_index);
	set_cursor_position(buf, editor.cursor_index, end_index);
	cut_selection(editor, buf, false);

	start :: get_cursor_position(buf, editor.cursor_index);
	insert_string(buf, start, tprint("%", fmt_int(n, base, true, -1, uppercase)));

	set_cursor_position(buf, editor.cursor_index, get_cursor_position(buf, editor.cursor_index)-1);

	commit_undo(buf);
}

toggle_comment :: fn (editor: *Editor, buf: *Buffer) {
	if maybe_report_readonly(buf) { return; }

	comment_with :: FILE_TYPE_COMMENT_WITH[auto buf.file_type];
	if comment_with.len == 0 { return; }

	start, end: s64;
	if has_selection(buf, editor.cursor_index) {
		s, e :: get_selection_range(buf, editor.cursor_index);
		clear_selection(buf, editor.cursor_index);
		sx, ex :: expand_range_to_whole_rows(buf, s, e);
		start = sx;
		end   = ex;
	} else {
		cursor :: get_cursor(buf, editor.cursor_index);
		line, s :: peek_row_without_new_line(buf, cursor.row);
		start = s;
		end   = s + cast(s32)line.len;
	}

	str      :: peek_range(buf, start, end);
	new_line :: get_line_ending(buf.line_ending);

	// we assume new line everytime ending with '\n'.
	assert(new_line[new_line.len-1] == '\n');
	lines :: str_split_by(str, '\n', application_context.temporary_allocator);

	if lines.len == 0 { return; }

	commented := str_new(math.max(str.len, 32));
	defer str_delete(&commented);

	nesting := 1000;
	position := start;
	loop i := 0; i < lines.len; i += 1 {
		line :: lines[i];
		if line.len > 0 {
			nesting = math.min(nesting, find_indentation_for_range(buf, position, position + line.len));
		}
		position += line.len + 1;
	}

	indenting_char_num := nesting;
	if settings.insert_spaces_instead_tabs {
		indenting_char_num *= settings.tab_size;
	}
	loop i := 0; i < lines.len; i += 1 {
		line := trim_right(lines[i], " \t\r");
		line  = trim_left(line, " \t", indenting_char_num);

		if line.len > 0 {
			trimmed_line :: trim_left(line, " \t"); // remove all leading whitespace
			if str_match(string_view.{ comment_with.len, trimmed_line.ptr }, comment_with) {
				line = trimmed_line;
				line.len -= comment_with.len;
				line.ptr  = &line[comment_with.len];
				line = trim_left(line, " ", 1);
				append_indentation(&commented, nesting);
				str_append(&commented, line);
			} else {
				append_indentation(&commented, nesting);
				str_append(&commented, comment_with);
				str_append(&commented, " ");
				str_append(&commented, line);
			}
		}
		if i + 1 < lines.len {
			str_append(&commented, new_line);
		}
	}

	if str.len < 1 { return; }

	set_cursor_position(buf, editor.cursor_index, start);

	commit_undo(buf);

	batch_begin(buf);
	delete_range(buf, start, start + str.len);
	insert_string(buf, start, commented);
	batch_end(buf);

	commit_undo(buf);
}

open_error_location :: fn (loc: *ErrorLocation) {
	filepath :: str_new(loc.file);
	defer str_delete(&filepath);
	str_replace_all(&filepath, '\\', '/'); // we love windows

	err :: open_location(filepath, loc.line-1, loc.col-1);
	if err {
		print_err(err);
		return;
	}

	error_marker_visible = true;
}

next_error :: fn () {
	if error_list.len == 0 { print_warn("No errors in current error list."); return; }
	error_list_index += 1;
	if error_list_index >= error_list.len { error_list_index = 0; }
	open_error_location(&error_list[error_list_index]);
}

prev_error :: fn () {
	if error_list.len == 0 { print_warn("No errors in current error list."); return; }
	error_list_index -= 1;
	if error_list_index < 0 { error_list_index = error_list.len - 1; }
	open_error_location(&error_list[error_list_index]);
}

clear_messages :: fn () {
	index :: messages_buffer_index;
	if index == -1 { return; }
	assert(index >= 0 && index < buffers.len);
	buf :: &buffers[index];
	assert(!buf.is_removed);

	clear_buffer(buf);
}

support_me :: fn () {
	open_path("https://www.paypal.com/donate/?hosted_button_id=WKSP23ADBFDP6");
}

open_file_location :: fn (buf: *Buffer) {
	dir :: path_split(buf.filepath);
	if dir.len == 0 {
		print_err("Cannot open file location.");
		return;
	}
	open_path(dir);
}

insert_current_date :: fn (editor: *Editor, buf: *Buffer) {
	if maybe_report_readonly(buf) { return; }

	date :: get_current_date_as_YYYY_MM_DD();

	position :: get_cursor_position(buf, editor.cursor_index);
	insert_string(buf, position, date);
}
shell: struct {
	job_index:       s32;
	buffer_index:    s32;
	last_ansi_color: u8;

	tmp: string;
};

shell_init :: fn () {
	shell.job_index    = -1;
	shell.buffer_index = -1;
}

shell_terminate :: fn () {
	str_delete(&shell.tmp);
}

request_shell_execute :: fn (cmd: string_view) Error {
	clear_error_list();

	if shell.job_index != -1 {
		return error("Shell execution is already in progress, use 'shell-kill' for interruption and try again.");
	}

	_, prev_editor :: get_active_buffer_and_editor();

	find_or_create_editor_with_buffer_in_other_split(&shell.buffer_index, "shell");
	buf :: &buffers[shell.buffer_index];

	active_editor = prev_editor.index;

	clear_buffer(buf);
	shell.last_ansi_color = 0;

	job_index :: start_async_job(JobKind.SHELL, "shell", &worker);

	request := Request.{ job_kind = JobKind.SHELL };
	request_data :: &request.data.build;
	request_data.args = str_new(cmd);

	push_request(get_job_context(job_index), &request);

	shell.job_index = job_index;
	return OK;
}

apply_shell :: fn (_: JobContext.state, request: *Request) {
	if shell.buffer_index == -1 then return;
	assert(shell.buffer_index >= 0 && shell.buffer_index < buffers.len);
	buf :: &buffers[shell.buffer_index];
	if buf.is_removed {
		kill_shell();
	} else {
		request_data :: &request.data.build;
		text: string_view;
		if shell.tmp.len > 0 {
			str_append(&shell.tmp, request_data.text);
			text = shell.tmp;
			shell.tmp.len = 0;
		} else {
			text = request_data.text;
		}

		append :: fn (buf: *Buffer, text: string_view, color: u8) {
			array_resize(&buf.colors, buf.colors.len + text.len);
			memset(&buf.colors[buf.bytes.len], color, auto text.len);
			append_readonly_buffer(buf, text);
		};

		allocator :: application_context.temporary_allocator;
		append_start_index, append_len := 0;

		// ANSI color codes...
		loop i := 0; i < text.len; {
			if text[i] == 27 { // Escape character
				esc_seq_start_index :: i;
				i += 1;

				MAX_ESCAPE_SEQ_LEN :: 8;
				is_complete := false;

				if append_len > 0 {
					append(buf, .{ append_len, &text[append_start_index] }, shell.last_ansi_color);
					append_len = 0;
				}

				if i < text.len && text[i] == '[' {
					i += 1;
					start_colors :: i;
					len := 0;
					loop ;i < text.len && len <= MAX_ESCAPE_SEQ_LEN; i += 1 {
						if text[i] == 'm' {
							is_complete = true;
							break;
						}
						len += 1;
					}

					if is_complete && len <= MAX_ESCAPE_SEQ_LEN {
						text_style :: str_split_by(string_view.{ len, &text[start_colors] }, ';', allocator);
						foreground_color : s32 = -1;
						loop i := 0; i < text_style.len; i += 1 {
							n, err :: strtos64(text_style[i]);
							if err then continue;
							if n >= 30 && n <= 37 then foreground_color = auto n;
						}

						if foreground_color == -1 {
							shell.last_ansi_color = 0;
						} else if settings.shell_enable_ansi_colors {
							shell.last_ansi_color = get_ansi_color_index_from_code(foreground_color);
						}
					} else {
						shell.last_ansi_color = 0;
					}
				}

				if !is_complete {
					len :: i - esc_seq_start_index;
					assert(len > 0, "We expect at least escape character here!");
					str_append(&shell.tmp, string_view.{ len, &text[esc_seq_start_index] });
					return;
				}

			} else {
				if append_len == 0 then append_start_index = i;
				append_len += 1;
			}
			i += 1;
		}

		if append_len > 0 then append(buf, .{ append_len, &text[append_start_index] }, shell.last_ansi_color);
	}
}

kill_shell :: fn () {
	if shell.job_index == -1 {
		print_warn("Build is not running.");
		return;
	}
	assert(shell.job_index >= 0 && shell.job_index < jobs.len);
	assert(!jobs[shell.job_index].worker_context.is_removed);
	assert(jobs[shell.job_index].worker_context.kind == JobKind.SHELL);
	remove_async_job(shell.job_index);
}

#scope_private

worker :: fn (ctx: *JobContext) s32 {
	using JobContext.state;

	// wait for request
	request: Request #noinit;
	loop !pop_request(ctx, &request) {
		os_sleep_ms(10);
	}
	request_data :: &request.data.build;
	defer terminate_request(&request);

	allocator :: application_context.temporary_allocator;

	shell_command :: str_new(if settings.shell.len == 0 then DEFAULT_SHELL else settings.shell, allocator);
	args_with_executable :: split_command_line_arguments(&shell_command, allocator);

	if args_with_executable.len == 0 {
		print_err("Cannot resolve shell executable name.");
		ctx.state = FAILED;
		return 0;
	}

	executable :: args_with_executable[0];
	args       :: []string_view.{ args_with_executable.len-1, &args_with_executable[1] };

	result :: Request.{ job_kind = JobKind.SHELL };
	result_data :: &result.data.build;

	result_data.text = sprint("Execute: %\n", request_data.args);
	push_result(ctx, &result);

	err :: start_process(ctx, executable, args);
	defer stop_process(ctx);

	if err {
		print_err(err);
		ctx.state = FAILED;
		return 1;
	}

	write_pipe(ctx.stdin, request_data.args);
	write_pipe(ctx.stdin, "\n");
	close_pipe(&ctx.stdin);

	loop !ctx.kill {
		state, err :: poll_process(ctx);
		if err {
			print_err(err);
            ctx.state = FAILED;
            return 1;
		}

		using PollEvent;
		if is_flag(state, READ) {
			result_data.text = str_new();
			defer push_result(ctx, &result);

			err_read :: read_pipe(ctx.stdout, &result_data.text);
			if err_read {
				print_err(err_read);
				ctx.state = FAILED;
				return 1;
			}
		}
		if is_flag(state, CLOSED) {
			ctx.state = DONE;
			break;
		}

		os_sleep_ms(10);
	}

	if ctx.state == DONE {
		result_data.text = sprint("\nProcess exited with status %.\n", ctx.exit_code);
		push_result(ctx, &result);
		return 0;
	}

	result_data.text = str_new("\nProcess killed.\n");
	push_result(ctx, &result);

	ctx.state = KILLED;
	return 0;
}

get_ansi_color_index_from_code :: fn (n: s32) u8 #inline {
	switch n {
		30 { return ANSI_COLOR_BLACK_INDEX;   }
		31 { return ANSI_COLOR_RED_INDEX;     }
		32 { return ANSI_COLOR_GREEN_INDEX;   }
		33 { return ANSI_COLOR_YELLOW_INDEX;  }
		34 { return ANSI_COLOR_BLUE_INDEX;    }
		35 { return ANSI_COLOR_MAGENTA_INDEX; }
		36 { return ANSI_COLOR_CYAN_INDEX;    }
		37 { return ANSI_COLOR_WHITE_INDEX;   }
		default;
	}
	return CODE_COLOR_DEFAULT_INDEX;
}
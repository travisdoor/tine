#import "os/windows"

BUILD_COMMAND :: "build.bat";
DEFAULT_SHELL :: "cmd.exe /c";

//
// Process
//

IoStream :: HANDLE;
Pid :: DWORD;

start_process :: fn (ctx: *?TContext, cmd: string_view, args: []string_view) Error {
	static_assert(has_member2(TContext, "pid"));
	static_assert(has_member2(TContext, "stdin"));
	static_assert(has_member2(TContext, "stdout"));

	stdin_read:   HANDLE;
	stdin_write:  HANDLE;
	stdout_read:  HANDLE;
	stdout_write: HANDLE;

	security_attributes :: SECURITY_ATTRIBUTES.{
		nLength = auto sizeof(SECURITY_ATTRIBUTES),
		bInheritHandle = TRUE,
		lpSecurityDescriptor = null
	};

	if CreatePipe(&stdout_read, &stdout_write, &security_attributes, 0) == 0 then return os_get_last_error2();
	if SetHandleInformation(stdout_read, HANDLE_FLAG_INHERIT, 0) == 0        then return os_get_last_error2();
	if CreatePipe(&stdin_read, &stdin_write, &security_attributes, 0) == 0   then return os_get_last_error2();
	if SetHandleInformation(stdin_write, HANDLE_FLAG_INHERIT, 0) == 0        then return os_get_last_error2();

	// Create process
	process_info: PROCESS_INFORMATION;

	allocator :: application_context.temporary_allocator;

	startup_info :: STARTUPINFOA.{
		cb          = auto sizeof(STARTUPINFOA),
		hStdError   = stdout_write,
		hStdOutput  = stdout_write,
		hStdInput   = stdin_read,
		dwFlags     = STARTF_USESTDHANDLES | STARTF_USESHOWWINDOW,
		wShowWindow = auto SW_HIDE,
	};

	// We must duplicate all arguments because they might not be zero terminated...
	tmp := str_new(cmd, allocator);
	loop i := 0; i < args.len; i += 1 {
		str_append(&tmp, " ");
		str_append(&tmp, str_new(args[i], allocator));
	}
	if CreateProcessA(null, strtoc(tmp), null, null, TRUE, 0, null, null, &startup_info, &process_info) == 0 then return os_get_last_error2();

	CloseHandle(process_info.hProcess);
	CloseHandle(process_info.hThread);
	CloseHandle(stdout_write);
	CloseHandle(stdin_read);

	ctx.pid    = process_info.dwProcessId;
	ctx.stdin  = stdin_write;
	ctx.stdout = stdout_read;

	return OK;
}

get_process_exit_code :: fn (pid: Pid) (exit_code: s32, err: Error) {
	handle :: OpenProcess(PROCESS_QUERY_INFORMATION | PROCESS_VM_READ, FALSE, pid);
	if !handle {
		return 0, os_get_last_error2();
	}
	defer CloseHandle(handle);

	exit_code: DWORD;
	if GetExitCodeProcess(handle, &exit_code) != 0 {
		if exit_code == STILL_ACTIVE {
			return 0, error("Process is still active.");
		}
		return auto exit_code, OK;
	}
	return 0, os_get_last_error2();
}

execute_system_command :: fn (cmd: string_view) Error {
	// Create process attributes
	startup_info: STARTUPINFOA;
	process_info: PROCESS_INFORMATION;
	startup_info.cb = auto sizeof(STARTUPINFOA);
	if CreateProcessA(null, strtoc(cmd), null, null, FALSE, 0, null, null, &startup_info, &process_info) == 0 then return os_get_last_error2();
	WaitForSingleObject(process_info.hProcess, INFINITE);
	CloseHandle(process_info.hProcess);
	CloseHandle(process_info.hThread);
	return OK;
}

kill_process :: fn (pid: Pid, exit_code: s32) Error {
	handle :: OpenProcess(PROCESS_TERMINATE, FALSE, pid);
	if !handle {
		return os_get_last_error2();
	}
	defer CloseHandle(handle);

	if TerminateProcess(handle, auto exit_code) == 0 {
		return os_get_last_error2();
	}

	return OK;
}

PollEvent :: enum #flags {
	READ;
	CLOSED;
	WAIT;
}

poll_pipe :: fn (stream: IoStream) (PollEvent, Error) {
	available_bytes: u32 #noinit;
	if PeekNamedPipe(stream, null, 0, null, &available_bytes, null) == 0 {
		err :: os_get_last_error2();
		if err.code == ERROR_BROKEN_PIPE then return PollEvent.CLOSED, OK;
		return PollEvent.CLOSED, err;
	}

	if available_bytes > 0 then return PollEvent.READ, OK;
	return PollEvent.WAIT, OK;
}

read_pipe :: fn (stream: IoStream, dest: *string) Error {
	// @Incomplete 2025-01-11: This is a bit weird solution, but ReadFile would block in case
	// there are no data to read. This does not map well with POSIX version with non-blocking
	// pipes; we might come up with some better handling of this on windows.
	//
	// In general we use peek pipe to get available bytes for read and read just that data.
	available_bytes: u32 #noinit;
	if PeekNamedPipe(stream, null, 0, null, &available_bytes, null) == 0 then return os_get_last_error2();
	assert(available_bytes > 0, "Read should be called only in case there is data available in the pipe!");

	total_read : u32 = 0;
	loop total_read < available_bytes {
		buf:  [2048]u8 #noinit;

		n: DWORD;
		if ReadFile(stream, buf.ptr, auto buf.len, &n, null) == 0 then return os_get_last_error2();
		str_append(dest, string_view.{ auto n, buf.ptr });
		total_read += n;
	}

	assert(total_read == available_bytes, "Not all data read from the pipe!");
	// print_log("Read: %", @dest);
	return OK;
}

write_pipe :: fn (stream: IoStream, msg: string_view) Error {
	total_written : u32 = 0;
	msg_len :: cast(u32) msg.len;
	loop total_written < msg_len {
		write_size :: math.min(msg_len - total_written, 4096);

		n: DWORD;
		if WriteFile(stream, auto &msg[auto total_written], write_size, &n, null) == 0 then return os_get_last_error2();
		total_written += n;
	}
	assert(msg_len == total_written);
	// print_log("Write: %", msg);
	return OK;
}

close_stream :: fn (handle: IoStream) {
	CloseHandle(handle);
}

//
// MISC
//

get_current_date_as_YYYY_MM_DD :: fn () string_view {
	time: SYSTEMTIME #noinit;
	GetLocalTime(&time);

	return tprint("%-%-%",
		time.wYear,
		fmt_int(time.wMonth, FmtIntBase.DEC, false, 2),
		fmt_int(time.wDay, FmtIntBase.DEC, false, 2),
	);
}

get_fonts_directory :: fn () string {
	path :: get_home();
	str_append(&path, "/AppData/Local/Microsoft/Windows/Fonts");
	return path;
}

new_filepath_from_url :: fn (url: string_view) (err: Error, filepath: string) {
	url_dup :: tprint("%", url); // Might not be zero-terminated...
	buf: [MAX_PATH]u8 #noinit;
	len: DWORD = auto buf.len;
	status :: PathCreateFromUrlA(strtoc(url_dup), auto buf.ptr, &len, 0);
	if status != S_OK {
		return error("Url '%' cannot be converted to file path.", url), string.{};
	}
	result :: str_new(string_view.{ auto len, buf.ptr });
	str_replace_all(&result, '\\', '/');
	return OK, result;
}

new_url_from_filepath :: fn (filepath: string_view) (err: Error, url: string) {
	filepath_dup :: tprint("%", filepath); // Might not be zero-terminated...
	buf: [2084]u8 #noinit; // INTERNET_MAX_URL_LENGTH
	len: DWORD = auto buf.len;
	status :: UrlCreateFromPathA(strtoc(filepath_dup), auto buf.ptr, &len, 0);
	if status != S_OK {
		return error("Filepath '%' cannot be converted to URL.", filepath), string.{};
	}
	result :: str_new(string_view.{ auto len, buf.ptr });
	return OK, result;
}

// @Note 2025-01-11: We use native windows implementation which does not require any
// initialization now.
init_clipboard :: fn () {}
terminate_clipboard :: fn () {}

read_clipboard :: fn () string_view {
	if OpenClipboard(null) == 0 { return ""; }
	defer CloseClipboard();
	if IsClipboardFormatAvailable(CF_UNICODETEXT) == 0 { return ""; }
	data :: GetClipboardData(CF_UNICODETEXT);
	if !data { return ""; }
	unicode_ptr :: cast(*u16) GlobalLock(data);
	defer GlobalUnlock(data);
	if !unicode_ptr { return ""; }
	utf16len :: C.wcslen(unicode_ptr);
	utf8len :: WideCharToMultiByte(CP_UTF8, null, unicode_ptr, auto utf16len, null, 0, null, null);
	if utf8len == 0 { return ""; }
	result := str_new(utf8len, application_context.temporary_allocator);
	result.len = utf8len;
	if WideCharToMultiByte(CP_UTF8, null, unicode_ptr, auto utf16len, auto result.ptr, auto utf8len, null, null) == 0 { return ""; }
	return result;
}

write_clipboard :: fn (text: string_view) {
	if text.len == 0 { return; }
	utf16len := cast(usize) MultiByteToWideChar(CP_UTF8, 0, auto text.ptr, auto text.len, null, 0);
	if utf16len == 0 {
		assert(false);
		return;
	}
	dest_mem :: GlobalAlloc(GMEM_MOVEABLE, auto (utf16len + 1) * sizeof(u16));
	if !dest_mem {
		assert(false);
		return;
	}
	dest_text :: cast(*u16)GlobalLock(dest_mem);
	if !dest_text {
		assert(false);
		return;
	}
	defer GlobalUnlock(dest_mem);

if MultiByteToWideChar(CP_UTF8, 0, auto text.ptr, auto text.len, dest_text, auto utf16len) == 0 {
		assert(false);
		return;
	}
	last_char :: cast(*u16)ptr_shift_bytes(auto dest_text, auto utf16len * sizeof(u16));
	@last_char = 0;


if OpenClipboard(null) == 0 {
		assert(false);
		return;
	}
	defer CloseClipboard();
	EmptyClipboard();

	// Transferes the allocated ownership to the system, so no free here!!!
	if SetClipboardData(CF_UNICODETEXT, dest_mem) == null {
		GlobalFree(dest_mem); // Free here since it's fucked.
		assert(false);
		return;
	}
}

//
// File change notifications
//

Watcher :: struct {
	handle: HANDLE;
	path:   string;
	flags:  WatchFor;
	remove: bool;
}

watch_init :: fn () {
	mutex_init(&worker_context.mutex);
	async(&job, &worker_context, &worker);
}

watch_terminate :: fn () {
	worker_context.cancel = true;
	async_wait(&job);
	mutex_terminate(&worker_context.mutex);
}

WatchFor :: enum u32 #flags {
	FILE_CHANGES      = FILE_NOTIFY_CHANGE_FILE_NAME;
	DIRECTORY_CHANGES = FILE_NOTIFY_CHANGE_DIR_NAME;
	MODIFICATIONS     = FILE_NOTIFY_CHANGE_LAST_WRITE;
}

watch_changes :: fn (directory: string_view, flags: WatchFor) Error {
	assert(directory.len > 0);

	hash :: hash_combine(str_hash(directory), cast(u32) flags);
	print_log("Watch changes in '%' for %.", directory, flags);

	mutex_lock(&worker_context.mutex);
	defer mutex_unlock(&worker_context.mutex);

	tbl :: &worker_context.watched;
	w := tbl_lookup_ptr(tbl, hash);
	if w {
		w.remove = false;
		return OK;
	}

	handle :: FindFirstChangeNotificationA(strtoc(directory), TRUE, auto flags);
	if handle == INVALID_HANDLE || handle == null {
		return os_get_last_error2();
	}

	w = tbl_insert(tbl, hash);
	w.path   = str_new(directory);
	w.handle = handle;
	w.remove = false;
	w.flags  = flags;

	return OK;
}

unwatch_changes :: fn (directory: string_view, flags: WatchFor) {
	hash :: hash_combine(str_hash(directory), cast(u32) flags);
	print_log("Unwatch changes in '%' for %.", directory, flags);

	mutex_lock(&worker_context.mutex);
	defer mutex_unlock(&worker_context.mutex);

	tbl :: &worker_context.watched;
	w :: tbl_lookup_ptr(tbl, hash);
	if !w { return; } // Maybe report this?
	str_delete(&w.path);
	w.remove= true;
}

next_watcher_event :: fn (changed_directory: *string_view, change_kind: *WatchFor) bool {
	mutex_lock(&worker_context.mutex);
	defer mutex_unlock(&worker_context.mutex);

	changed :: &worker_context.changed;

	dt :: frame_delta_time;
	loop i := 0; i < changed.len; i += 1 {
		c :: &changed.values[i];
		c.timeout_ms -= dt;
		if c.timeout_ms < 0.f {
			@changed_directory = tprint("%", c.path);
			@change_kind       = c.flags;
			tbl_erase(changed, changed.keys[i]);
			return true;
		}
	}

	return false;
}

get_file_last_write_time :: fn (filepath: string_view) (t: u64, err: Error) {
	attributes: WIN32_FILE_ATTRIBUTE_DATA;
	if GetFileAttributesExA(strtoc(filepath), GET_FILEEX_INFO_LEVELS.GetFileExInfoStandard, auto &attributes) == TRUE {
		tmp: union {
			wt: FILETIME;
			t: u64;
		};
		tmp.wt = attributes.ftLastWriteTime;
		return tmp.t, OK;
	}

	return 0, os_get_last_error2();
}

#scope_private

// Note that the file-watch system on Windows is SUPER SHITTY, there is no suitable way to watch changes to
// individual files, and notification system for directories might generate multiple events for a "single" user
// action e.g. save. Also even we have the save notification, the file still might be blocked by writing process,
// so we have timeout to give Windows some spare time to do its shit.

Change :: struct {
	path:       string;
	flags:      WatchFor;
	timeout_ms: f32;
}

job: Async(*typeof(worker_context), s32);

worker_context: struct {
	watched: Table(u32, Watcher);
	changed: Table(string_view, Change);
	mutex: Mutex;

	cancel: bool;
}

worker :: fn (ctx: *typeof(worker_context)) s32 {
	print_log("File watch started.");

	handles:   [..]HANDLE;
	hashes:    [..]u32;
	to_remove: [..]u32;
	defer array_terminate(&handles);
	defer array_terminate(&hashes);
	defer array_terminate(&to_remove);
	defer tbl_terminate(&ctx.watched);
	defer tbl_terminate(&ctx.changed);
	tbl :: &ctx.watched;

	loop !ctx.cancel {
		{
			mutex_lock(&worker_context.mutex);
			defer mutex_unlock(&worker_context.mutex);

			handles.len   = 0;
			hashes.len    = 0;
			to_remove.len = 0;
			loop i := 0; i < tbl.len; i += 1 {
				w :: &tbl.values[i];
				if w.remove {
					FindCloseChangeNotification(w.handle);
					str_delete(&w.path);
					array_push(&to_remove, tbl.keys[i]);
					continue;
				}

				array_push(&handles, w.handle);
				array_push(&hashes,  tbl.keys[i]);
			}
			loop i := 0; i < to_remove.len; i += 1 {
				tbl_erase(tbl, to_remove[i]);
			}
			assert(handles.len == hashes.len);
		}

		if handles.len == 0 {
			if !ctx.cancel { os_sleep_ms(100); }
			continue;
		}
		status :: WaitForMultipleObjects(auto handles.len, handles.ptr, FALSE, 100);
		if status == WAIT_TIMEOUT { continue; }

		{
			mutex_lock(&worker_context.mutex);
			defer mutex_unlock(&worker_context.mutex);

			if status >= 0 && status < auto hashes.len {
				index :: cast(s64) status;
				hash  :: hashes[index];
				w :: tbl_lookup_ptr(tbl, hash);
				assert(w);
				assert(w.handle == handles[index]);

				c := tbl_lookup_ptr(&ctx.changed, w.path);
				if !c {
					c = tbl_insert(&ctx.changed, w.path);
					c.path  = w.path;
					c.flags = auto 0;
				}
				c.flags |= w.flags;
				c.timeout_ms = 200.f;

				if FindNextChangeNotification(w.handle) == FALSE {
					print_err(os_get_last_error2());
					w.remove = true;
				}
			}
		}
		temporary_reset(); // just in case...
	}

	return 0;
}

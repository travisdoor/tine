#import "os/windows"

BUILD_COMMAND :: "build.bat";
DEFAULT_SHELL :: "CMD.exe /Q /K prompt $";

//
// Process
//

IoStream :: HANDLE;
Pid      :: DWORD;

start_process :: fn (ctx: *?TContext, executable: string_view, args: []string_view) Error {
	static_assert(type_utils.has_member#(TContext, "pid"));
	static_assert(type_utils.has_member#(TContext, "stdin"));
	static_assert(type_utils.has_member#(TContext, "stdout"));
	static_assert(type_utils.has_member#(TContext, "win_job_handle"));

	job_handle :: CreateJobObjectA(null, null);
	if job_handle == INVALID_HANDLE_VALUE {
		return os_get_last_error2();
	}

	job_info: JOBOBJECT_EXTENDED_LIMIT_INFORMATION;
	job_info.BasicLimitInformation.LimitFlags = JOB_OBJECT_LIMIT_KILL_ON_JOB_CLOSE;

	if SetInformationJobObject(job_handle, JOBOBJECTINFOCLASS.JobObjectExtendedLimitInformation, auto &job_info, auto sizeof(job_info)) == 0 {
		CloseHandle(job_handle);
		return os_get_last_error2();
	}

	stdin_read:   HANDLE;
	stdin_write:  HANDLE;
	stdout_read:  HANDLE;
	stdout_write: HANDLE;

	security_attributes :: SECURITY_ATTRIBUTES.{
		nLength = auto sizeof(SECURITY_ATTRIBUTES),
		bInheritHandle = TRUE,
		lpSecurityDescriptor = null
	};

	if CreatePipe(&stdout_read, &stdout_write, &security_attributes, 0) == 0 then return os_get_last_error2();
	if SetHandleInformation(stdout_read, HANDLE_FLAG_INHERIT, 0)        == 0 then return os_get_last_error2();
	if CreatePipe(&stdin_read, &stdin_write, &security_attributes, 0)   == 0 then return os_get_last_error2();
	if SetHandleInformation(stdin_write, HANDLE_FLAG_INHERIT, 0)        == 0 then return os_get_last_error2();

	// Create process
	process_info: PROCESS_INFORMATION;

	startup_info :: STARTUPINFOA.{
		cb          = auto sizeof(STARTUPINFOA),
		hStdError   = stdout_write,
		hStdOutput  = stdout_write,
		hStdInput   = stdin_read,
		dwFlags     = STARTF_USESTDHANDLES | STARTF_USESHOWWINDOW,
		wShowWindow = auto SW_HIDE,
	};

	command_line := str_make(executable);
	defer str_terminate(&command_line);

	loop i := 0; i < args.len; i += 1 {
		str_concat(&command_line, " ", args[i]);
	}

	str_append(&command_line, "\0"); // safe one copy.

	if CreateProcessA(null, auto command_line.ptr, null, null, TRUE, CREATE_SUSPENDED, null, null, &startup_info, &process_info) == 0 {
		CloseHandle(stdout_read);
		CloseHandle(stdout_write);
		CloseHandle(stdin_read);
		CloseHandle(stdin_write);
		return os_get_last_error2();
	}

	CloseHandle(stdout_write);
	CloseHandle(stdin_read);

	if AssignProcessToJobObject(job_handle, process_info.hProcess) == 0 {
		TerminateProcess(process_info.hProcess, 1);
		CloseHandle(process_info.hProcess);
		CloseHandle(process_info.hThread);
		CloseHandle(job_handle);
		CloseHandle(stdout_read);
		CloseHandle(stdin_write);
		return os_get_last_error2();
	}

	ResumeThread(process_info.hThread);
	CloseHandle(process_info.hThread);

	ctx.pid    = process_info.dwProcessId;
	ctx.stdin  = stdin_write;
	ctx.stdout = stdout_read;

	ctx.win_process_handle = process_info.hProcess;
	ctx.win_job_handle     = job_handle;

	return OK;
}

stop_process :: fn (ctx: *?TContext) Error {
	handles :: [_]*HANDLE.{ &ctx.win_process_handle, &ctx.win_job_handle, &ctx.stdout, &ctx.stdin };
	loop i := 0; i < handles.len; i += 1 {
		CloseHandle(@handles[i]);
		@handles[i] = INVALID_HANDLE_VALUE;
	}

	return OK;
}

// @Incomplete 2025-01-20: This might be rewritten using normal start_process api.
execute_system_command :: fn (cmd: string_view) Error {
	// Create process attributes
	startup_info: STARTUPINFOA;
	process_info: PROCESS_INFORMATION;
	startup_info.cb = auto sizeof(STARTUPINFOA);
	if CreateProcessA(null, strtoc(cmd), null, null, FALSE, 0, null, null, &startup_info, &process_info) == 0 then return os_get_last_error2();
	WaitForSingleObject(process_info.hProcess, INFINITE);
	CloseHandle(process_info.hProcess);
	CloseHandle(process_info.hThread);
	return OK;
}

PollEvent :: enum #flags {
	READ;
	CLOSED;
	WAIT;
}

poll_process :: fn (ctx: *?TContext) (PollEvent, Error) {
	result := PollEvent.WAIT;

	// Check if pipe has any data to read (process might be already closed).
	available_bytes: u32 #noinit;
	if PeekNamedPipe(ctx.stdout, null, 0, null, &available_bytes, null) == 0 {
		err :: os_get_last_error2();
		if err.code != ERROR_BROKEN_PIPE {
			return PollEvent.CLOSED, err;
		}
	}

	if available_bytes > 0 {
		result =  PollEvent.READ;
	} else {
		// Check if process is still alive.
		exit_code: DWORD;
		if GetExitCodeProcess(ctx.win_process_handle, &exit_code) != 0 {
			if exit_code != STILL_ACTIVE {
				ctx.exit_code = auto exit_code;
				result = PollEvent.CLOSED;
			}
		}
	}

	return result, OK;
}

read_pipe :: fn (stream: IoStream, dest: *string) Error {
	// @Incomplete 2025-01-11: This is a bit weird solution, but ReadFile would block in case
	// there are no data to read. This does not map well with POSIX version with non-blocking
	// pipes; we might come up with some better handling of this on windows.
	//
	// In general we use peek pipe to get available bytes for read and read just that data.
	available_bytes: u32 #noinit;
	if PeekNamedPipe(stream, null, 0, null, &available_bytes, null) == 0 then return os_get_last_error2();
	assert(available_bytes > 0, "Read should be called only in case there is data available in the pipe!");

	dest_index :: str_resize(dest, dest.len + auto available_bytes);

	n: DWORD;
	if ReadFile(stream, &(@dest)[dest_index], available_bytes, &n, null) == 0 then return os_get_last_error2();
	assert(n == available_bytes);

	return OK;
}

write_pipe :: fn (stream: IoStream, msg: string_view) Error {
	total_written : u32 = 0;
	msg_len :: cast(u32) msg.len;
	loop total_written < msg_len {
		write_size :: math.min(msg_len - total_written, 4096);

		n: DWORD;
		if WriteFile(stream, auto &msg[auto total_written], write_size, &n, null) == 0 then return os_get_last_error2();
		total_written += n;
	}
	assert(msg_len == total_written);
	return OK;
}

close_pipe :: fn (handle: *IoStream) {
	CloseHandle(@handle);
	@handle = INVALID_HANDLE_VALUE;
}

//
// MISC
//

get_current_date_as_YYYY_MM_DD :: fn () string_view {
	time: SYSTEMTIME #noinit;
	GetLocalTime(&time);

	return tprint("%-%-%",
		time.wYear,
		fmt_int(time.wMonth, FmtIntBase.DEC, false, 2),
		fmt_int(time.wDay, FmtIntBase.DEC, false, 2),
	);
}

get_fonts_directory :: fn () string {
	path :: get_home();
	str_append(&path, "/AppData/Local/Microsoft/Windows/Fonts");
	return path;
}

new_filepath_from_url :: fn (url: string_view) (err: Error, filepath: string) {
	buf: [MAX_PATH]u8 #noinit;
	len: DWORD = auto buf.len;
	status :: PathCreateFromUrlA(strtoc(url), auto buf.ptr, &len, 0);
	if status != S_OK {
		return error("Url '%' cannot be converted to file path.", url), string.{};
	}
	result :: str_make(string_view.{ auto len, buf.ptr });
	str_replace_all(&result, '\\', '/');
	return OK, result;
}

new_url_from_filepath :: fn (filepath: string_view) (err: Error, url: string) {
	buf: [2084]u8 #noinit; // INTERNET_MAX_URL_LENGTH
	len: DWORD = auto buf.len;
	status :: UrlCreateFromPathA(strtoc(filepath), auto buf.ptr, &len, 0);
	if status != S_OK {
		return error("Filepath '%' cannot be converted to URL.", filepath), string.{};
	}
	result :: str_make(string_view.{ auto len, buf.ptr });
	return OK, result;
}

get_file_last_write_time :: fn (filepath: string_view) (t: u64, err: Error) {
	attributes: WIN32_FILE_ATTRIBUTE_DATA;
	if GetFileAttributesExA(strtoc(filepath), GET_FILEEX_INFO_LEVELS.GetFileExInfoStandard, auto &attributes) == TRUE {
		tmp: union {
			wt: FILETIME;
			t: u64;
		};
		tmp.wt = attributes.ftLastWriteTime;
		return tmp.t, OK;
	}

	return 0, os_get_last_error2();
}

#load "posix.bl"

BUILD_COMMAND :: "./build.sh";
DEFAULT_SHELL :: "/bin/bash";


//
// MISC
//

get_fonts_directory :: fn () string {
	return str_make("/usr/share/fonts");
}

// Note 2025-01-11: We might reuse the same function on mac and windows.
new_url_from_filepath :: fn (filepath: string_view) (err: Error, url: string) {
	// @Incomplete 2025-01-11: Are there any possible fail cases to handle?

	result :: str_make(filepath.len);
	str_append(&result, "file://");
	loop i := 0; i < filepath.len; i += 1 {
		c :: filepath[i];
		if is_alpha(c) || is_digit(c) || c == '_' || c == '-' || c == '.' || c == '~' || c == '/' {
			str_append(&result, string_view.{ 1, &c });
		} else {
			str_append(&result, tprint("%%", "%", fmt_int(c, FmtIntBase.HEX, false, 2, true)));
		}
	}
	return OK, result;
}

// Note 2025-01-11: We might reuse the same function on mac and windows.
new_filepath_from_url :: fn (url: string_view) (err: Error, filepath: string) {
	result: string;
	if !str_match(url, "file://", 7) then return error("Proveded URL does not refer file."), result;
	if url.len == 7 then return error("No file path specified in URL."), result;

	filepath :: slice_range(url, 7);
	loop i := 0; i < filepath.len; {
		c := filepath[i];
		if is_alpha(c) || is_digit(c) || c == '_' || c == '-' || c == '.' || c == '~' || c == '/' {
			str_append(&result, string_view.{ 1, &c });
		} else if c == '%' && i + 2 < filepath.len {
			digits :: string_view.{ 2, &filepath[i+1] };
			n, err :: strtos64(digits, FmtIntBase.HEX);
			if err then return err, result;
			c = auto n;
			str_append(&result, string_view.{ 1, &c });
			i += 3;
			continue;
		} else {
			return error("Invalid URL."), result;
		}
		i += 1;
	}

	return OK, result;
}

get_file_last_write_time :: fn (filepath: string_view) (t: u64, err: Error) {
	using C;
	file_stat: stat_t #noinit;
	if stat(strtoc(filepath), &file_stat) == -1 {
		return 0, os_get_last_error2();
	}

	s  :: cast(u64) file_stat.st_mtim.tv_sec;
	ns :: cast(u64) file_stat.st_mtim.tv_nsec;

	t :: s * 1000 + ns / 1000000;
	return t, OK;
}

make_desktop_entry_if_needed :: fn () {
	filename :: "tine.desktop";
	filepath :: get_home();
	defer str_terminate(&filepath);
	if filepath.len < 1 then return;

	str_concat(&filepath, "/.local/share/applications/", filename);
	if file_exist(filepath) then return;


	appimagepath :: env_get("APPIMAGE");
	defer str_terminate(&appimagepath);

	execpath :: os_get_exec_path();
	defer str_terminate(&execpath);

	exec : string_view : if appimagepath.len > 0 then appimagepath else execpath;

	iconpath :: tprint("%/icon.png", data_dir);
	write_entire_file(iconpath, APP_ICON_DATA) catch print_err($);

	content ::
	"[Desktop Entry]\n"
	"Type=Application\n"
	"Name=Tine\n"
	"Exec=%\n"
	"Icon=%\n"
	"Categories=Application;Development;\n"
	;

	filled_content :: tprint(content, exec, iconpath);
	write_entire_file(filepath, filled_content) catch print_err($);

	print_info("Desktop entry file created at '%'.", filepath);
}

#private

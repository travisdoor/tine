#load "posix.bl"

BUILD_COMMAND :: "build.sh";
DEFAULT_SHELL :: "/bin/zsh";

//
// MISC
//

get_fonts_directory :: fn () string {
	return str_make("/System/Library/Fonts");
}

new_url_from_filepath :: fn (filepath: string_view) (err: Error, filepath: string) {
	result: string;

	cf_file_path :: CFStringCreateWithBytes(kCFAllocatorDefault, auto filepath.ptr, filepath.len, CFStringEncoding.UTF8, 0);
	defer CFRelease(cf_file_path);
	if !cf_file_path then return error("Failed to create CFString."), result;

	file_url :: CFURLCreateWithFileSystemPath(kCFAllocatorDefault, cf_file_path, 0, 0);
	defer CFRelease(file_url);
	if !file_url then return error("Failed to create CFURL."), result;

	url_string :: CFURLGetString(file_url);
	if !url_string then return error("Failed to get url string."), result;


	buf: [2048]C.char #noinit;
	if CFStringGetCString(url_string, buf.ptr, buf.len, CFStringEncoding.UTF8) == 0 {
		return error("Failed to get url string."), result;
	}

	str_append(&result, ctostr(buf.ptr));
	print_log("URL: %", result);
    return OK, result;
}

new_filepath_from_url :: fn (url: string_view) (err: Error, filepath: string) {
	result: string;

	cf_url_string :: CFStringCreateWithBytes(kCFAllocatorDefault, auto url.ptr, url.len, CFStringEncoding.UTF8, 0);
	defer CFRelease(cf_url_string);
	if !cf_url_string then return error("Failed to create file path from URL."), result;

	cf_url :: CFURLCreateWithString(kCFAllocatorDefault, cf_url_string, null);
	defer CFRelease(cf_url);
	if !cf_url then return error("Failed to create file path from URL."), result;

	cf_filepath :: CFURLCopyFileSystemPath(cf_url, 0);
	defer CFRelease(cf_filepath);
	if !cf_filepath then return error("Failed to create file path from URL."), result;

	buf: [2048]C.char #noinit;
	if CFStringGetCString(cf_filepath, buf.ptr, buf.len, CFStringEncoding.UTF8) == 0 {
		return error("Failed to create file path from URL."), result;
	}

	str_append(&result, ctostr(buf.ptr));
    return OK, result;
}

get_file_last_write_time :: fn (filepath: string_view) (t: u64, err: Error) {
	using C;
	file_stat: stat_t #noinit;
	if stat(strtoc(filepath), &file_stat) == -1 {
		return 0, os_get_last_error2();
	}

	s  :: cast(u64) file_stat.st_mtimespec.tv_sec;
	ns :: cast(u64) file_stat.st_mtimespec.tv_nsec;

	return s * 1000 + ns / 1000000, OK;
}

#scope_private
#import "os/macos"

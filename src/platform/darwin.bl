#load "posix.bl"

BUILD_COMMAND :: "build.sh";
DEFAULT_SHELL :: "/bin/zsh";

//
// MISC
//

get_fonts_directory :: fn () string {
	return str_make("/System/Library/Fonts");
}

new_url_from_filepath :: fn (filepath: string_view) (err: Error, filepath: string) {
	result: string;

	cf_file_path :: CFStringCreateWithBytes(kCFAllocatorDefault, auto filepath.ptr, filepath.len, CFStringEncoding.UTF8, 0);
	defer CFRelease(cf_file_path);
	if !cf_file_path then return error("Failed to create CFString."), result;

	file_url :: CFURLCreateWithFileSystemPath(kCFAllocatorDefault, cf_file_path, 0, 0);
	defer CFRelease(file_url);
	if !file_url then return error("Failed to create CFURL."), result;

	url_string :: CFURLGetString(file_url);
	if !url_string then return error("Failed to get url string."), result;


	buf: [2048]C.char #noinit;
	if CFStringGetCString(url_string, buf.ptr, buf.len, CFStringEncoding.UTF8) == 0 {
		return error("Failed to get url string."), result;
	}

	str_append(&result, ctostr(buf.ptr));
	print_log("URL: %", result);
    return OK, result;
}

new_filepath_from_url :: fn (url: string_view) (err: Error, filepath: string) {
	result: string;

	cf_url_string :: CFStringCreateWithBytes(kCFAllocatorDefault, auto url.ptr, url.len, CFStringEncoding.UTF8, 0);
	defer CFRelease(cf_url_string);
	if !cf_url_string then return error("Failed to create file path from URL."), result;

	cf_url :: CFURLCreateWithString(kCFAllocatorDefault, cf_url_string, null);
	defer CFRelease(cf_url);
	if !cf_url then return error("Failed to create file path from URL."), result;

	cf_filepath :: CFURLCopyFileSystemPath(cf_url, 0);
	defer CFRelease(cf_filepath);
	if !cf_filepath then return error("Failed to create file path from URL."), result;

	buf: [2048]C.char #noinit;
	if CFStringGetCString(cf_filepath, buf.ptr, buf.len, CFStringEncoding.UTF8) == 0 {
		return error("Failed to create file path from URL."), result;
	}

	str_append(&result, ctostr(buf.ptr));
    return OK, result;
}

//
// File change notifications
//

Watcher :: struct {
	stream: FSEventStreamRef;
	path:   string;
	flags:  WatchFor;
}

watch_init :: fn () {
	mutex_init(&mutex);
}

watch_terminate :: fn () {
	assert(watched.len == 0);
	tbl_terminate(&watched);
	tbl_terminate(&changed);

	mutex_terminate(&mutex);
}

WatchFor :: enum u32 #flags {
	FILE_CHANGES;
	DIRECTORY_CHANGES;
	MODIFICATIONS;
}

watch_changes :: fn (directory: string_view, flags: WatchFor) Error {
	hash :: hash_combine(str_hash(directory), cast(u32) flags);

	print_log("Watch changes: % (%)", directory, flags);

	path :: CFStringCreateWithBytes(kCFAllocatorDefault, auto directory.ptr, directory.len, CFStringEncoding.UTF8, 0);
	paths   :: CFArrayCreate(null, &path, 1, null);
	latency :: 3.0;

	w := tbl_lookup_ptr(&watched, hash);
	if w then return OK;

	w = tbl_insert(&watched, hash);

	ctx :: FSEventStreamContext.{
		info = auto w,
	};

	w.stream = FSEventStreamCreate(null, auto &change_callback, &ctx, paths, kFSEventStreamEventIdSinceNow, latency, kFSEventStreamCreateFlagNone);
	w.path   = str_make(directory);
	w.flags  = flags;

	run_loop :: CFRunLoopGetCurrent();
	run_loop_mode :: CFStringCreateWithCString(null, auto strtoc("kCFRunLoopDefaultMode"), CFStringEncoding.UTF8);
	defer CFRelease(run_loop_mode);

	FSEventStreamScheduleWithRunLoop(w.stream, run_loop, run_loop_mode);
	FSEventStreamStart(w.stream);

	return OK;
}

unwatch_changes :: fn (directory: string_view, flags: WatchFor) {
	hash :: hash_combine(str_hash(directory), cast(u32) flags);

	w := tbl_lookup_ptr(&watched, hash);
	assert(w);
	FSEventStreamStop(w.stream);
	FSEventStreamInvalidate(w.stream);
	FSEventStreamRelease(w.stream);
	str_terminate(&w.path);

	tbl_erase(&watched, hash);
}

next_watcher_event :: fn (changed_directory: *string_view, change_kind: *WatchFor) bool {
	mutex_lock(&mutex);
	defer mutex_unlock(&mutex);

	dt :: frame_delta_time;
	loop i := 0; i < changed.len; i += 1 {
		c :: &changed.values[i];
		c.timeout_ms -= dt;
		if c.timeout_ms < 0.f {
			@changed_directory = tprint("%", c.path);
			@change_kind       = c.flags;
			tbl_erase(&changed, changed.keys[i]);
			return true;
		}
	}

	return false;
}

get_file_last_write_time :: fn (filepath: string_view) (t: u64, err: Error) {
	using C;
	file_stat: stat_t #noinit;
	if stat(strtoc(filepath), &file_stat) == -1 {
		return 0, os_get_last_error2();
	}

	s  :: cast(u64) file_stat.st_mtimespec.tv_sec;
	ns :: cast(u64) file_stat.st_mtimespec.tv_nsec;

	return s * 1000 + ns / 1000000, OK;
}

#scope_private
#import "os/macos"

Change :: struct {
	path:  string;
	flags: WatchFor;
	timeout_ms: f32;
}

watched: Table(u32, Watcher);
changed: Table(string_view, Change);
mutex: Mutex;

change_callback :: fn (
	_: ConstFSEventStreamRef,
	watcher: *Watcher,
	_: usize,
	_: *u8,
	_: *FSEventStreamEventFlags,
	_: *FSEventStreamEventId
) {
	mutex_lock(&mutex);
	defer mutex_unlock(&mutex);

	c := tbl_lookup_ptr(&changed, watcher.path);
	if !c {
		c = tbl_insert(&changed, watcher.path);
		c.path  = watcher.path;
		c.flags = auto 0;
	}
	c.flags |= watcher.flags;
	c.timeout_ms = 200.f;
};

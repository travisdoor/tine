BUILD_SCRIPT :: "build.sh";
SHELL :: "/bin/zsh";
BUILD_ARGS :: [_]string_view.{ BUILD_SCRIPT };

//
// Process
//

IoStream :: C.int;
Pid :: C.pid_t;

start_process :: fn (ctx: *?TContext, cmd: string_view, args: []string_view) Error {
	in_pipe:  [2]s32 #noinit;
	out_pipe: [2]s32 #noinit;

	executable :: str_new(256);
	defer str_delete(&executable);

	err :: lookup_executable(cmd, &executable);
	if err then return err;

	print_log("Execute '%' with args: %", executable, args);

	if C.pipe(in_pipe.ptr) != 0 {
		return os_get_last_error2();
	}
	if C.pipe(out_pipe.ptr) != 0 {
		return os_get_last_error2();
	}

	flags :: C.fcntl(out_pipe[0], C.F_GETFL);
	if flags == -1 then return os_get_last_error2();
	if C.fcntl(out_pipe[0], C.F_SETFL, flags | C.O_NONBLOCK) == -1 then return os_get_last_error2();

	pid :: C.fork();
	if pid == -1 {
		return os_get_last_error2();
	}
	if pid == 0 {
		// child
		C.dup2(in_pipe[0], C.STDIN);
		C.dup2(out_pipe[1], C.STDOUT);

		C.close(in_pipe[1]);
		C.close(out_pipe[0]);

		C.dup2(C.STDOUT, C.STDERR);

		argc :: args.len + 2; // +2 executable and null terminator
		buf: [16]*C.char #noinit;
		assert(argc < buf.len);

		_, exec_name :: path_split(executable);

		cargs := []*C.char.{ ptr = auto buf.ptr, len = argc };
		cargs[0] = strtoc(exec_name);
		cargs[cargs.len-1] = null;
		loop i := 1; i < cargs.len-1; i += 1 {
			cargs[i] = strtoc(args[i-1]);
		}

		C.execv(strtoc(executable), cargs.ptr);
		print_err("Execution failed with error: %", os_get_last_error2());
		C.exit(1);
	} else {
		// parent
		print_log("Starting process with PID %.", pid);
		ctx.pid = pid;

		C.close(out_pipe[1]);
		C.close(in_pipe[0]);

		ctx.stdout = out_pipe[0];
		ctx.stdin  = in_pipe[1];
	}

	return OK;
}

execute_system_command :: fn (cmd: string_view) Error {
	cmd;
	print_warn("Not implemented!");
	return OK;
}

kill_process :: fn (pid: Pid, exit_code: s32) Error {
	using C;
	exit_code;  // @Incomplete: use this?
	if kill(pid, SIGTERM) == -1 then os_get_last_error2();
	return OK;
}

PollEvent :: enum #flags {
    READ;
    CLOSED;
    WAIT;
}

poll_pipe :: fn (stream: IoStream) (PollEvent, Error) {
    using C;
    pfd := pollfd.{
        fd = stream,
        events = POLLIN,
    };

    poll_result :: poll(&pfd, 1, 1);
    if poll_result > 0 {
        result := PollEvent.WAIT;

        if (pfd.revents & POLLIN) != 0 {
            result = PollEvent.READ;
        }
        if (pfd.revents & POLLHUP) != 0 {
            result |= PollEvent.CLOSED;
        }
        return result, OK;
    } else if poll_result == 0 {
        return PollEvent.WAIT, OK;
    }
    return PollEvent.CLOSED, os_get_last_error2();
}

read_pipe :: fn (stream: IoStream, dest: *string) Error {
    using C;
    loop i := 0;; i+=1 {
        buf:  [2048]u8 #noinit;
        n :: read(stream, auto buf.ptr, auto buf.len);
		if n == -1 {
			err :: os_get_last_error2();
			if err.code == EAGAIN then return OK;
			return err;
		}
        if n ==  0 then break;

		print_log("%", string_view.{ auto n, buf.ptr });
        str_append(dest, string_view.{ auto n, buf.ptr });
    }
	return OK;
}

write_pipe :: fn (stream: IoStream, msg: string_view) Error {
	using C;
	total_written : s64 = 0;
	loop total_written < msg.len {
		write_size :: math.min(msg.len - total_written, 4096);
		n :: write(stream, auto &msg[total_written], auto write_size);
		if n == -1 then return os_get_last_error2();
		total_written += n;
	}
	assert(msg.len == total_written);
	return OK;
}

close_stream :: fn (handle: IoStream) {
	C.close(handle);
}

//
// MISC
//

get_current_date_as_YYYY_MM_DD :: fn () string_view {
	time :: C.time(null);
	tm :: C.localtime(&time);
	buf: [11]C.char;
	C.strftime(buf.ptr, auto buf.len, strtoc("%Y-%m-%d"), tm);
	return tprint("%", ctostr(buf.ptr));
}

get_fonts_directory :: fn () string {
	return str_new("/System/Library/Fonts");
}

new_url_from_filepath :: fn (filepath: string_view) (err: Error, filepath: string) {
	result :: str_new();

	cf_file_path :: CFStringCreateWithBytes(kCFAllocatorDefault, auto filepath.ptr, filepath.len, CFStringEncoding.UTF8, 0);
	defer CFRelease(cf_file_path);
	if !cf_file_path then return error("Failed to create CFString."), result;

	file_url :: CFURLCreateWithFileSystemPath(kCFAllocatorDefault, cf_file_path, 0, 0);
	defer CFRelease(file_url);
	if !file_url then return error("Failed to create CFURL."), result;

	url_string :: CFURLGetString(file_url);
	if !url_string then return error("Failed to get url string."), result;


	buf: [2048]C.char #noinit;
	if CFStringGetCString(url_string, buf.ptr, buf.len, CFStringEncoding.UTF8) == 0 {
		return error("Failed to get url string."), result;
	}

	str_append(&result, ctostr(buf.ptr));
	print_log("URL: %", result);
    return OK, result;
}

new_filepath_from_url :: fn (url: string_view) (err: Error, filepath: string) {
	result :: str_new();

	cf_url_string :: CFStringCreateWithBytes(kCFAllocatorDefault, auto url.ptr, url.len, CFStringEncoding.UTF8, 0);
	defer CFRelease(cf_url_string);
	if !cf_url_string then return error("Failed to create file path from URL."), result;

	cf_url :: CFURLCreateWithString(kCFAllocatorDefault, cf_url_string, null);
	defer CFRelease(cf_url);
	if !cf_url then return error("Failed to create file path from URL."), result;

	cf_filepath :: CFURLCopyFileSystemPath(cf_url, 0);
	defer CFRelease(cf_filepath);
	if !cf_filepath then return error("Failed to create file path from URL."), result;

	buf: [2048]C.char #noinit;
	if CFStringGetCString(cf_filepath, buf.ptr, buf.len, CFStringEncoding.UTF8) == 0 {
		return error("Failed to create file path from URL."), result;
	}

	str_append(&result, ctostr(buf.ptr));
    return OK, result;
}

init_clipboard :: fn () {
	clipboard.init();
}

terminate_clipboard :: fn () {
	clipboard.terminate();
}

read_clipboard :: fn () string_view {
	return clipboard.get();
}

write_clipboard :: fn (text: string_view) {
	clipboard.set(text);
}

//
// File change notifications
//

Watcher :: struct {
	stream: FSEventStreamRef;
	path:   string;
	flags:  WatchFor;
}

watch_init :: fn () {
	mutex_init(&mutex);
}

watch_terminate :: fn () {
	assert(watched.len == 0);
	tbl_terminate(&watched);
	tbl_terminate(&changed);

	mutex_terminate(&mutex);
}

WatchFor :: enum u32 #flags {
	FILE_CHANGES;
	DIRECTORY_CHANGES;
	MODIFICATIONS;
}

watch_changes :: fn (directory: string_view, flags: WatchFor) Error {
	hash :: hash_combine(str_hash(directory), cast(u32) flags);

	print_log("Watch changes: % (%)", directory, flags);

	path :: CFStringCreateWithBytes(kCFAllocatorDefault, auto directory.ptr, directory.len, CFStringEncoding.UTF8, 0);
	paths   :: CFArrayCreate(null, &path, 1, null);
	latency :: 3.0;

	w := tbl_lookup_ptr(&watched, hash);
	if w then return OK;

	w = tbl_insert(&watched, hash);

	ctx :: FSEventStreamContext.{
		info = auto w,
	};

	w.stream = FSEventStreamCreate(null, auto &change_callback, &ctx, paths, kFSEventStreamEventIdSinceNow, latency, kFSEventStreamCreateFlagNone);
	w.path   = str_new(directory);
	w.flags  = flags;

	run_loop :: CFRunLoopGetCurrent();
	run_loop_mode :: CFStringCreateWithCString(null, auto strtoc("kCFRunLoopDefaultMode"), CFStringEncoding.UTF8);
	defer CFRelease(run_loop_mode);

	FSEventStreamScheduleWithRunLoop(w.stream, run_loop, run_loop_mode);
	FSEventStreamStart(w.stream);

	return OK;
}

unwatch_changes :: fn (directory: string_view, flags: WatchFor) {
	hash :: hash_combine(str_hash(directory), cast(u32) flags);

	w := tbl_lookup_ptr(&watched, hash);
	assert(w);
	FSEventStreamStop(w.stream);
	FSEventStreamInvalidate(w.stream);
	FSEventStreamRelease(w.stream);
	str_delete(&w.path);

	tbl_erase(&watched, hash);
}

next_watcher_event :: fn (changed_directory: *string_view, change_kind: *WatchFor) bool {
	mutex_lock(&mutex);
	defer mutex_unlock(&mutex);

	dt :: frame_delta_time;
	loop i := 0; i < changed.len; i += 1 {
		c :: &changed.values[i];
		c.timeout_ms -= dt;
		if c.timeout_ms < 0.f {
			@changed_directory = tprint("%", c.path);
			@change_kind       = c.flags;
			tbl_erase(&changed, changed.keys[i]);
			return true;
		}
	}

	return false;
}

get_file_last_write_time :: fn (filepath: string_view) (t: u64, err: Error) {
	using C;
	file_stat: stat_t #noinit;
	if stat(strtoc(filepath), &file_stat) == -1 {
		return 0, os_get_last_error2();
	}

	s  :: cast(u64) file_stat.st_mtimespec.tv_sec;
	ns :: cast(u64) file_stat.st_mtimespec.tv_nsec;

	return s * 1000 + ns / 1000000, OK;
}

#scope_private
#import "os/macos"
clipboard :: #import "extra/clipboard";

Change :: struct {
	path:  string;
	flags: WatchFor;
	timeout_ms: f32;
}

watched: Table(u32, Watcher);
changed: Table(string_view, Change);
mutex: Mutex;

change_callback :: fn (
	_: ConstFSEventStreamRef,
	watcher: *Watcher,
	_: usize,
	_: *u8,
	_: *FSEventStreamEventFlags,
	_: *FSEventStreamEventId
) {
	mutex_lock(&mutex);
	defer mutex_unlock(&mutex);

	c := tbl_lookup_ptr(&changed, watcher.path);
	if !c {
		c = tbl_insert(&changed, watcher.path);
		c.path  = watcher.path;
		c.flags = auto 0;
	}
	c.flags |= watcher.flags;
	c.timeout_ms = 200.f;
};

lookup_executable :: fn (path: string_view, full_path: *string) Error {
	full_path.len = 0;
	if C.access(strtoc(path), C.X_OK) == 0 {
		str_append(full_path, path);
		return OK;
	}
	env_path :: env_get("PATH");
	if env_path.len == 0 then return error(ERR_NOT_FOUND, "File not found.");
	allocator :: application_context.temporary_allocator;
	paths :: str_split_by(env_path, ':', allocator);

	loop i := 0; i < paths.len; i += 1 {
		str_clear_concat(full_path, paths[i], "/", path);
		if C.access(strtoc(@full_path), C.X_OK) == 0 then return OK;
	}
	full_path.len = 0;
	return error(ERR_NOT_FOUND, "File not found.");
}
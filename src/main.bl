#import "extra/glfw3"
#import "extra/draw"
#import "std/debug_allocator"
#import "std/fs"
#import "std/pool"
#import "std/async"
#import "clipboard"

#load "buffer.bl"
#load "commands.bl"
#load "editor.bl"
#load "goto.bl"
#load "listing.bl"
#load "open_from_drive.bl"
#load "quick_open.bl"
#load "save_to_drive.bl"
#load "command_run.bl"
#load "key_names.bl"
#load "search.bl"
#load "utils.bl"
#load "project.bl"
#load "open_project.bl"
#load "search_in_project.bl"
#load "clang_format.bl"
#load "builder.bl"
#load "lsp.bl"
#load "completion.bl"
#load "replace.bl"

#load "syntax/bl.bl"
#load "syntax/project.bl"
#load "syntax/cpp.bl"
#load "syntax/messages.bl"
#load "syntax/build.bl"
#load "syntax/md.bl"
#load "syntax/glsl.bl"
#load "syntax/search.bl"
#load "syntax/asm.bl"

LineEnding :: enum {
	UNKNOWN;
	CRLF;
	LF;
}

// @Incomplete: Set from settings?
WINDOW_WIDTH  := 800;
WINDOW_HEIGHT := 600;
WINDOW_TITLE  :: "Tine"; // This is not Emacs

WINDOW_SCALE: f32;
scaling_changed := false;

MOUSE_DRAG_OFFSET :: 4.f;
MOUSE_DBL_CLICK_S :: 0.5;

CODE_COLOR_DEFAULT_INDEX   : u8 : 0;
CODE_COLOR_CURSOR_INDEX    : u8 : 1;
CODE_COLOR_KEYWORD_INDEX   : u8 : 2;
CODE_COLOR_COMMENT_INDEX   : u8 : 3;
CODE_COLOR_DIRECTIVE_INDEX : u8 : 4;
CODE_COLOR_STRING_INDEX    : u8 : 5;
CODE_COLOR_INVALID_INDEX   : u8 : 6;
CODE_COLOR_NUMBER_INDEX    : u8 : 7;
CODE_COLOR_ERROR_INDEX     : u8 : 9;
CODE_COLOR_WARNING_INDEX   : u8 : 10;

DEFAULT_FONT_SIZE              :: 20;
MAX_FONT_SIZE                  :: 64;
MIN_FONT_SIZE                  :: 4;
LINE_SPACING                   :: 1.3f;
BOTTOM_SCROLL_TRIGGER          :: 5;

DEFAULT_CONFIG_FILE :: "default.proj";
PROJECTS_DIRECTORY  :: "projects";
BUILD_SCRIPT        :: "build.bat";
FONT_DIRECTORY: string;

FONT_RESIZE_STEP :: 1;

CARET_BLINK_MS :: 500.f;

// Unicode awesome font codes.
ICON_BELL        : u32 : 0xF0A2;
ICON_FILE        : u32 : 0xF1C9;
ICON_CHANGES     : u32 : 0xF044;
ICON_FOLDER      : u32 : 0xF07B;
ICON_DRIVE       : u32 : 0xF0A0;
ICON_COMMAND     : u32 : 0x26A1;
ICON_PROJECT     : u32 : 0xF6D1;
ICON_READONLY    : u32 : 0xF023;
ICON_WARNING     : u32 : 0x26A0;
ICON_ERROR       : u32 : 0xF06A;

ICON_BUILD    : u32 : 0xF6E3;
ICON_MESSAGES : u32 : 0x2709;

// Static assets loaded directly into the executable data segment.
FONT                          :: "JetBrainsMono-Regular.ttf";
FONT_UI                       :: "SourceSans3-Regular.ttf";
FONT_UI_B                     :: "SourceSans3-Bold.ttf";

ICONS                         :: "fa-solid-900.ttf";
APPLICATION_ICON              :: "icon/icon-flip.png";
DEFAULT_PROJECT_FILE_TEMPLATE :: "default-config-file-template.proj";
HELP_FILE                     :: "README.md";

FONT_DATA                          :: file_to_stack(FONT);
FONT_UI_DATA                       :: file_to_stack(FONT_UI);
FONT_UI_B_DATA                     :: file_to_stack(FONT_UI_B);
ICON_DATA                          :: file_to_stack(ICONS);
DEFAULT_PROJECT_FILE_TEMPLATE_DATA :: file_to_stack(DEFAULT_PROJECT_FILE_TEMPLATE);
APPLICATION_ICON_DATA              :: file_to_stack(APPLICATION_ICON);
HELP_FILE_DATA                     :: file_to_stack(HELP_FILE);

MAX_VISIBLE_SEARCH_RESULTS_IN_EDITOR :: 1024;

PROJECT_IS_INDEXING_MESSAGE :: "Project indexing in progress, please wait.";

window: *glfw.Window;

font:      draw.Font;
font_ui:   draw.Font;
font_ui_b: draw.Font;
icons:     draw.Font;

current_font_hash: u32;

buffers: [..]Buffer;
editors: [..]Editor;

frame_delta_time: f32;

editor_start_time: s64;

active_editor  : s32 = -1;
command_editor : s32 = -1;

notify_changes_to_buffer: s32 = -1;

// Used for logs/errors/warnings etc.
messages_buffer_index := -1;
help_buffer_index     := -1;
search_buffer_index   := -1;

is_project_indexing_paused := false;

SearchLocation :: struct {
	start: s32;
	end:   s32;
	row:   s32;
	col:   s32;
}

search: struct {
	last_subject:     string;
	last_replacement: string;
	results:      [..]SearchLocation;
	result_index:     s64;
}

// Points to previous active text editor, this might be used in interactive modes where we need the text buffer
// as context (e.g. search mode).
last_active_text_editor : s32 = -1;

Split :: enum { FLOATING; LEFT; RIGHT; }

left:  s32 = -1;
right: s32 = -1;

Metric :: enum s64 {
	LINE_HEIGHT;
	TITLE_BAR_HEIGHT;
	ITEM_SPACING;
	TEXT_PADDING;
	TITLE_MAX_SIZE;
	SHADOW_SIZE;
	CORNER_ROUNDING;
}

metrics: [enum_count(Metric)]f32;

InputMode :: enum {
	TEXT;
	NUMBERS;
}

input_mode: InputMode;

Message :: struct {
	using std;

	kind:  PrintLogKind;
	text:  string;

	mutex: Mutex;
}

Mode :: enum {
	TEXT_EDIT;
	GOTO_LINE;
	OPEN_FROM_DRIVE;
	QUICK_OPEN;
	SAVE_TO_DRIVE;
	RUN_COMMAND;
	SEARCH_FILE;
	OPEN_PROJECT;
	SEARCH_IN_PROJECT;
	COMPLETION;
	REPLACE;
}

mode: Mode;

FileType :: enum {
	UNKNOWN;
	BL;
	C;
	PROJ;
	MD;
	GLSL;
	ASM;
}

FILE_TYPE_NAME ::         [enum_count(FileType)]string_view.{ "Text", "BL", "C/C++", "Configuration", "Markdown", "GLSL", "ASM" };
FILE_TYPE_COMMENT_WITH :: [enum_count(FileType)]string_view.{ "",     "//", "//",    "#",             ""        , "//",   ";"   };
FILE_TYPE_REINDENT_ON ::  [enum_count(FileType)]string_view.{ "",     "}",  "}",     "",              ""        , "}",    ":"   };

project: struct {
	using std;

	name:       string_view;
	filepath:   string_view;
	is_default: bool;

	included_directories: [..]string_view;
	included_extensions:  [..]string_view;
	excluded_directories: [..]string_view;

	is_indexing:   bool;
	indexed_files: [..]string_view;

	mutex: Mutex;
	string_cache: std.PoolAllocator;
}

// Global application settings loaded from the configuraiton file. These might be overriden by local project settings.
Settings :: struct {
	font_size: s32;
	tab_size:  s32;

	font: string;

	insert_spaces_instead_tabs:             bool;
	trim_trailing_whitespace_on_save:       bool;
	indent_on_paste:                        bool;
	indent_on_new_line:                     bool;
	vertical_move_tries_follow_indentation: bool;
	indent_on_tab:                          bool;
	use_lsp:                                bool;
	show_lsp_inline_diagnostics:            bool;
	block_caret:                            bool;
	word_wrap:                              bool;
	maximize_on_start:                      bool;
	save_all_before_build:                  bool;
	show_hints:                             bool;
};

settings: Settings;

Colors :: struct {
	using glm;

	background_color                    : v4;
	foreground_color                    : v4;
	cursor_background_color             : v4;
	cursor_foreground_color             : v4;
	current_line_background_color       : v4;
	search_result_background_color      : v4;
	title_bar_color                     : v4;
	title_bar_active                    : v4;
	title_bar_text_color                : v4;
	command_background_color            : v4;
	command_foreground_color            : v4;
	command_title_color                 : v4;
	command_select_color                : v4;
	command_list_background_color       : v4;
	modification_indicator_color        : v4;
	selection_background_color          : v4;
	selection_background_inactive_color : v4;
	message_color                       : v4;
	warning_color                       : v4;
	error_color                         : v4;
	inline_error_background_color       : v4;
	inline_warning_background_color     : v4;

	// code
	code_comment   : v4;
	code_keyword   : v4;
	code_directive : v4;
	code_string    : v4;
	code_number    : v4;
	code_invalid   : v4;
	code_error     : v4;
	code_warning   : v4;
}

colors:           Colors;
code_color_table: [11]glm.v4;

//
// Build errors
//

ErrorLocation :: struct {
	kind: enum { ERROR; WARNING; };
	message:   string_view;
	file:      string_view;
	file_hash: u32;
	line_hash: u32;
	line:      s32;
	col:       s32;
	is_hidden: bool;
};

error_list:       [..]ErrorLocation;
error_list_index:     s64;
error_marker_visible: bool;

clear_error_list :: fn () {
	error_list.len   =  0;
	error_list_index = -1;
	error_marker_visible = false;
}

//
// Recent locations
//

recent_locations: struct {
	stack: [..]s32;
	index:     s32;

	did_jump: bool;
};

add_recent_location :: fn (editor: *Editor) {
	assert(editor.track_recent_locations);
	rl :: &recent_locations;
	if rl.did_jump {
		rl.did_jump = false;
		return;
	}
	if rl.index >= 0 {
		if rl.stack[rl.index] == editor.index { return; }
		// Drop rest of the stack here.
		rl.stack.len = auto rl.index + 1;
	}
	array_push(&rl.stack, editor.index);
	rl.index = auto rl.stack.len-1;
}

erase_all_locations_for_editor :: fn (editor: *Editor) {
	// Erase also current editor index.
	assert(editor.track_recent_locations);
	rl  :: &recent_locations;
	loop i := 0; i < rl.stack.len; {
		editor_index :: rl.stack[i];
		if editor_index == editor.index {
			array_erase_keep_order(&rl.stack, i);
			if rl.index >= i { rl.index -= 1; }
			continue;
		}
		i += 1;
	}
}

jump_to_previous_location :: fn () bool {
	rl  :: &recent_locations;
	if rl.index < 1 { return false; }
	assert(active_editor != command_editor);

	rl.index -= 1;
	activate_editor(rl.stack[rl.index]);
	rl.did_jump = true;

	return true;
}

jump_to_next_location :: fn () bool {
	rl  :: &recent_locations;
	if rl.index+1 >= rl.stack.len { return false; }
	assert(active_editor != command_editor);

	rl.index += 1;
	activate_editor(rl.stack[rl.index]);
	rl.did_jump = true;

	return true;
}

// Points to the directory containing editor executable (does not contain the last path separator).
exec_dir: string_view;

// Path where to store projects folder and default config, same as exec_dir on Windows.
data_dir: string;

//
// Mouse
//

MouseState :: enum #flags {
	LB_PRESS;
	LB_DOWN;
	LB_RELEASE;
	LB_DBL_PRESS;
	LB_DRAGGING_START;
	LB_DRAGGING;
}

MouseCursor :: enum {
	DEFAULT;
	IBEAM;
}

mouse: struct {
	px:     f32;
	py:     f32;
	scroll: f32;

	last_hover_elem_id:  u32;
	hover_elem_id:       u32;
	drag_target_elem_id: u32;

	state: MouseState;

	current_cursor: MouseCursor;
	beam_cursor:   *glfw.Cursor;

	prev_mouse_pos: glm.v2;
	prev_click_time_s: f64;
};

// We can speed up rendering and disable low-power mode in case some animation is running. Next
// frame will not wait for inputs.
force_redraw := false;

main :: fn () s32 {
	using glfw;
	using std;

	// Setup debug allocator in DEBUG mode.
	prev_allocator: *Allocator;
#if IS_DEBUG {
	debug_allocator = debug_allocator_make(application_context.allocator);
	prev_allocator  = set_allocator_allocator(auto &debug_allocator);
}
	defer set_allocator_allocator(prev_allocator);
	defer temporary_release();

	//debug_allocator_break(&debug_allocator, 3);

	MAIN_THREAD_ID = get_thread_id();
	FONT_DIRECTORY = get_fonts_directory();
	defer str_delete(&FONT_DIRECTORY);

	mutex_init(&message.mutex);
	defer mutex_terminate(&message.mutex);
	defer str_delete(&message.text);

	// Clipboard
	clipboard.init();
	defer clipboard.terminate();

	// Recent location
	recent_locations.index = -1;
	defer array_terminate(&recent_locations.stack);

	// Create command editor.
	command_editor = add_editor(add_command_buffer());
	// Messages buffer
	messages_buffer_index = add_messages_buffer("messages");

	default_logger :: set_logger(&logger);
	defer set_logger(default_logger);

	print_log("Font directory: '%'", FONT_DIRECTORY);

	editor_start_time = get_timestamp();
	print_log("Editor start time is %.", editor_start_time);


	// Resolve editor executable path.
	exec_path :: os_get_exec_path();
	defer str_delete(&exec_path);

	head :: path_split(exec_path);
	exec_dir = head;
	if exec_dir.len > 0 && exec_dir[exec_dir.len-1] == '/' {
		exec_dir.len -= 1;
	}

	if exec_dir.len == 0 {
		print_warn("Unable to resolve the root directory of the editor executable.");
	} else {
		print_log("Editor executable directory: '%'", exec_dir);
	}

	#if PLATFORM == Platform.WINDOWS {
		data_dir = str_new(exec_dir);
	} else {
		data_dir = get_home();
		str_append(&data_dir, "/.tine");
		if !file_exist(data_dir) {
			err :: create_dir(data_dir);
			if err {
				panic(err);
			} else {
				print_log("Tine directory created at '%'.", data_dir);
			}
		}
	}

	defer str_delete(&data_dir);

	print_log("Editor data directory: '%'", data_dir);

	// must be before project...
	watch_init();
	defer watch_terminate();

	init_project();
	defer terminate_project();

	defer array_terminate(&key_binding);

	// Initialize GLFW.
	if glfw.Init() == 0 {
		print_glfw_error();
		panic("Cannot initialize glfw.\n");
	}
	defer glfw.Terminate();

	// Create GLFW window.
	WindowHint(CONTEXT_VERSION_MAJOR, 3);
	WindowHint(CONTEXT_VERSION_MINOR, 3);
	WindowHint(OPENGL_FORWARD_COMPAT, 1);
	WindowHint(OPENGL_PROFILE, OPENGL_CORE_PROFILE);

	WindowHint(DOUBLEBUFFER, TRUE);
	WindowHint(RESIZABLE, TRUE);
	WindowHint(SAMPLES, 2);

	window = CreateWindow(WINDOW_WIDTH, WINDOW_HEIGHT, strtoc(WINDOW_TITLE), null, null);
	defer DestroyWindow(window);

	if !window {
		print_glfw_error();
		panic("Cannot create GLFW window.\n");
	}

	set_icon();

	SetWindowSizeLimits(window, 640, 480, DONT_CARE, DONT_CARE);
	GetFramebufferSize(window, &WINDOW_WIDTH, &WINDOW_HEIGHT);
	GetWindowContentScale(window, &WINDOW_SCALE, null);

	MakeContextCurrent(window);

	SetKeyCallback(window, &key_callback);
	SetCharCallback(window, &character_callback);
	SetWindowSizeCallback(window, &window_size_callback);
	SetWindowContentScaleCallback(window, &window_scale_callback);
	SetWindowIconifyCallback(window, &window_iconify_callback);
	SetWindowFocusCallback(window, &window_focus_callback);
	SetMouseButtonCallback(window, &mouse_button_callback);
	SetScrollCallback(window, &scroll_callback);
	SetDropCallback(window, &drop_callback);

	draw.init(WINDOW_WIDTH, WINDOW_HEIGHT);
	defer draw.terminate();

	project_dir_path :: tprint("%/%", data_dir, PROJECTS_DIRECTORY);
	if !file_exist(project_dir_path) {
		err :: create_dir(project_dir_path);
		if err {
			print_err(err);
		} else {
			print_log("Projects directory created at '%'.", project_dir_path);
		}
	}

	// Initial readme file on the first start.
	show_help := false;

	// Check whether the default project file exists.
	if !is_default_project_exists() {
		show_help = true;
		err :: setup_after_first_run();
		if err {
			print_err(err);
		} else {
			print_log("Default project file created.");
		}
	} else {
		// Try to load it, note that in case of fail, we use default setting implicitly (even if the file
		// content is invalid).
		err :: load_default_project_file();
		if err {
			print_err(err);
		} else {
			print_log("Default project file loaded from disk.");
		}
	}

	defer str_delete(&settings.font);

	rebuild_fonts();
	defer draw.font_terminate(&font);
	defer draw.font_terminate(&font_ui);
	defer draw.font_terminate(&font_ui_b);
	defer draw.font_terminate(&icons);

	listing_init();
	defer listing_terminate();

	// Initialize async job system.
	jobs_init();

	lsp_init();
	defer lsp_terminate();

	build_init();

	// Cleanup error list...
	defer array_terminate(&error_list);

	// Search stuff
	array_init(&search.results, 1024);

	defer str_delete(&search.last_subject);
	defer str_delete(&search.last_replacement);
	defer array_terminate(&search.results);

	loop i := 1; i < command_line_arguments.len; i += 1 {
		filepath :: command_line_arguments[i];
		buf_error :: open(filepath);
		if buf_error {
			print_err(buf_error);
		}
	}

	if active_editor == -1 {
		active_editor = add_editor(add_buffer(), true, Split.LEFT);
		left          = active_editor;
	}

	assert(left != -1);
	assert(active_editor != -1);

	// cursors
	mouse.beam_cursor = CreateStandardCursor(IBEAM_CURSOR);
	defer DestroyCursor(mouse.beam_cursor);

	SwapInterval(1);
	prev_time := GetTime();
	prev_frame_delta := -1.f #maybe_unused;
	fps, fps_sum: f32 #maybe_unused;
	fps_num: s32 #maybe_unused;

	if show_help {
		help();
	}

	if settings.maximize_on_start {
		MaximizeWindow(window);
	}

	prev_active_editor := -1;
	last_focus_index := 0;

	loop WindowShouldClose(window) == 0 {
		current_time :: glfw.GetTime();
		frame_delta_time = auto (current_time - prev_time) * 1000.;
		prev_time = current_time;

		#if PLATFORM == Platform.DARWIN {
			// Limit maximum FPS on mac since vsync seems not work.
			if prev_frame_delta <= 33.f && prev_frame_delta > 0.f {
				os_sleep_ms(cast(u32) (33.f - prev_frame_delta));
			}
		}

		wait_s := 0.100;
		if low_power_mode && force_redraw == false {
			wait_s = 1.0;
		} else if force_redraw {
			wait_s = 0.016;
		}
		force_redraw = false;

		WaitEventsTimeout(wait_s);

		update_mouse();
		update_caret();

		if build.job_index == -1 {
			// Disable indexing in case there is ongoing compilation (which might produce multiple file-change events).
			changed_directory: string_view;
			change_kind: WatchFor;
			loop next_watcher_event(&changed_directory, &change_kind) {
				if check_project_changes(changed_directory, change_kind) { continue; }
			}
		}

		if !is_project_indexing_paused {
			maybe_reindex_current_project();
		}
		update_jobs(); // Also process all responses...

		buf, editor :: get_active_buffer_and_editor();
		if prev_active_editor != active_editor {
			prev_active_editor = active_editor;
			buf.last_focus_index = last_focus_index;
			last_focus_index += 1;

			if editor.track_recent_locations {
				add_recent_location(editor);
			}
		}

		draw_frame();
		scaling_changed = false;

		title: string_view;
		#if IS_DEBUG && false {
			fps_num += 1;
			fps_sum += 1000.f/frame_delta_time;
			if fps_num == 10 {
				fps = fps_sum / auto fps_num;
				fps_sum = 0.f;
				fps_num = 0;
			}
			title = tprint("FPS: %", fps);
			SetWindowTitle(window, auto std.strtoc(title));
		} else {
			if project.is_default {
				title = buf.name;
			} else {
				title = tprint("% - %", project.name, buf.name);
			}
			SetWindowTitle(window, auto std.strtoc(title));
		}
		clear_mouse_events();
		prev_frame_delta = frame_delta_time;
	}

	// Terminate any possible active mode.
	set_mode(Mode.TEXT_EDIT);

	// Terminate all pending jobs. After that it's save to remove all buffers and editors.
	jobs_terminate();

	// To speed things up a bit.
	recent_locations.stack.len = 0;

	loop i := 0; i < editors.len; i += 1 { remove_editor(i); }
	loop i := 0; i < buffers.len; i += 1 { remove_buffer(i); }

	array_terminate(&editors);
	array_terminate(&buffers);

	print_log("DONE.");
	return 0;
}

in_bounds :: fn (arr: []?T, v: s64) bool #inline {
	return v >= 0 && v < arr.len;
}

lookup_font :: fn (font_name: string_view) string_view {
	using std;
	assert(font_name.len > 0);
	if file_exist(font_name)) {
		return font_name;
	}
	if FONT_DIRECTORY.len == 0 { return ""; }
	tmp :: tprint("%/%", FONT_DIRECTORY, font_name);
	if file_exist(tmp)) {
		return tmp;
	}
	return "";
}

rebuild_fonts :: fn () Error {
	size := settings.font_size;
	custom_font_path := "";
	font_hash: u32 = 0;

	if settings.font.len > 0 {
		custom_font_path = lookup_font(settings.font);
		if custom_font_path.len == 0 {
			print_err("Custom font '%' not found. Default expected font file location"
				" is %. Note that the full path can be used too.",
				settings.font,
				FONT_DIRECTORY
			);
		} else {
			font_hash = std.str_hash(custom_font_path);
		}
	}

	assert(size >= MIN_FONT_SIZE && size <= MAX_FONT_SIZE);
	if (size == auto font.size) && (scaling_changed == false) && (current_font_hash == font_hash) {
		return OK;
	}

	print_log("Scale = %", WINDOW_SCALE);
	scaled_size :: cast(s32) std.round(WINDOW_SCALE * auto size);

	draw.font_terminate(&font);
	draw.font_terminate(&font_ui);
	draw.font_terminate(&font_ui_b);
	draw.font_terminate(&icons);

	char_set: [..]u32;
	defer array_terminate(&char_set);
	array_push_all(&char_set, draw.font_default_char_set());
	draw.font_generate_char_set("áčďéěíňóřšťúůýžÁČĎÉĚÍŇÓŘŠŤÚŮÝŽÄÖÜßäöü", &char_set);
	array_push(&char_set, 0x00A9);
	array_push(&char_set, 0x00AE);
	array_push(&char_set, 0x00A7);

	err: Error;

	// main font
	use_custom_font := custom_font_path.len > 0;
	if use_custom_font {
		print_log("Using custom font: %", custom_font_path);
		err = draw.font_init_at_size(&font, "", custom_font_path, scaled_size, char_set);
		if err {
			print_err(err);
			use_custom_font = false;
		} else {
			current_font_hash = font_hash;
		}
	}

	if !use_custom_font {
		err = draw.font_init_at_size_from_memory(&font, FONT_DATA, scaled_size, char_set);
		if err { panic(err); }
		current_font_hash = 0;
	}

	err = draw.font_init_at_size_from_memory(&font_ui, FONT_UI_DATA, scaled_size + 2);
	if err { panic(err); }

	err = draw.font_init_at_size_from_memory(&font_ui_b, FONT_UI_B_DATA, scaled_size + 2);
	if err { panic(err); }

	// Set tab size!
	font.tab_size = settings.tab_size;

	icon_set: [..]u32;
	defer array_terminate(&icon_set);

	draw.font_generate_char_set("X", &icon_set);
	// Use push all + array?
	array_push(&icon_set, ICON_BELL);
	array_push(&icon_set, ICON_FILE);
	array_push(&icon_set, ICON_CHANGES);
	array_push(&icon_set, ICON_FOLDER);
	array_push(&icon_set, ICON_DRIVE);
	array_push(&icon_set, ICON_COMMAND);
	array_push(&icon_set, ICON_PROJECT);
	array_push(&icon_set, ICON_READONLY);
	array_push(&icon_set, ICON_WARNING);
	array_push(&icon_set, ICON_ERROR);
	array_push(&icon_set, ICON_BUILD);
	array_push(&icon_set, ICON_MESSAGES);

	err = draw.font_init_at_size_from_memory(&icons, ICON_DATA, scaled_size, icon_set);
	if err { panic(err); }

	recalculate_metrics();
	return OK;
}

get_active_buffer_and_editor :: fn () (*Buffer, *Editor) #inline {
	editor :: &editors[active_editor];
	assert(editor.buffer_index != -1);
	buf :: &buffers[editor.buffer_index];
	assert(!buf.is_removed);

	return buf, editor;
}

get_last_active_buffer_and_editor :: fn () (*Buffer, *Editor) #inline {
	assert(last_active_text_editor != -1);
	editor :: &editors[last_active_text_editor];
	assert(editor.buffer_index != -1);
	buf :: &buffers[editor.buffer_index];
	assert(!buf.is_removed);

	return buf, editor;
}

set_mode :: fn (m: Mode) bool #inline {
	using Mode;
	if m == mode { return false; }

	notify_changes_to_buffer = -1;

	switch mode {
		GOTO_LINE;
		TEXT_EDIT         { last_active_text_editor = active_editor; }
		OPEN_FROM_DRIVE   { open_from_drive_mode_terminate();        }
		QUICK_OPEN        { quick_open_mode_terminate();             }
		SAVE_TO_DRIVE     { save_to_drive_mode_terminate();          }
		RUN_COMMAND       { run_command_mode_terminate();            }
		SEARCH_FILE       { search_mode_terminate();                 }
		OPEN_PROJECT      { open_project_mode_terminate();           }
		SEARCH_IN_PROJECT { search_in_project_mode_terminate();      }
		COMPLETION        { completion_mode_terminate();             }
		REPLACE           { replace_mode_terminate();                }

		default;
	}

	mode = m;

	if m != TEXT_EDIT {
		is_project_indexing_paused = true;
	} else {
	}

	switch m {
		TEXT_EDIT {
			assert(last_active_text_editor != -1);
			assert(last_active_text_editor != command_editor);
			active_editor = last_active_text_editor;
			input_mode = InputMode.TEXT;

			assert(active_editor >= 0 && active_editor < editors.len);
		}
		GOTO_LINE         { goto_mode_init();              }
		OPEN_FROM_DRIVE   { open_from_drive_mode_init();   }
		QUICK_OPEN        { quick_open_mode_init();        }
		SAVE_TO_DRIVE     { save_to_drive_mode_init();     }
		RUN_COMMAND       { run_command_mode_init();       }
		SEARCH_FILE       { search_mode_init();            }
		OPEN_PROJECT      { open_project_mode_init();      }
		SEARCH_IN_PROJECT { search_in_project_mode_init(); }
		COMPLETION        { completion_mode_init();        }
		REPLACE           { replace_mode_init();           }

		default;
	}

	// Note: The log here must be called after the actual mode is changed; in case we're in command-mode
	// and last focused buffer is message buffer, the log here cause text change notification in the command-mode
	// causing reset of the current list.
	print_log("Mode % set.", m);

	return true;
}

// Cancel the current mode (e.g. goto line) and switch the editor back to main text edit mode.
set_default_mode :: fn () #inline {
	set_mode(Mode.TEXT_EDIT);
}

get_command_editor_size :: fn () (w: f32, h: f32) #inline {
	using Metric;
	line_height  :: metrics[auto LINE_HEIGHT];
	text_padding :: metrics[auto TEXT_PADDING];
	return cast(f32) WINDOW_WIDTH, line_height + text_padding * 2.f;
}

last_message :: fn () (exists: bool, kind: PrintLogKind, text: string_view) {
	using std;
	mutex_lock(&message.mutex);
	defer mutex_unlock(&message.mutex);

	if message.text.len == 0 {
		return false, PrintLogKind.MESSAGE, "";
	}
	text_dup :: tprint(message.text);
	return true, message.kind, text_dup;
}

clear_message :: fn () {
	using std;
	mutex_lock(&message.mutex);
	defer mutex_unlock(&message.mutex);
	message.text.len = 0;
}

// Find any other editor open in the split.
find_next_in_the_split :: fn (split: Split) s32 {
	loop i := 0; i < editors.len; i += 1 {
		e :: &editors[i];
		if e.is_removed { continue; }
		if e.split == split { return e.index; }
	}
	return -1;
}

close_buffer :: fn (buffer_index: s32) {
	using Split;
	assert(buffer_index >= 0 && buffer_index < buffers.len);
	assert(!buffers[buffer_index].is_removed);

	loop i := 0; i < editors.len; i += 1 {
		e :: &editors[i];
		if e.is_removed { continue; }
		if e.buffer_index == buffer_index {
			remove_editor(e.index);
		}
	}

	if buffer_index == build.buffer_index {
		build.buffer_index = -1;
		// reset error list, we refer to the original buffer strings.
		clear_error_list();
	} else if buffer_index == help_buffer_index {
		help_buffer_index = -1;
	} else if buffer_index == search_buffer_index {
		search_buffer_index = -1;
	}

	// We should not remove buffer for messages.
	if buffer_index != messages_buffer_index {
		buf :: &buffers[buffer_index];
		if buf.lsp.version > 0 {
			lsp_close_document(buf);
		}
		remove_buffer(buffer_index);
	}

	activate_split: Split;
	if right != -1 && editors[right].is_removed {
		// We've closed buffer shown in the right split.
		if active_editor == right { activate_split = RIGHT; }
		right = find_next_in_the_split(Split.RIGHT);
	}

	assert(left != -1);
	if editors[left].is_removed {
		// We've closed buffer shown in the left split.
		if active_editor == left { activate_split = LEFT; }
		left = find_next_in_the_split(Split.LEFT);
	}

	// We should have one editor open at least...
	if left == -1 {
		left = find_or_create_editor_in_split(Split.LEFT, add_buffer());
		active_editor = left;
	}

	assert(left != -1);
	// Note that no editor might not be activated. (We're deleting buffer which is not in any active editor.)
	if activate_split == RIGHT {
		active_editor = right;
	} else if activate_split == LEFT {
		active_editor = left;
	}

	if active_editor == -1 {
		active_editor = left;
	}
	assert(active_editor != -1);
}

// Path must be normalized!
get_buffer_by_filepath :: fn (filepath: string_view) *Buffer {
	hash :: get_file_hash(filepath);

	// resolve buffer
	buffer_index := -1;
	loop i := 0; i < buffers.len; i += 1 {
		buf :: &buffers[i];
		if buf.is_removed { continue; }
		if buf.hash == hash {
			buffer_index = i;
			break;
		}
	}
	if buffer_index == -1 { return null; }
	return &buffers[buffer_index];
}

open :: fn (filepath: string_view, open_in_other_split := false) Error {
	using std;
	normalized_path := str_new(filepath, application_context.temporary_allocator);
	norm_err :: path_normalize(&normalized_path);
	if norm_err {
		return error("Invalid file path: '%'.", filepath);
	}
	buf := get_buffer_by_filepath(normalized_path);
	if !buf {
		buf = &buffers[add_buffer()];
		buf_error :: load_buffer_from_file(buf, normalized_path);
		if buf_error {
			return buf_error;
		}
		if is_lsp_running() && lsp_is_supported_document_type(buf) {
			lsp_open_document(buf);
		}
	}
	assert(buf);

	// resolve editor
	split: Split #noinit;
	if open_in_other_split {
		split = get_other_split();
	} else {
		split = get_active_split();
	}
	editor_index :: find_or_create_editor_in_split(split, buf.index);
	active_editor = editor_index;

	return OK;
}

save :: fn (buf: *Buffer, filepath: string_view) Error {
	assert(filepath.len > 0);

	hash :: get_file_hash(filepath);
	loop i := 0; i < buffers.len; i += 1 {
		b :: &buffers[i];
		if b.is_removed { continue; }
		if b.hash == hash {
			// We might have already open file with the same name, so we have to close it to
			// prevent creation of duplicit buffers.
			close_buffer(i);
			break;
		}
	}
	return save_buffer_to_file(buf, filepath);
}

// Open file in the buffer or switch to already existing one and move the cursor to line and col.
open_location :: fn (filepath: string_view, line: s32, col: s32, open_in_other_split := false) Error {
	err :: open(filepath, open_in_other_split);
	if err { return err; }

	target_buf, target_editor :: get_active_buffer_and_editor();

	goto_line(target_editor, target_buf, line);
	if col >= 0 {
		move_right_by_num_characters(target_editor, target_buf, col);
	} else {
		jump_line_end(target_editor, target_buf);
	}
	// center_view(target_editor);
	return OK;
}

open_project :: fn (directory: string_view, filepath: string_view) Error {
	kill_async_jobs();
	is_project_indexing_paused = false;

	err :: load_project(directory, filepath);
	if err { return err; }

	// Use the first path in the included directories as a working directory since it's supposed to be
	// a project root.
	if project.included_directories.len > 0 {
		std.set_cwd(project.included_directories[0]);
	}

	print_info("Project % loaded.", project.name);

	if settings.use_lsp {
		err :: start_lsp_server();
		if err { print_err(err); }
	}

	return OK;
}

get_active_split :: fn () Split #inline {
	using Split;
	if active_editor == -1 { return LEFT; }
	if left  == active_editor { return LEFT;  }
	if right == active_editor { return RIGHT; }
	assert(editors[active_editor].split == FLOATING);
	return FLOATING;
}

get_other_split :: fn () Split #inline {
	using Split;
	if get_active_split() == LEFT {
		return RIGHT;
	}
	return LEFT;
}

// Close the split and leaves the other always as the left one (if we close LEFT all editors
// from left are removed and RIGHT split is used as left one -> right one is left empty).
close_all_in_split :: fn (split: Split) {
	using Split;
	loop i := 0; i < editors.len; i += 1 {
		e :: &editors[i];
		if e.is_removed { continue; }
		if e.split == split {
			remove_editor(e.index);
		} else if e.split == RIGHT && split == LEFT {
			// If we're closing left split, we have to move all right editor to the left.
			e.split = LEFT;
		}
	}

	switch split {
		LEFT    { left  = right; right = -1; }
		RIGHT   { right = -1; }
		default { panic();    }
	}

	assert(left != -1);
	active_editor = left;
}

// Show given buffer in the split, in case any editor in the split already serves this buffer, it's activated;
// otherwise a new editor is created for the buffer. Returns index of used editor.
find_or_create_editor_in_split :: fn (split: Split, buffer_index: s32) s32 {
	assert(buffer_index != -1);

	editor_index : s32 = -1;

	// Lookup existing editor first.
	loop i := 0; i < editors.len; i += 1 {
		e :: &editors[i];
		if e.is_removed { continue; }
		if e.buffer_index == buffer_index && e.split == split {
			editor_index = e.index;
			break;
		}
	}

	if editor_index == -1 {
		editor_index = add_editor(buffer_index, true, split);
	}
	assert(editor_index > -1);

	using Split;
	switch split {
		LEFT    { left  = editor_index; }
		RIGHT   { right = editor_index; }
		default { panic();              }
	}

	active_editor = editor_index;
	return editor_index;
}

// Open or create editor for the buffer_index in the other split, in case the buffer_index is -1 new buffer
// with name buffer_name is created. Returns id of editor.
find_or_create_editor_with_buffer_in_other_split :: fn (buffer_index: *s32, buffer_name: string_view) s32 {
	buf, editor := get_active_buffer_and_editor();
	if buf.index != @buffer_index {
		if @buffer_index == -1 {
			@buffer_index = add_messages_buffer(buffer_name);
		}
		buf = &buffers[@buffer_index];
		return find_or_create_editor_in_split(get_other_split(), @buffer_index);
	}
	return editor.index;
}

// Activate existing editor it it's split.
activate_editor :: fn (editor_index: s32) (*Buffer, *Editor) {
	assert(editor_index >= 0 && editor_index < editors.len);
	editor :: &editors[editor_index];
	assert(!editor.is_removed);

	using Split;
	switch editor.split {
		LEFT    { left  = editor_index; }
		RIGHT   { right = editor_index; }
		default { panic(); }
	}
	active_editor = editor_index;
	return &buffers[editor.buffer_index], editor;
}

detect_filetype :: fn (filename: string_view) FileType {
	using FileType;
	using std;
	_, ext :: path_splitext(filename);
	extension :: str_new(ext, application_context.temporary_allocator);
	str_lower(&extension);

	if str_match_one_of(extension, [5]string_view.{ ".c", ".cpp", ".h", ".hpp", ".cc" }) {
		return C;
	}
	if str_match(extension, ".bl") {
		return BL;
	}
	if str_match(extension, ".proj") {
		return PROJ;
	}
	if str_match(extension, ".md") {
		return MD;
	}
	if str_match(extension, ".glsl") {
		return GLSL;
	}
	if str_match(extension, ".asm") {
		return ASM;
	}
	return FileType.UNKNOWN;
}

//
// Jobs
//

// @Cleanup: Move to separate file?

JobContext :: struct {
	state: enum { RUNNING; DONE; FAILED; KILLED; };
	kind: JobKind;
	name: string_view;

	pid: Pid;

	stdin:  IoStream;
	stdout: IoStream;

	pending:  [..]Request;
	complete: [..]Request;
	mutex:    std.Mutex;

	kill: bool;
	is_removed: bool;
}

Request :: struct {
	job_kind: JobKind;
	data: union {
		clang_format: struct {
			filepath:     string;
			src:          string;
			buffer_index: s32;
			buffer_hash:  u32;
		};
		build: struct {
			text: string;
		};
		lsp: struct {
			kind:           LspRequestKind;
			buffer_index:   s32;
			src:            string;
			filepath:       string;
			cursor:         Cursor;
			version:        s32;
			dia:        [..]ErrorLocation;
			strs:       [..]string; // @Incomplete: Use also for src and filepath
			flags:          LspRequestFlags;
		};
	}
}

JobKind :: enum {
	UNKNOWN;
	CLANG_FORMAT;
	BUILD;
	LSP;
}

Job :: std.Async2(JobContext, s32);
jobs: [..]Job;

jobs_init :: fn () {}

jobs_terminate :: fn () {
	using std;
	kill_async_jobs();
}

start_async_job :: fn (kind: JobKind, name: string_view, worker: *fn (ctx: *JobContext) s32) s32 {
	using std;

	ctx := JobContext.{
		state = JobContext.state.RUNNING,
		name  = name,
		kind  = kind,
	};
	mutex_init(&ctx.mutex);

	job: *Job;
	index := -1;
	loop i := 0; i < jobs.len; i += 1 {
		if jobs[i].worker_context.is_removed {
			job   = zeroinit(&jobs[i]);
			index = i;
		}
	}

	if !job {
		index = auto jobs.len;
		job   = zeroinit(array_push(&jobs));
	}
	async2(job, ctx, worker);
	assert(index >= 0);
	return index;
}

remove_async_job :: fn (index: s32) {
	using std;
	using JobContext.state;

	job :: &jobs[index];
	ctx :: &job.worker_context;

	assert(!ctx.is_removed);

	ctx.kill = true;
	async_wait(job);

	switch ctx.state {
		DONE   { print_info("Job '%' finished.", ctx.name); }
		KILLED { print_warn("Job '%' killed.", ctx.name); }
		FAILED;

		default { panic(); }
	}

	consume_job_results(job, true);

	if ctx.kind == JobKind.BUILD {
		build.job_index = -1;
	} else if ctx.kind == JobKind.LSP {
		remove_all_buffers_from_lsp();
		lsp.job_index = -1;
	}

	loop i := 0; i < ctx.pending.len; i += 1 {
		terminate_request(&ctx.pending[i]);
	}
	loop i := 0; i < ctx.complete.len; i += 1 {
		terminate_request(&ctx.complete[i]);
	}

	array_terminate(&ctx.pending);
	array_terminate(&ctx.complete);
	std.mutex_terminate(&ctx.mutex);

	ctx.is_removed = true;
}

kill_async_jobs :: fn () {
	using std;
	using JobContext.state;

	has_running_jobs := false;
	loop i := 0; i < jobs.len; i += 1 {
		job :: &jobs[i];
		if job.worker_context.is_removed { continue; }
		remove_async_job(i);
		has_running_jobs = true;
	}
	array_terminate(&jobs);
	zeroinit(&jobs);

	if !has_running_jobs {
		print_info("No asynchronous jobs are running.");
	}
}

consume_job_results :: fn (job: *Job, required := false) {
	using std;
	using JobContext.state;
	using JobKind;

	ctx :: &job.worker_context;
	assert(!ctx.is_removed);

	locked := false;
	if required {
		locked = true;
		mutex_lock(&ctx.mutex);
	} else {
		l, err :: mutex_try_lock(&ctx.mutex);
		if err {
			print_err(err);
		} else {
			locked = l;
		}
	}

	if locked {
		defer mutex_unlock(&ctx.mutex);

		result: Request #noinit;
		loop pop_result(ctx, &result) {
			assert(result.job_kind == ctx.kind);
			switch ctx.kind {
				CLANG_FORMAT { apply_format(ctx.state, &result);      }
				BUILD        { apply_build(ctx.state, &result);       }
				LSP          { apply_lsp_results(ctx.state, &result); }
				default { panic(); }
			}
			terminate_request(&result);
		}
	}
}

update_jobs :: fn () {
	using std;
	using JobContext.state;
	using JobKind;

	loop i := 0; i < jobs.len; i += 1 {
		job :: &jobs[i];
		ctx :: &job.worker_context;
		if ctx.is_removed { continue; }

		consume_job_results(job);

		if ctx.state != RUNNING {
			remove_async_job(i);
		}
	}
}

get_job_context :: fn (index: s32) *JobContext {
	assert(index >= 0 && index < jobs.len);
	return &jobs[index].worker_context;
}

push_request :: fn (ctx: *JobContext, request: *Request) {
	using std;
	assert(request.job_kind == ctx.kind);
	mutex_lock(&ctx.mutex);
	defer mutex_unlock(&ctx.mutex);
	r :: array_push(&ctx.pending);
	memcpy(auto r, auto request, sizeof(@request));
}

pop_request :: fn (ctx: *JobContext, request: *Request) bool {
	using std;
	mutex_lock(&ctx.mutex);
	defer mutex_unlock(&ctx.mutex);
	if array_pop_first(&ctx.pending, request) {
		assert(request.job_kind == ctx.kind);
		return true;
	}
	return false;
}

push_result :: fn (ctx: *JobContext, request: *Request) {
	using std;
	assert(request.job_kind == ctx.kind);
	mutex_lock(&ctx.mutex);
	defer mutex_unlock(&ctx.mutex);
	r :: array_push(&ctx.complete);
	memcpy(auto r, auto request, sizeof(@request));
}

// ctx.mutex should be locked before this is called
pop_result :: fn (ctx: *JobContext, request: *Request) bool {
	using std;
	if array_pop_first(&ctx.complete, request) {
		assert(request.job_kind == ctx.kind);
		return true;
	}
	return false;
}

terminate_request :: fn (request: *Request) {
	using std;
	using JobKind;
	switch request.job_kind {
		CLANG_FORMAT {
			str_delete(&request.data.clang_format.src);
			str_delete(&request.data.clang_format.filepath);
		}
		BUILD {
			str_delete(&request.data.build.text);
		}
		LSP {
			rd :: &request.data.lsp;
			str_delete(&rd.src);
			str_delete(&rd.filepath);
			array_terminate(&rd.dia);
			loop i := 0; i < rd.strs.len; i += 1 {
				str_delete(&rd.strs[i]);
			}
			array_terminate(&rd.strs);
			rd.kind = LspRequestKind.UNKNOWN;
		}
		default;
	}
}

check_main_thread :: fn (loc := #call_location) #enable_if IS_DEBUG {
	if MAIN_THREAD_ID != std.get_thread_id() {
		panic("Location: %:% is expected to be reached only from the main thread!", loc.file, loc.line);
	}
}

is_lmb_down :: fn () bool #inline {
	return is_flag(mouse.state, MouseState.LB_DOWN);
}

is_lmb_press :: fn () bool #inline {
	return is_flag(mouse.state, MouseState.LB_PRESS);
}

is_lmb_dbl_press :: fn () bool #inline {
	return is_flag(mouse.state, MouseState.LB_DBL_PRESS);
}

is_lmb_release :: fn () bool #inline {
	return is_flag(mouse.state, MouseState.LB_RELEASE);
}

is_lmb_dragging_start :: fn () bool #inline {
	return is_flag(mouse.state, MouseState.LB_DRAGGING_START);
}

is_lmb_dragging :: fn {
	fn  (elem_id: u32) bool #inline {
		return mouse.drag_target_elem_id == elem_id && is_flag(mouse.state, MouseState.LB_DRAGGING);
	};
	fn () bool #inline {
		return is_flag(mouse.state, MouseState.LB_DRAGGING);
	};
}

set_mouse_cursor :: fn (cursor := MouseCursor.DEFAULT) #inline {
	if mouse.current_cursor == cursor { return; }
	mouse.current_cursor = cursor;

	using MouseCursor;
	using glfw;
	switch cursor {
		DEFAULT { SetCursor(window, null);              }
		IBEAM   { SetCursor(window, mouse.beam_cursor); }
	}
}

caret: struct {
	visible:    bool;
	blink_t:    f32;
	no_binking: bool;
};

reset_caret_blinking :: fn () #inline {
	caret.blink_t    = 0.f;
	caret.visible    = true;
	caret.no_binking = false;
}

clipboard_read :: fn () string_view {
	return clipboard.get();

	// Seems to be laggy on Windows :/
	// cstr :: glfw.GetClipboardString(window);
	// if !cstr { return ""; }
	// return std.ctostr(auto cstr);
}

clipboard_write :: fn (str: string_view) {
	err :: clipboard.set(str);
	if err { print_err(err); }
	// using std;
	// if str.len == 0 { return; }
	// The input string might not be zero terminated.
	// dup :: str_new(str, application_context.temporary_allocator);
	// glfw.SetClipboardString(window, auto std.strtoc(dup));
}

#private

MAIN_THREAD_ID: u64;

message: Message;
debug_allocator: std.DebugAllocator;
ignore_char_input: bool;

// Might be changed when window is not focused.
low_power_mode: bool;

draw_frame :: fn () {
	using draw;

	clear_color(colors.foreground_color);

	{
		active_x: f32;
		x :: 0.f;
		y := 0.f;

		h := cast(f32) WINDOW_HEIGHT;
		w := cast(f32) WINDOW_WIDTH;

		// This is probably temporary solution fixing the issue when we cannot see the search hit
		// on the first line which is covered by the command buffer line.
		if active_editor == command_editor && (mode == Mode.SEARCH_FILE || mode == Mode.REPLACE) {
			_, ch :: get_command_editor_size();
			y += ch;
			h -= ch;
		}

		assert(left != -1);
		if right != -1 {
			gap :: 2.f;
			w = (0.5f * cast(f32) WINDOW_WIDTH) - gap * 0.5f;

			lx :: x;
			rx :: w + gap;

			draw_text_editor(left,  lx, y, w, h);
			draw_text_editor(right, rx, y, w, h);

			if active_editor == left {
				active_x = lx;
			} else if active_editor == right {
				active_x = rx;
			}
		} else {
			draw_text_editor(left, x, y, w, h);
		}

		using Mode;
		switch mode {
			TEXT_EDIT;
			GOTO_LINE         { draw_goto_mode();              }
			OPEN_FROM_DRIVE   { draw_open_from_drive_mode();   }
			QUICK_OPEN        { draw_quick_open_mode();        }
			SAVE_TO_DRIVE     { draw_save_to_drive_mode();     }
			RUN_COMMAND       { draw_run_command_mode();       }
			SEARCH_FILE       { draw_search_mode();            }
			OPEN_PROJECT      { draw_open_project_mode();      }
			SEARCH_IN_PROJECT { draw_search_in_project_mode(); }
			REPLACE           { draw_replace_mode();           }
			COMPLETION        {
				draw_completion_mode(active_x, y);
			}

			default;
		}
	}

	flush();
	glfw.SwapBuffers(window);
	temporary_reset();
}

print_glfw_error :: fn () {
	cstr: *u8;
	glfw.GetError(&cstr);

	if cstr == null { return; }
	tmp := string_view.{ auto C.strlen(auto cstr), auto cstr };
	print_err("GLFW Error: %", tmp);
}

key_callback :: fn (_: *glfw.Window, k: s32, _: s32, action: s32, mods: s32) {
	using glfw;

	reset_caret_blinking();
	if is_lmb_dragging() { return; }

	key := k;
	if key == KEY_KP_ENTER {
		key = KEY_ENTER;
	}

	if action == PRESS || action == REPEAT {
		ignore_char_input = ((mods & MOD_CONTROL) == MOD_CONTROL) || ((mods & MOD_ALT) == MOD_ALT);
		loop i := 0; i < key_binding.len; i += 1 {
			m :: &key_binding[i];
			if m.key == key && m.mods == mods {
				buf, editor :: get_active_buffer_and_editor();
				clear_message();
				error_marker_visible = false;
				invoke_command(editor, buf, m.cmd);

				break;
			}
		}
	}
}

character_callback :: fn (_: *glfw.Window, codepoint: u32) {
	if ignore_char_input { return; }
	reset_caret_blinking();

	if input_mode == InputMode.NUMBERS && ((codepoint < cast(u32) '0') || (codepoint > cast(u32) '9')) {
		return;
	}
	if is_lmb_dragging() { return; }

	clear_message();

	buf, editor :: get_active_buffer_and_editor();
	if maybe_report_readonly(buf) { return; }

	cut_selection(editor, buf, editor.index != command_editor);

	position := get_cursor_position(buf, editor.cursor_index);
	if has_indentation_info(buf) && is_row_empty(buf, position) {
		indent_range(buf, position, position);
	}

	position = get_cursor_position(buf, editor.cursor_index);
	inserted :: insert_unicode_character(buf, position, codepoint);

	if has_indentation_info(buf) && std.str_match(FILE_TYPE_REINDENT_ON[auto buf.file_type], inserted) {
		indent_range(buf, position, position);
	}

	set_prev_executed_command(Command.UNKNOWN);
}

mouse_button_callback :: fn (_: *glfw.Window, button: s32, action: s32, _: s32) {
	using glfw;
	using MouseState;
	switch button {
		MOUSE_BUTTON_LEFT {
			if action == PRESS {
				set_flag(&mouse.state, LB_PRESS);
				set_flag(&mouse.state, LB_DOWN);
				// detect double-click
				if GetTime() - mouse.prev_click_time_s < MOUSE_DBL_CLICK_S {
					set_flag(&mouse.state, LB_DBL_PRESS);
				}
				mouse.prev_click_time_s = GetTime();
			} else if action == RELEASE {
				set_flag(&mouse.state, LB_RELEASE);
				clr_flag(&mouse.state, LB_DOWN);
			}
		}
		default;
	}
	set_prev_executed_command(Command.UNKNOWN);
	if action == PRESS {
		clear_message();
	}
}

scroll_callback :: fn (_: *glfw.Window, _: f64, yoff: f64) {
	reset_caret_blinking();
	mouse.scroll += auto yoff;
	clear_message();
}

window_iconify_callback :: fn (_: *glfw.Window, iconified: s32) {
	low_power_mode = iconified != 0;
}

window_size_callback :: fn (_: *glfw.Window, _: s32, _: s32) {
	glfw.GetFramebufferSize(window, &WINDOW_WIDTH, &WINDOW_HEIGHT);
	draw.set_viewport_size(WINDOW_WIDTH, WINDOW_HEIGHT);

	// Hide any possible completion popup.
	if mode == Mode.COMPLETION { set_mode(Mode.TEXT_EDIT); }

	draw_frame();
}

window_scale_callback :: fn (_: *glfw.Window, xscale: f32, _: f32) {
	WINDOW_SCALE = xscale;
	scaling_changed = true;
	rebuild_fonts();
	draw_frame();
}

window_focus_callback :: fn (_: *glfw.Window, focused: s32) {
	if focused > 0 {
		reset_caret_blinking();
		low_power_mode = false;
	} else {
		caret.no_binking = true;
		low_power_mode   = true;
		print_log("Focus out!");
	}
}

drop_callback :: fn (_: *glfw.Window, count: s32, paths: **u8) {
	p :: []*u8.{ count, paths };
	loop i := 0; i < p.len; i += 1 {
		filepath :: std.ctostr(auto p[i]);
		buf_error :: open(filepath);
		if buf_error {
			print_err(buf_error);
		}
	}
}

recalculate_metrics :: fn () {
	using Metric;
	metrics[auto TITLE_BAR_HEIGHT] = font_ui.height  * 1.6f;
	metrics[auto LINE_HEIGHT     ] = font.height  * LINE_SPACING;
	metrics[auto ITEM_SPACING    ] = icons.height * 1.2f;
	metrics[auto TEXT_PADDING    ] = font.height  * 0.2f;
	metrics[auto TITLE_MAX_SIZE  ] = font.height  * 25.f;
	metrics[auto SHADOW_SIZE     ] = WINDOW_SCALE * 10.f;
	metrics[auto CORNER_ROUNDING ] = WINDOW_SCALE * 4.f;
}

file_to_stack :: fn (filepath: string_view) []u8 #comptime {
	using std;
	using StreamLocator;

	stream, open_err :: open_file(filepath);
	defer close_file(&stream);
	if open_err {
		panic(open_err);
	}
	size, seek_end_err :: seek(&stream, END);
	if seek_end_err { panic(seek_end_err); }

	_, seek_begin_err :: seek(&stream, BEGIN);
	if seek_begin_err { panic(seek_begin_err); }

	data, alloc_err :: new_slice(u8, size, true);
	if alloc_err { panic(alloc_err); }

	read_err :: read_all(&stream, data.ptr, data.len, 2048);
	if read_err { panic(read_err); }
	return data;
}

set_allocator_allocator :: fn (allocator: *Allocator) *Allocator {
	if !allocator { return null; }
	prev_allocator :: application_context.allocator;
	if prev_allocator == &debug_allocator {
		std.dump_memory_leaks(auto prev_allocator);
		std.debug_allocator_release(auto prev_allocator);
	}
	application_context.allocator = allocator;
	return prev_allocator;
}

set_logger :: fn (func: PrintLogFn) PrintLogFn {
	prev_func :: application_context.print_log_fn;
	application_context.print_log_fn = func;
	return prev_func;
}

// Use this to prevent recursive looping when log is reported while we report logs...
log_reported := false;

logger :: fn (kind: PrintLogKind, file: string_view #maybe_unused, line: s32 #maybe_unused, format: string_view, args: ...) {
	get_message_prefix :: fn (kind: PrintLogKind) string_view {
		using PrintLogKind;
		switch kind {
			WARNING { return "warning: "; }
			ERROR   { return "error: ";   }
			default;
		}
		return "";
	};

	// Prevent looping.
	if log_reported { return; }
	log_reported = true;

	defer fn () {
		log_reported = false;
	}();

	using std;
	using PrintLogKind;
	switch kind {
		INFO, WARNING, ERROR {
			mutex_lock(&message.mutex);
			defer mutex_unlock(&message.mutex);

			message.kind     = kind;
			message.text.len = 0;

			str_append(&message.text, tprint(format, args));
		}
		MESSAGE {
#if !IS_DEBUG { return; }
		}
		default;
	}

	switch kind {
		INFO, WARNING, ERROR, MESSAGE {
			index :: messages_buffer_index;
			if index >= 0 && index < buffers.len {
				buf :: &buffers[index];
				if !buf.is_removed {
					msg :: tprint(format, args);
					lock_buffer(buf);
					defer unlock_buffer(buf);
					append_readonly_buffer(buf, tprint("%%\n", get_message_prefix(kind), msg));
				}
			}
		}
		default;
	}

	// @Incomplete: We need concept of log file in case we're in release mode. On Windows we don't have
	// a console so there is no stdio initialized and we get the last error notification which is in
	// case of failiure invalid stream error.
	// We also might have some way how to show more than last one message to report all errors without
	// need of log file archeology.
	#if (IS_DEBUG && PLATFORM == Platform.WINDOWS) || PLATFORM != Platform.WINDOWS {
		__print_log_default(kind, file, line, format, args);
	}
}

set_icon :: fn () {
	using glfw;
	using draw;
	image: Image;
	bit_depth: u8;
	format: TextureFormat;
	err :: png_load_from_memory(APPLICATION_ICON_DATA, &image.pixels, auto &image.width, auto &image.height, &bit_depth, &format);
	defer free(image.pixels);
	if err { panic(err); }
	images :: [1]Image.{ image };
	SetWindowIcon(window, 1, images.ptr);
}

clear_mouse_events :: fn () {
	mouse.scroll = 0.f;
	using MouseState;
	clr_flag(&mouse.state, LB_PRESS);
	clr_flag(&mouse.state, LB_RELEASE);
	clr_flag(&mouse.state, LB_DRAGGING_START);
	clr_flag(&mouse.state, LB_DBL_PRESS);
}

update_mouse :: fn () {
	using glfw;
	using MouseState;

	mpx, mpy: f64;
	GetCursorPos(window, &mpx, &mpy);

	scale: f32;
	#if PLATFORM == Platform.DARWIN {
		GetWindowContentScale(window, &scale, null);
	} else {
		scale = 1.f;
	}

	mouse.px = (cast(f32) mpx) * scale;
	mouse.py = (cast(f32) mpy) * scale;
	mouse.last_hover_elem_id = mouse.hover_elem_id;
	mouse.hover_elem_id = 0;

	using glm;
	if is_lmb_press() {
		mouse.prev_mouse_pos = v2.{ mouse.px, mouse.py };
	}

	if is_lmb_down() && is_lmb_dragging() == false && distance(v2.{ mouse.px, mouse.py }, mouse.prev_mouse_pos) > MOUSE_DRAG_OFFSET {
		mouse.state |= LB_DRAGGING | LB_DRAGGING_START;
		mouse.drag_target_elem_id = mouse.last_hover_elem_id;
	}
	if is_lmb_release() {
		clr_flag(&mouse.state, LB_DRAGGING);
		mouse.drag_target_elem_id = 0;
	}
}

update_caret :: fn () {
	if caret.no_binking {
		caret.visible = true;
		return;
	}

	caret.blink_t += frame_delta_time;
	if caret.blink_t > CARET_BLINK_MS {
		caret.blink_t = 0.f;
		caret.visible = !caret.visible;
	}
}

/*
TODO

- sometimes crash on project reload!!! Maybe connected to LSP?
- mouse support
  - resize split
  - add scroll indicators for lister
  - select in buffer
	x double click select word
	- tripple click select line
  x current hover element recorder each frame
  x scroll buffers
  x set cursor position
  x switch active split
  x clicking in the lists
  x scroling in the lists


- find and replace in project
  - we want also unified undo
  - do as regular edit in results buffer?

- LSP for c++

  - handle fatal errors
  - complete on tab
  - cleanup completion flow
	- messy completions sometimes
	- completion does not work until we enter some text
	- popup can overflow to right from the window
  x LSP cannot goto definition in file paths containing spaces (win api functions).
  x goto definition
  x restart command
  x kill command
  x info in status bar (LSP (server name), warning and error count).
  x symbol suggestions
  x add opened files on server start! (remove buffer updates)
  x cleanup inline hints on server kill/crash
  x remove all tracked files on server kill (remove buffer updates...)
  x !!! goto declaration in other split !!!

- process
  - macos port
  - get status of the process (wait pid???)

- word wrap
  - rendering lines
  - rendering selection & highlights
  - cursor navigation and position
  - cursor mouse press position

- filewatch reload opened files
  - hot reload current or default project file
  - reload openned files outside of project
  - multithreaded features should reuse the same threads instead creating new ones everytime

- when replace is canceled, jump to the last replacement
x indentation + paste sometimes moves the cursor into weird locations
- syntax for batch
- draw module should prepare font glyphs into rectangle texture not into line...
- move line up and down
- dark/light colors switch
- not all commands needs to return value...
- add documentation into the global config file
- hide mouse cursor after some time without movement
- don't highlight entries under cursor until mouse was not moved to prevent confusion which item is selected.
- implement file sections distinguished by different background color?
- fullscreen mode (no window decorations)
- open project from command line
- command to close all buffers
- multi-cursor edit (oh shit!)
- make active buffer in split temporarily bigger
- propper error handling in release mode on windows
- log file
- multiple messages (notifications) UI
- shift+scroll to resize font.
- hot-reload non-project files
- hot-reload project configs
- add command to kill clang format
- Show whole diag message on cursor hover.
- Kill process seems to leave it running!
- focus into the build output only in case it failed compilation?
- Message should disapear after some time.
- Crash on project reload during indexing?
- Indexing too often?
- prefer previous buffer in the split on close current one
- undo of large file change should restore cursor positions?
- cut sometimes breaks new lines... (maybe breaks on paste when we have in clipboard different line endings?)
- highlight current word after timeout


x jump to previous and next cursor locations (even in files)
- pause indexing in sub-modes and during compilation? (Paused already during compilation.)
x change default font from settings
x remap keyboard
x cursor blinking
x clang-format
x stop cursor blinking when window is out of focus
x indentation on the last line in the file is broken when typing
x horizontal view switch if we go too far
x help + readme
x find and replace in file
x open file in a new split on the same position if it's already open in other split.
x merge quick-open and buffer-open
x Experiment with toggle ctrl?
x Warnings/errors should not cover document title bar.
x fix cursor position after indentation!!!
x autoindent when we insert indentation char
x virtual whitespace indentation for empty lines (finally not used)
x move up and down should try to respect indentation
  x make settings entry for this
x autoindent on paste when enabled
  x allow this for the whole inserted block of code (we cannot do it right now, because the indentation
	info is not recomputed right away after insertion, so in case the clipboard text contains some chars changing
	indentation the result is invalid)
x Reduce framerate after some period of idle time? (note we wait for events and also limit max frame rate on mac).
x Open file from the command line sometimes fails, also filepath is not normalized.
x recursive search might output results into separate buffer and allow user to switch quickly locations (alt+n/alt+p).
x markdown syntax
x make startup maximization optional
x messages clear command
x jump to previous position
x add str_match_ignore_case
x add command to kill current build
x error in project config has invalid line number...
x reduce override of the clipboard by stuff from command buffer
x last search should stay in search in files command
x switch cpp/h (covered by LSP)
x numpad enter should also work
x parse keys in settings
x set window minimal size
x horizontal view adjustements does not work in case the line is too long
x command to save all buffers
x option to save all buffers before compilation is invoked

*/

draw       :: #import "extra/draw";
glfw       :: #import "extra/glfw3";
math       :: #import "std/math";
io         :: #import "std/io";
C          :: #import "libc";
type_utils :: #import "std/type_utils";

#import "std/async"
#import "std/debug_allocator"
#import "std/fs"
#import "std/pool"
#import "std/string"
#import "std/print"
#import "std/array"
#import "std/table"
#import "std/thread"
#import "std/sync"
#import "extra/glm"
#import "extra/filewatch"
#import "pcre"

#load "buffer.bl"
#load "clang_format.bl"
#load "command_run.bl"
#load "commands.bl"
#load "completion.bl"
#load "editor.bl"
#load "goto.bl"
#load "list_functions.bl"
#load "listing.bl"
#load "lsp.bl"
#load "open_from_drive.bl"
#load "open_project.bl"
#load "peek_error.bl"
#load "project.bl"
#load "quick_open.bl"
#load "repeat.bl"
#load "replace.bl"
#load "save_to_drive.bl"
#load "search.bl"
#load "search_in_project.bl"
#load "shell.bl"
#load "shell_run.bl"
#load "utils.bl"
#load "window.bl"

LineEnding :: enum {
	UNKNOWN;
	CRLF;
	LF;
}

MOUSE_DRAG_OFFSET :: 4.f;
MOUSE_DBL_CLICK_S :: 0.5;

CODE_COLOR_DEFAULT_INDEX   : u8 : 0;
CODE_COLOR_CURSOR_INDEX    : u8 : 1;
CODE_COLOR_KEYWORD_INDEX   : u8 : 2;
CODE_COLOR_COMMENT_INDEX   : u8 : 3;
CODE_COLOR_DIRECTIVE_INDEX : u8 : 4;
CODE_COLOR_STRING_INDEX    : u8 : 5;
CODE_COLOR_INVALID_INDEX   : u8 : 6;
CODE_COLOR_NUMBER_INDEX    : u8 : 7;
CODE_COLOR_ERROR_INDEX     : u8 : 9;
CODE_COLOR_WARNING_INDEX   : u8 : 10;
CODE_COLOR_FUNCTION_INDEX  : u8 : 11;
ANSI_COLOR_BLACK_INDEX     : u8 : 12;
ANSI_COLOR_RED_INDEX       : u8 : 13;
ANSI_COLOR_GREEN_INDEX     : u8 : 14;
ANSI_COLOR_YELLOW_INDEX    : u8 : 15;
ANSI_COLOR_BLUE_INDEX      : u8 : 16;
ANSI_COLOR_MAGENTA_INDEX   : u8 : 17;
ANSI_COLOR_CYAN_INDEX      : u8 : 18;
ANSI_COLOR_WHITE_INDEX     : u8 : 19;

DEFAULT_FONT_SIZE              :: 20;
MAX_FONT_SIZE                  :: 64;
MIN_FONT_SIZE                  :: 4;
BOTTOM_SCROLL_TRIGGER          :: 5;

DEFAULT_CONFIG_FILE :: "default.proj";
PROJECTS_DIRECTORY  :: "projects";
FONT_DIRECTORY: string;

FONT_RESIZE_STEP :: 1;

CARET_BLINK_MS :: 500.f;

draw_next_frame := true;

// Limits
MAX_FILE_SYNTAX_HIGHLIGHT_BYTES :: 8388608; // 8MB
MAX_INDENTATION_RANGE_BYTES     :: 1048576; // 1MB

// Unicode awesome font codes.
ICON_BELL           : u32 : 0xF0A2;
ICON_FILE           : u32 : 0xF1C9;
ICON_CHANGES        : u32 : 0xF044;
ICON_FOLDER         : u32 : 0xF07B;
ICON_DRIVE          : u32 : 0xF0A0;
ICON_COMMAND        : u32 : 0x26A1;
ICON_PROJECT        : u32 : 0xF6D1;
ICON_READONLY       : u32 : 0xF023;
ICON_WARNING        : u32 : 0x26A0;
ICON_ERROR          : u32 : 0xF06A;
ICON_BL             : u32 : 0xF564;
ICON_CODE_FUNCTION  : u32 : 0x0046;
ICON_CODE_CLASS     : u32 : 0x0043;
ICON_CODE_INTERFACE : u32 : 0x0049;
ICON_CODE_TEXT      : u32 : 0xF080;
ICON_CODE_TYPE      : u32 : 0x0054;
ICON_CODE_VARIABLE  : u32 : 0x0056;
ICON_CODE_ENUM      : u32 : 0x0045;
ICON_CODE_MODULE    : u32 : 0xF1B2;
ICON_CIRCLE         : u32 : 0x25CF;

ICON_SHELL    : u32 : 0xF120;
ICON_MESSAGES : u32 : 0x2709;

// Static assets loaded directly into the executable data segment.
FONT                          :: "FiraCode-Regular.ttf";
// FONT                          :: "JetBrainsMono-Regular.ttf";
// FONT                          :: "GeistMono-Regular.ttf";
FONT_UI                       :: "SourceSans3-Regular.ttf";
FONT_UI_B                     :: "SourceSans3-Bold.ttf";

ICONS                         :: "fa-solid-900.ttf";
APP_FLIP_ICON                 :: "icon/icon_flip_256x256.png";
APP_ICON                      :: "icon/icon_256x256.png";
DEFAULT_PROJECT_FILE_TEMPLATE :: "default-config-file-template.proj";
HELP_FILE                     :: "README.md";

FONT_DATA                          :: file_to_stack(FONT);
FONT_UI_DATA                       :: file_to_stack(FONT_UI);
FONT_UI_B_DATA                     :: file_to_stack(FONT_UI_B);
ICON_DATA                          :: file_to_stack(ICONS);
DEFAULT_PROJECT_FILE_TEMPLATE_DATA :: file_to_stack(DEFAULT_PROJECT_FILE_TEMPLATE);
APP_FLIP_ICON_DATA                 :: file_to_stack(APP_FLIP_ICON);
APP_ICON_DATA                      :: file_to_stack(APP_ICON);
HELP_FILE_DATA                     :: file_to_stack(HELP_FILE);

MAX_VISIBLE_SEARCH_RESULTS_IN_EDITOR :: 1024;

PROJECT_IS_INDEXING_MESSAGE :: "Project indexing in progress, please wait.";

font:      draw.Font;
font_ui:   draw.Font;
font_ui_b: draw.Font;
icons:     draw.Font;

current_font_hash: u32;

buffers: [..]Buffer;
editors: [..]Editor;

file_watch: *FileWatch;

frame_delta_time: f32;

editor_start_time: s64;

active_editor  : s32 = -1;
command_editor : s32 = -1;

notify_changes_to_buffer: s32 = -1;

// Used for logs/errors/warnings etc.
messages_buffer_index := -1;
help_buffer_index     := -1;
search_buffer_index   := -1;

SearchLocation :: struct {
	start: s32;
	end:   s32;
	row:   s32;
	col:   s32;
}

search: struct {
	last_subject:     string;
	last_replacement: string;
	results:      [..]SearchLocation;
	result_index:     s64;
}

// Points to previous active text editor, this might be used in interactive modes where we need the text buffer
// as context (e.g. search mode).
last_active_text_editor : s32 = -1;

Split :: enum { FLOATING; LEFT; RIGHT; }

left:  s32 = -1;
right: s32 = -1;

Metric :: enum s64 {
	LINE_HEIGHT;
	TITLE_BAR_HEIGHT;
	ITEM_SPACING;
	TEXT_PADDING;
	TITLE_MAX_SIZE;
	SHADOW_SIZE;
	CORNER_ROUNDING;
}

metrics: [type_utils.enum_variant_count(Metric)]f32;

InputMode :: enum {
	TEXT;
	NUMBERS;
}

input_mode: InputMode;

Message :: struct {
	kind:  PrintLogKind;
	text:  string;

	mutex: Mutex;
}

Mode :: enum {
	TEXT_EDIT;
	GOTO_LINE;
	REPEAT;
	OPEN_FROM_DRIVE;
	QUICK_OPEN;
	SAVE_TO_DRIVE;
	RUN_COMMAND;
	SEARCH_FILE;
	OPEN_PROJECT;
	SEARCH_IN_PROJECT;
	COMPLETION;
	REPLACE;
	PEEK_ERROR;
	LIST_FUNCTIONS;
	SHELL_RUN;
}

mode: Mode;

FileType :: enum {
	UNKNOWN;
	BL;
	C;
	PROJ;
	MD;
	GLSL;
	ASM;
}

FILE_TYPE_NAME         :: [type_utils.enum_variant_count(FileType)]string_view.{ "Text", "BL", "C/C++", "Configuration", "Markdown", "GLSL", "ASM" };
FILE_TYPE_COMMENT_WITH :: [type_utils.enum_variant_count(FileType)]string_view.{ "",     "//", "//",    "#",             ""        , "//",   ";"   };
FILE_TYPE_REINDENT_ON  :: [type_utils.enum_variant_count(FileType)]string_view.{ "",     "}",  "}",     "",              ""        , "}",    ":"   };

// Related to align_assignments command. Each character is treated separately.
FILE_TYPE_ALIGN_ON     :: [type_utils.enum_variant_count(FileType)]string_view.{ "",     ":=", "=",     "",              ""        , "=",    ""    };

project: struct {
	name:       string_view;
	filepath:   string_view;
	is_default: bool;

	included_directories: [..]string_view;
	included_extensions:  [..]string_view;
	excluded_directories: [..]string_view;

	is_indexing:   bool;
	indexed_files: [..]string_view;

	mutex: Mutex;
	string_cache: PoolAllocator;

	file_link_regex: struct {
		expr:     Regex;
		is_valid: bool;
	};

	file_loc_regex: struct {
		expr:     Regex;
		is_valid: bool;
	};
}

// Global application settings loaded from the configuraiton file. These might be overriden by local project settings.
Settings :: struct {
	font_size:    s32;
	tab_size:     s32;
	line_spacing: s32;

	font: string;

	shell: string;

	build_command: string;

	clang_format_executable: string;
	clangd_executable:       string;
	clangd_args:             string;

	insert_spaces_instead_tabs:             bool;
	trim_trailing_whitespace_on_save:       bool;
	indent_on_paste:                        bool;
	indent_on_new_line:                     bool;
	vertical_move_tries_follow_indentation: bool;
	indent_on_tab:                          bool;
	use_lsp:                                bool;
	show_lsp_inline_diagnostics:            bool;
	block_caret:                            bool;
	word_wrap:                              bool;
	maximize_on_start:                      bool;
	save_all_before_build:                  bool;
	show_hints:                             bool;
	smooth_movement:                        bool;
	show_line_numbers:                      bool;
	line_numbers_relative:                  bool;

	shell_parse_error_locations:            bool;
	shell_enable_ansi_colors:               bool;
	shell_enable_error_location_colors:     bool;

	// Language support related things
	c_extensions:    string;
	bl_extensions:   string;
	glsl_extensions: string;
	asm_extensions:  string;

	// file location
	parse_file_links:    bool;
	file_link_regex:     string;
	file_location_regex: string;

	search_size_limit_bytes: s32;
};

settings: Settings;

Colors :: struct {
	background_color                    : v4;
	foreground_color                    : v4;
	cursor_background_color             : v4;
	cursor_foreground_color             : v4;
	current_line_background_color       : v4;
	search_result_background_color      : v4;
	title_bar_color                     : v4;
	title_bar_active                    : v4;
	title_bar_text_color                : v4;
	command_background_color            : v4;
	command_foreground_color            : v4;
	command_title_color                 : v4;
	command_select_color                : v4;
	command_list_background_color       : v4;
	modification_indicator_color        : v4;
	selection_background_color          : v4;
	selection_background_inactive_color : v4;
	message_color                       : v4;
	warning_color                       : v4;
	error_color                         : v4;
	inline_error_background_color       : v4;
	inline_warning_background_color     : v4;
	macro_record_icon_color             : v4;
	background_line_numbers_color       : v4;
	foreground_line_numbers_color       : v4;

	// code
	code_comment   : v4;
	code_keyword   : v4;
	code_directive : v4;
	code_string    : v4;
	code_number    : v4;
	code_invalid   : v4;
	code_error     : v4;
	code_warning   : v4;
	code_function  : v4;

	ansi_black   : v4;
	ansi_red     : v4;
	ansi_green   : v4;
	ansi_yellow  : v4;
	ansi_blue    : v4;
	ansi_magenta : v4;
	ansi_cyan    : v4;
	ansi_white   : v4;
}

colors:           Colors;
code_color_table: [20]v4;

//
// Build errors
//

ErrorLocation :: struct {
	kind: enum { ERROR; WARNING; };
	message:   string_view;
	file:      string_view;
	file_hash: u32;
	line_hash: u32;
	line:      s32;
	col:       s32;
	is_hidden: bool;
};

error_list:       [..]ErrorLocation;
error_list_index:     s64;
error_marker_visible: bool;

clear_error_list :: fn () {
	error_list.len   =  0;
	error_list_index = -1;
	error_marker_visible = false;

	if mode == Mode.PEEK_ERROR then set_mode(Mode.TEXT_EDIT);
}

// Compilation errors are in the list and shown only if the line with error is focused and not changed.
get_current_compilation_error :: fn () *ErrorLocation {
	if !error_marker_visible then return null;
	if error_list.len == 0 || error_list_index == -1 then return null;
	return &error_list[error_list_index];
}

//
// Shell links
//

FileLink :: struct {
	start: s64;
	end:   s64;

	filepath: string_view; // Valid until source buffer contains this string.
	ln:       s32;
	cl:       s32;
}

get_file_link_at_position :: fn (subject: string_view, position: s64) (FileLink, bool) {
	// measure_elapsed_ms_begin();
	// defer measure_elapsed_ms_end();

	if !settings.parse_file_links then return .{}, false;

	links :: parse_valid_clang_like_file_link(subject);
	loop i := 0; i < links.len; i += 1 {
		link :: &links[i];
		if link.start <= position && link.end > position {
			return links[i], true;
		}
	}

	return .{}, false;
}

//
// Recent locations
//

recent_locations: struct {
	stack: [..]s32;
	index:     s32;

	did_jump: bool;
};

add_recent_location :: fn (editor: *Editor) {
	assert(editor.track_recent_locations);
	rl :: &recent_locations;
	if rl.did_jump {
		rl.did_jump = false;
		return;
	}
	if rl.index >= 0 {
		if rl.stack[rl.index] == editor.index { return; }
		// Drop rest of the stack here.
		rl.stack.len = auto rl.index + 1;
	}
	array_push(&rl.stack, editor.index);
	rl.index = auto rl.stack.len-1;
}

erase_all_locations_for_editor :: fn (editor: *Editor) {
	// Erase also current editor index.
	assert(editor.track_recent_locations);
	rl  :: &recent_locations;
	loop i := 0; i < rl.stack.len; {
		editor_index :: rl.stack[i];
		if editor_index == editor.index {
			array_erase_keep_order(&rl.stack, i);
			if rl.index >= i { rl.index -= 1; }
			continue;
		}
		i += 1;
	}
}

jump_to_previous_location :: fn () bool {
	rl  :: &recent_locations;
	if rl.index < 1 { return false; }
	assert(active_editor != command_editor);

	rl.index -= 1;
	activate_editor(rl.stack[rl.index]);
	rl.did_jump = true;

	return true;
}

jump_to_next_location :: fn () bool {
	rl  :: &recent_locations;
	if rl.index+1 >= rl.stack.len { return false; }
	assert(active_editor != command_editor);

	rl.index += 1;
	activate_editor(rl.stack[rl.index]);
	rl.did_jump = true;

	return true;
}

//
// Macros
//

macros: struct {
	is_recording: bool;
	is_replaying: bool;
	queue: [..]Command;
	text:  [..]string;

	text_pool: PoolAllocator;
};

#scope_private
init_macros :: fn () {
	macros.text_pool = pool_make(null, 2048);
}

terminate_macros :: fn () {
	array_terminate(&macros.queue);
	array_terminate(&macros.text);

	release_allocator(&macros.text_pool);
}
#scope_public

add_macro_record :: fn {
	fn (command: Command) #inline {
		assert(macros.is_recording);
		array_push(&macros.queue, command);
	};

	fn (char: string_view) #inline {
		assert(macros.is_recording);
		array_push(&macros.queue, Command.UNKNOWN);
		array_push(&macros.text, str_make(char, &macros.text_pool));
	};
}

start_macro_recording :: fn () {
	if macros.is_recording then stop_macro_recording();
	macros.is_recording = true;
	macros.queue.len = 0;
	macros.text.len  = 0;
	toggle_binding :: get_keybinding_for_command(Command.TOGGLE_MACRO_RECORDING);
	reset_allocator(&macros.text_pool);

	print_info("Start recording macro. Use [%] to stop recording.", toggle_binding);
}

stop_macro_recording :: fn () {
	if !macros.is_recording then return;
	macros.is_recording = false;
	replay_binding :: get_keybinding_for_command(Command.REPLAY_MACRO);

	print_info("Stop recording macro. Use [%] to replay recording.", replay_binding);
}

replay_macro :: fn () {
	if macros.is_recording then stop_macro_recording();
	char_index := 0;
	macros.is_replaying = true;

	start_time := get_ticks();
	loop i := 0; i < macros.queue.len; i += 1 {
		if get_ticks() - start_time > 5. {
			print_warn("Execution took too long, stopping now.");
			break;
		}

		cmd :: macros.queue[i];
		if cmd == Command.UNKNOWN {
			handle_text_input(macros.text[char_index]);
			char_index += 1;
		} else {
			target_buf, target_editor :: get_active_buffer_and_editor();
			invoke_command(target_editor, target_buf, cmd);
		}
	}
	macros.is_replaying = false;

	loop i := 0; i < buffers.len; i += 1 {
		if buffers[i].is_removed then continue;
		commit_undo(&buffers[i]);
	}

	print_info("Replay macro.");
}

// Points to the directory containing editor executable (does not contain the last path separator).
exec_dir: string_view;

// Path where to store projects folder and default config, same as exec_dir on Windows.
data_dir: string;

main :: fn () s32 {
	// Setup debug allocator in DEBUG mode.
	prev_allocator: *Allocator;
#if IS_DEBUG {
	debug_allocator = debug_allocator_make(application_context.allocator);
	prev_allocator  = set_allocator_allocator(auto &debug_allocator);
}
	defer set_allocator_allocator(prev_allocator);
	defer temporary_release();

	// debug_allocator_break(&debug_allocator, 116);

	MAIN_THREAD_ID = get_thread_id();
	FONT_DIRECTORY = get_fonts_directory();
	defer str_terminate(&FONT_DIRECTORY);

	mutex_init(&message.mutex);
	defer mutex_terminate(&message.mutex);
	defer str_terminate(&message.text);

	// Recent location
	recent_locations.index = -1;
	defer array_terminate(&recent_locations.stack);

	// Create command editor.
	command_editor = add_editor(add_command_buffer());
	// Messages buffer
	messages_buffer_index = add_builtin_buffer("messages");

	default_logger :: set_logger(&logger);
	defer set_logger(default_logger);

	print_log("Font directory: '%'", FONT_DIRECTORY);

	editor_start_time = get_timestamp();
	print_log("Editor start time is %.", editor_start_time);


	// Resolve editor executable path.
	exec_path :: os_get_exec_path();
	defer str_terminate(&exec_path);

	head :: path_split(exec_path);
	exec_dir = head;
	if exec_dir.len > 0 && exec_dir[exec_dir.len-1] == '/' {
		exec_dir.len -= 1;
	}

	if exec_dir.len == 0 {
		print_warn("Unable to resolve the root directory of the editor executable.");
	} else {
		print_log("Editor executable directory: '%'", exec_dir);
	}

	#if PLATFORM == Platform.WINDOWS {
		data_dir = str_make(exec_dir);
	} else {
		data_dir = get_home();
		str_append(&data_dir, "/.tine");
		if !file_exist(data_dir) {
			err :: create_dir(data_dir);
			if err {
				panic(err);
			} else {
				print_log("Tine directory created at '%'.", data_dir);
			}
		}
	}

	defer str_terminate(&data_dir);

	print_log("Editor data directory: '%'", data_dir);

	#if PLATFORM == Platform.LINUX {
		make_desktop_entry_if_needed();
	}

	fw :: new_filewatch() catch panic($);
	file_watch = fw; // @Cleanup 2025-03-02
	defer delete_filewatch(file_watch);

	init_project();
	defer terminate_project();

	init_macros();
	defer terminate_macros();

	defer array_terminate(&key_binding);

	shell_run_mode_on_start();
	defer shell_run_mode_on_exit();

	init_window();
	defer terminate_window();

	draw.init(WINDOW_WIDTH, WINDOW_HEIGHT);
	defer draw.terminate();

	project_dir_path :: tprint("%/%", data_dir, PROJECTS_DIRECTORY);
	if !file_exist(project_dir_path) {
		err :: create_dir(project_dir_path);
		if err {
			print_err(err);
		} else {
			print_log("Projects directory created at '%'.", project_dir_path);
		}
	}

	// Initial readme file on the first start.
	show_help := false;

	// Check whether the default project file exists.
	if !is_default_project_present() {
		show_help = true;
		err :: setup_after_first_run();
		if err {
			print_err(err);
		} else {
			print_log("Default project file created.");
		}
	} else {
		// Try to load it, note that in case of fail, we use default setting implicitly (even if the file
		// content is invalid).
		err :: load_default_project_file();
		if err {
			print_err(err);
		} else {
			print_log("Default project file loaded from disk.");
		}
	}

	print_log("Settings: %", settings);


	rebuild_fonts();
	defer draw.font_terminate(&font);
	defer draw.font_terminate(&font_ui);
	defer draw.font_terminate(&font_ui_b);
	defer draw.font_terminate(&icons);

	listing_init();
	defer listing_terminate();

	// Initialize async job system.
	jobs_init();

	lsp_init();
	defer lsp_terminate();

	shell_init();
	defer shell_terminate();

	// Cleanup error list...
	defer array_terminate(&error_list);

	// Search stuff
	array_init(&search.results, 1024);

	defer str_terminate(&search.last_subject);
	defer str_terminate(&search.last_replacement);
	defer array_terminate(&search.results);

	loop i := 1; i < command_line_arguments.len; i += 1 {
		filepath :: command_line_arguments[i];
		buf_error :: open(filepath);
		if buf_error {
			print_err(buf_error);
		}
	}

	if active_editor == -1 {
		active_editor = add_editor(add_buffer(), true, Split.LEFT);
		left          = active_editor;
	}

	assert(left != -1);
	assert(active_editor != -1);

	prev_time := get_ticks();
	prev_frame_delta := -1.f #maybe_unused;

	if show_help then help();
	if settings.maximize_on_start then maximize_window();

	prev_active_editor := -1;
	last_focus_index := 0;

	current_window_title: string;
	defer str_terminate(&current_window_title);

	loop is_running() {
		current_time :: get_ticks();
		frame_delta_time = auto (current_time - prev_time) * 1000.;
		prev_time = current_time;

		recalculate_metrics();

		handle_window_event_loop();
		update_caret();

		if shell.job_index == -1 {
			removed_num  := 0;
			reloaded_num := 0;

			event: WatchEvent;
			loop poll_file_changes(file_watch, &event) {
				print_log("Event: %", event);

				using WatchEvent.kind;
				switch event.kind {
					FILE_CHANGED {
						buf :: get_buffer_by_filepath(event.path);
						assert(buf);
						if !buf then continue;
						buf.missing_on_disk = false;

						if event.timestamp == buf.last_write_time then continue;

						print_log("Reload '%' due to content changed on disk.", buf.filepath);
						load_buffer_from_file(buf, buf.filepath) catch {
							print_err($);
							continue;
						};

						reloaded_num += 1;
						print_info("Buffer '%' reloaded from disk.", buf.name);
					}

					FILE_REMOVED {
						buf :: get_buffer_by_filepath(event.path);
						assert(buf);
						if !buf then continue;
						buf.missing_on_disk = true;
						removed_num += 1;
						print_warn("File '%' not found on disk.", event.path);
					}

					DIR_CHANGED, DIR_REMOVED {
						reindex_project();
					}

					default;
				}
			}

			if removed_num > 1 {
				print_warn("Multiple opened files no longer exist on disk. Open messages for more info.");
			} else if reloaded_num > 1 {
				print_info("Multiple opened files reloaded from disk. Open messages for more info.");
			}
		}

		maybe_reindex_current_project();

		update_jobs(); // Also process all responses...

		buf, editor :: get_active_buffer_and_editor();
		if prev_active_editor != active_editor {
			prev_active_editor = active_editor;
			buf.last_focus_index = last_focus_index;
			last_focus_index += 1;

			if editor.track_recent_locations {
				add_recent_location(editor);
			}
		}

		if draw_next_frame {
			draw_next_frame = false;
			draw_frame();
		}

		title: string_view;
		if project.is_default {
			title = buf.name;
		} else {
			title = tprint("% - %", project.name, buf.name);
		}

		if !str_match(current_window_title, title) {
			current_window_title.len = 0;
			str_append(&current_window_title, title);
			set_window_title(current_window_title);
		}

		prev_frame_delta = frame_delta_time;
		temporary_reset();
	}

	// Terminate any possible active mode.
	set_mode(Mode.TEXT_EDIT);

	// Terminate all pending jobs. After that it's save to remove all buffers and editors.
	jobs_terminate();

	// To speed things up a bit.
	recent_locations.stack.len = 0;

	loop i := 0; i < editors.len; i += 1 { remove_editor(i); }
	loop i := 0; i < buffers.len; i += 1 { remove_buffer(i); }

	array_terminate(&editors);
	array_terminate(&buffers);

	info :: cast(*TypeInfoStruct) typeinfo(Settings);
	loop i := 0; i < info.members.len; i += 1 {
		member :: &info.members[i];
		if member.base_type == typeinfo(string) {
			str :: cast(*string) ptr_shift_bytes(&settings, member.offset_bytes);
			str_terminate(str);
		}
	}

	print_log("DONE.");
	return 0;
}

in_bounds :: fn (arr: []?T, v: s64) bool #inline {
	return v >= 0 && v < arr.len;
}

lookup_font :: fn (font_name: string_view) string_view {
	assert(font_name.len > 0);
	if file_exist(font_name) {
		return font_name;
	}
	if FONT_DIRECTORY.len == 0 { return ""; }
	tmp :: tprint("%/%", FONT_DIRECTORY, font_name);
	if file_exist(tmp) {
		return tmp;
	}
	return "";
}

rebuild_fonts :: fn (force := false) Error {
	size := settings.font_size;
	custom_font_path := "";
	font_hash: u32 = 0;

	if settings.font.len > 0 {
		custom_font_path = lookup_font(settings.font);
		if custom_font_path.len == 0 {
			print_err("Custom font '%' not found. Default expected font file location"
				" is %. Note that the full path can be used too.",
				settings.font,
				FONT_DIRECTORY
			);
		} else {
			font_hash = str_hash(custom_font_path);
		}
	}

	assert(size >= MIN_FONT_SIZE && size <= MAX_FONT_SIZE);
	if !force && (size == auto font.size) && (current_font_hash == font_hash) {
		return OK;
	}

	scaled_size :: cast(s32) math.round(WINDOW_SCALE * auto size);

	draw.font_terminate(&font);
	draw.font_terminate(&font_ui);
	draw.font_terminate(&font_ui_b);
	draw.font_terminate(&icons);

	char_set: [..]u32;
	defer array_terminate(&char_set);
	array_push_all(&char_set, draw.font_default_char_set());
	draw.font_generate_char_set("áčďéěíňóřšťúůýžÁČĎÉĚÍŇÓŘŠŤÚŮÝŽÄÖÜßäöü‘’┬┌│─├└┘┤┐┴┼", &char_set);
	array_push(&char_set, 0x00A9);
	array_push(&char_set, 0x00AE);
	array_push(&char_set, 0x00A7);

	err: Error;

	// main font
	use_custom_font := custom_font_path.len > 0;
	if use_custom_font {
		print_log("Using custom font: %", custom_font_path);
		err = draw.font_init_at_size(&font, "", custom_font_path, scaled_size, char_set);
		if err {
			print_err(err);
			use_custom_font = false;
		} else {
			current_font_hash = font_hash;
		}
	}

	if !use_custom_font {
		// Load defautl bundled font.
		draw.font_init_at_size_from_memory(&font, FONT_DATA, scaled_size, char_set) catch panic($);
		current_font_hash = 0;
	}

	err = draw.font_init_at_size_from_memory(&font_ui, FONT_UI_DATA, scaled_size + 2);
	if err { panic(err); }

	err = draw.font_init_at_size_from_memory(&font_ui_b, FONT_UI_B_DATA, scaled_size + 2);
	if err { panic(err); }

	// Set tab size!
	font.tab_size = settings.tab_size;

	icon_set: [..]u32;
	defer array_terminate(&icon_set);

	draw.font_generate_char_set("X", &icon_set);

	ICONS :: [_]u32.{
		ICON_BELL, ICON_FILE, ICON_CHANGES, ICON_FOLDER,
		ICON_DRIVE, ICON_COMMAND, ICON_PROJECT, ICON_READONLY,
		ICON_WARNING, ICON_ERROR, ICON_SHELL, ICON_MESSAGES,
		ICON_BL, ICON_CODE_FUNCTION, ICON_CODE_CLASS, ICON_CODE_INTERFACE,
		ICON_CODE_TEXT, ICON_CODE_TYPE, ICON_CODE_VARIABLE, ICON_CODE_ENUM,
		ICON_CODE_MODULE, ICON_CIRCLE,
	};

	array_push_all(&icon_set, ICONS);

	err = draw.font_init_at_size_from_memory(&icons, ICON_DATA, scaled_size, icon_set);
	if err { panic(err); }

	return OK;
}

get_active_buffer_and_editor :: fn () (*Buffer, *Editor) #inline {
	editor :: &editors[active_editor];
	assert(editor.buffer_index != -1);
	buf :: &buffers[editor.buffer_index];
	assert(!buf.is_removed);

	return buf, editor;
}

get_last_active_buffer_and_editor :: fn () (*Buffer, *Editor) #inline {
	assert(last_active_text_editor != -1);
	editor :: &editors[last_active_text_editor];
	assert(editor.buffer_index != -1);
	buf :: &buffers[editor.buffer_index];
	assert(!buf.is_removed);

	return buf, editor;
}

// Returns true in case the mode was changed.
set_mode :: fn (m: Mode) bool #inline {
	using Mode;
	if m == mode then return false;

	notify_changes_to_buffer = -1;

	switch mode {
		GOTO_LINE;
		TEXT_EDIT         { last_active_text_editor = active_editor; }
		OPEN_FROM_DRIVE   { open_from_drive_mode_terminate();        }
		QUICK_OPEN        { quick_open_mode_terminate();             }
		SAVE_TO_DRIVE     { save_to_drive_mode_terminate();          }
		RUN_COMMAND       { run_command_mode_terminate();            }
		SEARCH_FILE       { search_mode_terminate();                 }
		OPEN_PROJECT      { open_project_mode_terminate();           }
		SEARCH_IN_PROJECT { search_in_project_mode_terminate();      }
		COMPLETION        { completion_mode_terminate();             }
		REPLACE           { replace_mode_terminate();                }
		PEEK_ERROR        { peek_error_mode_terminate();             }
		LIST_FUNCTIONS    { list_functions_mode_terminate();         }
		SHELL_RUN         { shell_run_mode_terminate();              }

		default;
	}

	mode = m;

	switch m {
		TEXT_EDIT {
			assert(last_active_text_editor != -1);
			assert(last_active_text_editor != command_editor);
			active_editor = last_active_text_editor;
			input_mode = InputMode.TEXT;

			assert(active_editor >= 0 && active_editor < editors.len);
		}
		GOTO_LINE         { goto_mode_init();              }
		REPEAT            { repeat_mode_init();            }
		OPEN_FROM_DRIVE   { open_from_drive_mode_init();   }
		QUICK_OPEN        { quick_open_mode_init();        }
		SAVE_TO_DRIVE     { save_to_drive_mode_init();     }
		RUN_COMMAND       { run_command_mode_init();       }
		SEARCH_FILE       { search_mode_init();            }
		OPEN_PROJECT      { open_project_mode_init();      }
		SEARCH_IN_PROJECT { search_in_project_mode_init(); }
		COMPLETION        { completion_mode_init();        }
		REPLACE           { replace_mode_init();           }
		PEEK_ERROR        { peek_error_mode_init();        }
		LIST_FUNCTIONS    { list_functions_mode_init();    }
		SHELL_RUN         { shell_run_mode_init();         }

		default;
	}

	// Note: The log here must be called after the actual mode is changed; in case we're in command-mode
	// and last focused buffer is message buffer, the log here cause text change notification in the command-mode
	// causing reset of the current list.
	print_log("Mode % set.", m);

	return true;
}

// Cancel the current mode (e.g. goto line) and switch the editor back to main text edit mode.
set_default_mode :: fn () bool #inline {
	return set_mode(Mode.TEXT_EDIT);
}

get_command_editor_size :: fn () (w: f32, h: f32) #inline {
	using Metric;
	line_height  :: metrics[auto LINE_HEIGHT];
	text_padding :: metrics[auto TEXT_PADDING];
	return cast(f32) WINDOW_WIDTH, line_height + text_padding * 2.f;
}

last_message :: fn () (exists: bool, kind: PrintLogKind, text: string_view) {
	mutex_lock(&message.mutex);
	defer mutex_unlock(&message.mutex);

	if message.text.len == 0 {
		return false, PrintLogKind.MESSAGE, "";
	}
	text_dup :: tprint(message.text);
	return true, message.kind, text_dup;
}

clear_message :: fn () {
	mutex_lock(&message.mutex);
	defer mutex_unlock(&message.mutex);
	message.text.len = 0;
}

// Find any other editor open in the split.
find_next_in_the_split :: fn (split: Split) s32 {
	loop i := 0; i < editors.len; i += 1 {
		e :: &editors[i];
		if e.is_removed { continue; }
		if e.split == split { return e.index; }
	}
	return -1;
}

close_buffer :: fn (buffer_index: s32) {
	using Split;
	assert(buffer_index >= 0 && buffer_index < buffers.len);
	assert(!buffers[buffer_index].is_removed);

	loop i := 0; i < editors.len; i += 1 {
		e :: &editors[i];
		if e.is_removed { continue; }
		if e.buffer_index == buffer_index {
			remove_editor(e.index);
		}
	}

	if buffer_index == shell.buffer_index {
		shell.buffer_index = -1;
		// reset error list, we refer to the original buffer strings.
		clear_error_list();
	} else if buffer_index == help_buffer_index {
		help_buffer_index = -1;
	} else if buffer_index == search_buffer_index {
		search_buffer_index = -1;
	}

	// We should not remove buffer for messages.
	if buffer_index != messages_buffer_index {
		buf :: &buffers[buffer_index];
		if buf.lsp.version > 0 {
			lsp_close_document(buf);
		}
		remove_buffer(buffer_index);
	}

	activate_split: Split;
	if right != -1 && editors[right].is_removed {
		// We've closed buffer shown in the right split.
		if active_editor == right { activate_split = RIGHT; }
		right = find_next_in_the_split(Split.RIGHT);
	}

	assert(left != -1);
	if editors[left].is_removed {
		// We've closed buffer shown in the left split.
		if active_editor == left { activate_split = LEFT; }
		left = find_next_in_the_split(Split.LEFT);
	}

	// We should have one editor open at least...
	if left == -1 {
		left = find_or_create_editor_in_split(Split.LEFT, add_buffer());
		active_editor = left;
	}

	assert(left != -1);
	// Note that no editor might not be activated. (We're deleting buffer which is not in any active editor.)
	if activate_split == RIGHT {
		active_editor = right;
	} else if activate_split == LEFT {
		active_editor = left;
	}

	if active_editor == -1 {
		active_editor = left;
	}
	assert(active_editor != -1);
}

// Path must be normalized!
get_buffer_by_filepath :: fn (filepath: string_view) *Buffer {
	hash :: get_file_hash(filepath);

	// resolve buffer
	buffer_index := -1;
	loop i := 0; i < buffers.len; i += 1 {
		buf :: &buffers[i];
		if buf.is_removed { continue; }
		if buf.hash == hash {
			buffer_index = i;
			break;
		}
	}
	if buffer_index == -1 { return null; }
	return &buffers[buffer_index];
}

open :: fn (filepath: string_view, open_in_other_split := false) Error {
	normalized_path := str_make(filepath, application_context.temporary_allocator);
	norm_err :: path_normalize(&normalized_path);
	if norm_err {
		return error("Invalid file path: '%'.", filepath);
	}
	buf := get_buffer_by_filepath(normalized_path);
	if !buf {
		buf = &buffers[add_buffer()];
		buf_error :: load_buffer_from_file(buf, normalized_path);
		if buf_error {
			return buf_error;
		}
		if is_lsp_running() && lsp_is_supported_document_type(buf) {
			lsp_open_document(buf);
		}
	}
	assert(buf);

	// resolve editor
	split: Split #noinit;
	if open_in_other_split {
		split = get_other_split();
	} else {
		split = get_active_split();
	}
	editor_index :: find_or_create_editor_in_split(split, buf.index);
	active_editor = editor_index;

	return OK;
}

save :: fn (buf: *Buffer, filepath: string_view) Error {
	assert(filepath.len > 0);

	hash :: get_file_hash(filepath);
	loop i := 0; i < buffers.len; i += 1 {
		b :: &buffers[i];
		if b.is_removed { continue; }
		if b.hash == hash {
			// We might have already open file with the same name, so we have to close it to
			// prevent creation of duplicit buffers.
			close_buffer(i);
			break;
		}
	}
	return save_buffer_to_file(buf, filepath);
}

// Open file in the buffer or switch to already existing one and move the cursor to line and col.
open_location :: fn (filepath: string_view, line: s32, col: s32, open_in_other_split := false) Error {
	err :: open(filepath, open_in_other_split);
	if err { return err; }

	target_buf, target_editor :: get_active_buffer_and_editor();

	goto_line(target_editor, target_buf, line);
	if col >= 0 {
		move_right_by_num_characters(target_editor, target_buf, col);
	} else {
		jump_line_end(target_editor, target_buf);
	}
	// center_view(target_editor);
	return OK;
}

open_project :: fn (directory: string_view, filepath: string_view) Error {
	kill_async_jobs();

	err :: load_project(directory, filepath);
	if err { return err; }

	// Use the first path in the included directories as a working directory since it's supposed to be
	// a project root.
	if project.included_directories.len > 0 {
		set_cwd(project.included_directories[0]);
	}

	print_info("Project % loaded.", project.name);

	if settings.use_lsp {
		err :: start_lsp_server();
		if err { print_err(err); }
	}

	return OK;
}

get_active_split :: fn () Split #inline {
	using Split;
	if active_editor == -1 { return LEFT; }
	if left  == active_editor { return LEFT;  }
	if right == active_editor { return RIGHT; }
	assert(editors[active_editor].split == FLOATING);
	return FLOATING;
}

get_other_split :: fn () Split #inline {
	using Split;
	if get_active_split() == LEFT {
		return RIGHT;
	}
	return LEFT;
}

// Close the split and leaves the other always as the left one (if we close LEFT all editors
// from left are removed and RIGHT split is used as left one -> right one is left empty).
close_all_in_split :: fn (split: Split) {
	using Split;
	loop i := 0; i < editors.len; i += 1 {
		e :: &editors[i];
		if e.is_removed { continue; }
		if e.split == split {
			remove_editor(e.index);
		} else if e.split == RIGHT && split == LEFT {
			// If we're closing left split, we have to move all right editor to the left.
			e.split = LEFT;
		}
	}

	switch split {
		LEFT    { left  = right; right = -1; }
		RIGHT   { right = -1; }
		default { panic();    }
	}

	assert(left != -1);
	active_editor = left;
}

// Show given buffer in the split, in case any editor in the split already serves this buffer, it's activated;
// otherwise a new editor is created for the buffer. Returns index of used editor.
find_or_create_editor_in_split :: fn (split: Split, buffer_index: s32) s32 {
	assert(buffer_index != -1);

	editor_index : s32 = -1;

	// Lookup existing editor first.
	loop i := 0; i < editors.len; i += 1 {
		e :: &editors[i];
		if e.is_removed { continue; }
		if e.buffer_index == buffer_index && e.split == split {
			editor_index = e.index;
			break;
		}
	}

	if editor_index == -1 {
		editor_index = add_editor(buffer_index, true, split);
	}
	assert(editor_index > -1);

	using Split;
	switch split {
		LEFT    { left  = editor_index; }
		RIGHT   { right = editor_index; }
		default { panic();              }
	}

	active_editor = editor_index;
	return editor_index;
}

// Open or create editor for the buffer_index in the other split, in case the buffer_index is -1 new buffer
// with name buffer_name is created. Returns id of editor.
find_or_create_editor_with_buffer_in_other_split :: fn (buffer_index: *s32, buffer_name: string_view) s32 {
	buf, editor := get_active_buffer_and_editor();
	if buf.index != @buffer_index {
		if @buffer_index == -1 {
			@buffer_index = add_builtin_buffer(buffer_name, BufferFlags.PARSE_FILE_LINKS);
		}
		buf = &buffers[@buffer_index];
		return find_or_create_editor_in_split(get_other_split(), @buffer_index);
	}
	return editor.index;
}

// Activate existing editor it it's split.
activate_editor :: fn (editor_index: s32) (*Buffer, *Editor) {
	assert(editor_index >= 0 && editor_index < editors.len);
	editor :: &editors[editor_index];
	assert(!editor.is_removed);

	using Split;
	switch editor.split {
		LEFT    { left  = editor_index; }
		RIGHT   { right = editor_index; }
		default { panic(); }
	}
	active_editor = editor_index;
	return &buffers[editor.buffer_index], editor;
}

detect_filetype :: fn (filename: string_view) FileType {
	using FileType;
	_, ext :: path_splitext(filename);
	extension :: str_make(ext, application_context.temporary_allocator);
	str_lower(&extension);

	allocator :: application_context.temporary_allocator;

	if str_match_one_of(extension, str_split_by(settings.c_extensions, ' ', allocator)) {
		return C;
	}
	if str_match_one_of(extension, str_split_by(settings.bl_extensions, ' ', allocator)) {
		return BL;
	}
	if str_match(extension, ".proj") {
		return PROJ;
	}
	if str_match(extension, ".md") {
		return MD;
	}
	if str_match_one_of(extension, str_split_by(settings.glsl_extensions, ' ', allocator)) {
		return GLSL;
	}
	if str_match_one_of(extension, str_split_by(settings.asm_extensions, ' ', allocator)) {
		return ASM;
	}
	return FileType.UNKNOWN;
}

get_icon_for_file_type :: fn (file_type: FileType) string_view {
	using FileType;
	switch file_type {
		PROJ { return icon(ICON_PROJECT); }
		BL   { return icon(ICON_BL);      }
		default;
	}
	return icon(ICON_FILE);
}

//
// Jobs
//

JobContext :: struct {
	state: enum { RUNNING; DONE; FAILED; KILLED; };
	kind: JobKind;
	name: string_view;

	pid: Pid;

	// Extra shit needed only on Windows.
	win_job_handle:     *u8;
	win_process_handle: *u8;

	stdin:  IoStream;
	stdout: IoStream;

	pending:  [..]Request;
	complete: [..]Request;
	mutex:    Mutex;

	kill: bool;
	is_removed: bool;

	exit_code: s32;
}

Request :: struct {
	job_kind: JobKind;
	data: union {
		clang_format: struct {
			filepath:     string;
			src:          string;
			buffer_index: s32;
			buffer_hash:  u32;
		};
		build: struct {
			args:  string;
			text:  string;
		};
		lsp: struct {
			kind:           LspRequestKind;
			buffer_index:   s32;
			src:            string;
			filepath:       string;
			cursor:         Cursor;
			version:        s32;
			dia:        [..]ErrorLocation;
			strs:       [..]string; // @Incomplete: Use also for src and filepath
			ids:        [..]s32;
			flags:          LspRequestFlags;
		};
	}
}

JobKind :: enum {
	UNKNOWN;
	CLANG_FORMAT;
	SHELL;
	LSP;
}

Job :: Async2(JobContext, s32);
jobs: [..]Job;

jobs_init :: fn () {}

jobs_terminate :: fn () {
	kill_async_jobs();
}

start_async_job :: fn (kind: JobKind, name: string_view, worker: *fn (ctx: *JobContext) s32) s32 {
	ctx := JobContext.{
		state = JobContext.state.RUNNING,
		name  = name,
		kind  = kind,
	};
	mutex_init(&ctx.mutex, MutexKind.RECURSIVE);

	job: *Job;
	index := -1;
	loop i := 0; i < jobs.len; i += 1 {
		if jobs[i].worker_context.is_removed {
			job   = zeroinit(&jobs[i]);
			index = i;
		}
	}

	if !job {
		index = auto jobs.len;
		job   = zeroinit(array_push(&jobs));
	}

	async2(job, ctx, worker);

	assert(index >= 0);
	return index;
}

remove_async_job :: fn (index: s32) {
	using JobContext.state;

	job :: &jobs[index];
	ctx :: &job.worker_context;

	assert(!ctx.is_removed);

	ctx.kill = true;
	async_wait(job);

	switch ctx.state {
		DONE   { print_info("Job '%' finished.", ctx.name); }
		KILLED { print_warn("Job '%' killed.", ctx.name); }
		FAILED;

		default { panic(); }
	}

	consume_job_results(job, true);

	if ctx.kind == JobKind.SHELL {
		shell.job_index = -1;
	} else if ctx.kind == JobKind.LSP {
		remove_all_buffers_from_lsp();
		lsp.job_index = -1;
	}

	loop i := 0; i < ctx.pending.len; i += 1 {
		terminate_request(&ctx.pending[i]);
	}
	loop i := 0; i < ctx.complete.len; i += 1 {
		terminate_request(&ctx.complete[i]);
	}

	array_terminate(&ctx.pending);
	array_terminate(&ctx.complete);
	mutex_terminate(&ctx.mutex);

	ctx.is_removed = true;
}

kill_async_jobs :: fn () {
	using JobContext.state;

	has_running_jobs := false;
	loop i := 0; i < jobs.len; i += 1 {
		job :: &jobs[i];
		if job.worker_context.is_removed { continue; }
		remove_async_job(i);
		has_running_jobs = true;
	}
	array_terminate(&jobs);
	zeroinit(&jobs);

	if !has_running_jobs {
		print_info("No asynchronous jobs are running.");
	}
}

consume_job_results :: fn (job: *Job, required := false) {
	using JobContext.state;
	using JobKind;

	ctx :: &job.worker_context;
	assert(!ctx.is_removed);

	locked := false;
	if required {
		locked = true;
		mutex_lock(&ctx.mutex);
	} else {
		l, err :: mutex_try_lock(&ctx.mutex);
		if err then print_err(err) else locked = l;
	}

	if locked {
		defer mutex_unlock(&ctx.mutex);

		result: Request #noinit;
		loop pop_result(ctx, &result) {
			assert(result.job_kind == ctx.kind);
			switch ctx.kind {
				CLANG_FORMAT { apply_format(ctx.state, &result);      }
				SHELL        { apply_shell(ctx.state, &result);       }
				LSP          { apply_lsp_results(ctx.state, &result); }
				default { panic(); }
			}
			terminate_request(&result);
			redraw();
		}
	}
}

update_jobs :: fn () {
	using JobContext.state;
	using JobKind;

	loop i := 0; i < jobs.len; i += 1 {
		job :: &jobs[i];
		ctx :: &job.worker_context;
		if ctx.is_removed { continue; }

		consume_job_results(job);

		if ctx.state != RUNNING {
			remove_async_job(i);
		}
	}
}

get_job_context :: fn (index: s32) *JobContext #inline {
	assert(index >= 0 && index < jobs.len);
	return &jobs[index].worker_context;
}

push_request :: fn (ctx: *JobContext, request: *Request) {
	assert(request.job_kind == ctx.kind);
	mutex_lock(&ctx.mutex);
	defer mutex_unlock(&ctx.mutex);
	r :: array_push(&ctx.pending);
	memcpy(auto r, auto request, sizeof(@request));
}

pop_request :: fn (ctx: *JobContext, request: *Request) bool {
	mutex_lock(&ctx.mutex);
	defer mutex_unlock(&ctx.mutex);
	if array_pop_first(&ctx.pending, request) {
		assert(request.job_kind == ctx.kind);
		return true;
	}
	return false;
}

// Consume the 'request' data; meaning they are zero initialized in case the request is pushed
// this way we prevent possible double-free of request data strings.
push_result :: fn (ctx: *JobContext, request: *Request) {
	assert(request.job_kind == ctx.kind);
	mutex_lock(&ctx.mutex);
	defer mutex_unlock(&ctx.mutex);
	r :: array_push(&ctx.complete);
	memcpy(auto r, auto request, sizeof(@request));
	zeroinit(&request.data);
}

// ctx.mutex should be locked before this is called
pop_result :: fn (ctx: *JobContext, request: *Request) bool {
	if array_pop_first(&ctx.complete, request) {
		assert(request.job_kind == ctx.kind);
		return true;
	}
	return false;
}

terminate_request :: fn (request: *Request) {
	using JobKind;
	switch request.job_kind {
		CLANG_FORMAT {
			rd :: &request.data.clang_format;
			str_terminate(&rd.src);
			str_terminate(&rd.filepath);
		}
		SHELL {
			rd :: &request.data.build;
			str_terminate(&rd.args);
			str_terminate(&rd.text);
		}
		LSP {
			rd :: &request.data.lsp;
			str_terminate(&rd.src);
			str_terminate(&rd.filepath);
			array_terminate(&rd.dia);
			loop i := 0; i < rd.strs.len; i += 1 {
				str_terminate(&rd.strs[i]);
			}
			array_terminate(&rd.strs);
			array_terminate(&rd.ids);
			rd.kind = LspRequestKind.UNKNOWN;
		}
		default;
	}
}

check_main_thread :: fn (loc := #call_location) #enable_if IS_DEBUG {
	if MAIN_THREAD_ID != get_thread_id() {
		panic("Location: %:% is expected to be reached only from the main thread!", loc.file, loc.line);
	}
}

is_lmb_down :: fn () bool #inline {
	return is_flag(mouse.state, MouseState.LB_DOWN);
}

is_lmb_press :: fn () bool #inline {
	return is_flag(mouse.state, MouseState.LB_PRESS);
}

is_lmb_dbl_press :: fn () bool #inline {
	return is_flag(mouse.state, MouseState.LB_DBL_PRESS);
}

is_lmb_release :: fn () bool #inline {
	return is_flag(mouse.state, MouseState.LB_RELEASE);
}

is_lmb_dragging_start :: fn () bool #inline {
	return is_flag(mouse.state, MouseState.LB_DRAGGING_START);
}

is_lmb_dragging :: fn {
	fn  (elem_id: u32) bool #inline {
		return mouse.drag_target_elem_id == elem_id && is_flag(mouse.state, MouseState.LB_DRAGGING);
	};
	fn () bool #inline {
		return is_flag(mouse.state, MouseState.LB_DRAGGING);
	};
}

caret: struct {
	visible:    bool;
	blink_t:    f32;
};

reset_caret_blinking :: fn () #inline {
	caret.blink_t    = 0.f;
	caret.visible    = true;
}

TextLine :: struct {
	start_index: s32;
	len: s32;
}

calculate_line_offsets :: fn (text: string_view, fit_to_width: f32, font: *draw.Font) []TextLine {
	acc_width             := 0.f;
	last_whitespace_index := -1;
	last_whitespace_width := 0.f;
	start_index           := 0;

	lines: [..]TextLine;
	array_init(&lines, 32, application_context.temporary_allocator);

	loop index := 0; index < text.len; {
		if text[index] == ' ' || text[index] == '\t' {
			last_whitespace_index = index;
			last_whitespace_width = acc_width;
		} else if text[index] == '\n' {
			array_push(&lines, TextLine.{ start_index = start_index, len = index - start_index + 1 });
			start_index           = index + 1;
			acc_width             = 0.f;
			last_whitespace_index = -1;
			index += 1;
			continue;
		}

		char_len :: get_character_len(text[index]);

		w :: draw.text_size(string_view.{ char_len, &text[index] }, font, -1);
		acc_width += w;

		if acc_width < (fit_to_width/* * WINDOW_SCALE*/){
			index += char_len;
			continue;
		}

		if last_whitespace_index != -1 {
			len :: last_whitespace_index - start_index + 1;
			array_push(&lines, TextLine.{ start_index = start_index, len = len });
			start_index += len;
			acc_width   -= last_whitespace_width;
		} else {
			array_push(&lines, TextLine.{ start_index = start_index, len = index - start_index });
			start_index = index;
			acc_width   = 0.f;
		}
		last_whitespace_index = -1;
		index += char_len;
	}

	if start_index < text.len {
		array_push(&lines, TextLine.{ start_index = start_index, len = auto text.len - start_index });
	}

	if lines.len == 0 {
		array_push(&lines, TextLine.{});
	}
	return lines;
}

redraw :: fn () {
	if is_minimized() then return;
	draw_next_frame = true;
}

redraw_immediatelly :: fn () #maybe_unused {
	draw_frame();
}

#scope_private

MAIN_THREAD_ID: u64;

message: Message;
debug_allocator: DebugAllocator;

draw_frame :: fn () {
	using draw;

	begin_frame();
	defer end_frame();

	clear_color(colors.foreground_color);

	{
		active_x: f32;
		x :: 0.f;
		y := 0.f;

		h := cast(f32) WINDOW_HEIGHT;
		w := cast(f32) WINDOW_WIDTH;

		// This is probably temporary solution fixing the issue when we cannot see the search hit
		// on the first line which is covered by the command buffer line.
		if active_editor == command_editor && (mode == Mode.SEARCH_FILE || mode == Mode.REPLACE) {
			_, ch :: get_command_editor_size();
			y += ch;
			h -= ch;
		}

		assert(left != -1);
		if right != -1 {
			gap :: 2.f;
			w = (0.5f * cast(f32) WINDOW_WIDTH) - gap * 0.5f;

			lx :: x;
			rx :: w + gap;

			draw_text_editor(left,  lx, y, w, h);
			draw_text_editor(right, rx, y, w, h);

			if active_editor == left {
				active_x = lx;
			} else if active_editor == right {
				active_x = rx;
			}
		} else {
			draw_text_editor(left, x, y, w, h);
		}

		using Mode;
		switch mode {
			TEXT_EDIT;
			GOTO_LINE         { draw_goto_mode();              }
			REPEAT            { draw_repeat_mode();            }
			OPEN_FROM_DRIVE   { draw_open_from_drive_mode();   }
			QUICK_OPEN        { draw_quick_open_mode();        }
			SAVE_TO_DRIVE     { draw_save_to_drive_mode();     }
			RUN_COMMAND       { draw_run_command_mode();       }
			SEARCH_FILE       { draw_search_mode();            }
			OPEN_PROJECT      { draw_open_project_mode();      }
			SEARCH_IN_PROJECT { draw_search_in_project_mode(); }
			REPLACE           { draw_replace_mode();           }
			LIST_FUNCTIONS    { draw_list_functions_mode();    }
			SHELL_RUN         { draw_shell_run_mode();         }
			PEEK_ERROR        {
				draw_peek_error_mode(active_x, y, w);
			}
			COMPLETION        {
				draw_completion_mode(active_x, y);
			}

			default;
		}
	}

	flush();
}

recalculate_metrics :: fn () {
	using Metric;

	line_spacing :: math.min(math.max(0.8f, cast(f32)settings.line_spacing / 100.f), 2.f);

	metrics[auto TITLE_BAR_HEIGHT] = font_ui.height  * 1.6f;
	metrics[auto LINE_HEIGHT     ] = font.height  * line_spacing;
	metrics[auto ITEM_SPACING    ] = icons.height * 1.2f;
	metrics[auto TEXT_PADDING    ] = font.height  * 0.2f;
	metrics[auto TITLE_MAX_SIZE  ] = font.height  * 25.f;
	metrics[auto SHADOW_SIZE     ] = WINDOW_SCALE * 10.f;
	metrics[auto CORNER_ROUNDING ] = WINDOW_SCALE * 4.f;
}

file_to_stack :: fn (filepath: string_view) []u8 #comptime {
	using io.StreamLocator;

	stream, open_err :: open_file(filepath);
	defer close_file(&stream);
	if open_err {
		panic(open_err);
	}
	size, seek_end_err :: io.seek(&stream, END);
	if seek_end_err { panic(seek_end_err); }

	_, seek_begin_err :: io.seek(&stream, BEGIN);
	if seek_begin_err { panic(seek_begin_err); }

	data, alloc_err :: new_slice(u8, size, true);
	if alloc_err { panic(alloc_err); }

	read_err :: io.read_all(&stream, data.ptr, data.len, 2048);
	if read_err { panic(read_err); }
	return data;
}

set_allocator_allocator :: fn (allocator: *Allocator) *Allocator {
	if !allocator { return null; }
	prev_allocator :: application_context.allocator;
	if prev_allocator == &debug_allocator {
		if dump_memory_leaks(auto prev_allocator) > 0 {
			debugbreak;
		}
		debug_allocator_release(auto prev_allocator);
	}
	application_context.allocator = allocator;
	return prev_allocator;
}

set_logger :: fn (func: PrintLogFn) PrintLogFn {
	prev_func :: application_context.print_log_fn;
	application_context.print_log_fn = func;
	return prev_func;
}

// Use this to prevent recursive looping when log is reported while we report logs...
log_reported := false;

logger :: fn (kind: PrintLogKind, file: string_view #maybe_unused, line: s32 #maybe_unused, format: string_view, args: ...) {
	get_message_prefix :: fn (kind: PrintLogKind) string_view {
		using PrintLogKind;
		switch kind {
			WARNING { return "warning: "; }
			ERROR   { return "error: ";   }
			default;
		}
		return "";
	};

	// Prevent looping.
	if log_reported { return; }
	log_reported = true;

	defer fn () {
		log_reported = false;
	}();

	using PrintLogKind;
	switch kind {
		INFO, WARNING, ERROR {
			mutex_lock(&message.mutex);
			defer mutex_unlock(&message.mutex);

			message.kind     = kind;
			message.text.len = 0;

			str_append(&message.text, tprint(format, args));
		}
		MESSAGE {
			#if !IS_DEBUG { return; }
		}
		default;
	}

	switch kind {
		INFO, WARNING, ERROR, MESSAGE {
			index :: messages_buffer_index;
			if index >= 0 && index < buffers.len {
				buf :: &buffers[index];
				if !buf.is_removed {
					msg :: tprint(format, args);
					lock_buffer(buf);
					defer unlock_buffer(buf);
					append_readonly_buffer(buf, tprint("%%\n", get_message_prefix(kind), msg));
					set_all_cursors_position_to_buffer_end(buf);
				}
			}
		}
		default;
	}

	// @Incomplete: We need concept of log file in case we're in release mode. On Windows we don't have
	// a console so there is no stdio initialized and we get the last error notification which is in
	// case of failiure invalid stream error.
	// We also might have some way how to show more than last one message to report all errors without
	// need of log file archeology.
	#if (IS_DEBUG && PLATFORM == Platform.WINDOWS) || PLATFORM != Platform.WINDOWS {
		__print_log_default(kind, file, line, format, args);
	}
}

/*

*/

update_caret :: fn () {
	if !is_focused() {
		caret.visible = true;
		return;
	}

	caret.blink_t += frame_delta_time;
	if caret.blink_t > CARET_BLINK_MS {
		caret.blink_t = 0.f;
		caret.visible = !caret.visible;
		redraw();
	}
}

#import "extra/glfw3"
#import "extra/draw"
#import "std/debug_allocator"
#import "std/fs"
#import "std/pool"
#import "std/async"

#load "buffer.bl"
#load "commands.bl"
#load "editor.bl"
#load "goto.bl"
#load "listing.bl"
#load "open_from_drive.bl"
#load "quick_open.bl"
#load "save_to_drive.bl"
#load "command_run.bl"
#load "key_names.bl"
#load "search.bl"
#load "utils.bl"
#load "project.bl"
#load "open_project.bl"
#load "search_in_project.bl"
#load "clang_format.bl"
#load "builder.bl"
#load "lsp.bl"
#load "completion.bl"

#load "syntax/bl.bl"
#load "syntax/project.bl"
#load "syntax/cpp.bl"
#load "syntax/messages.bl"
#load "syntax/build.bl"
#load "syntax/md.bl"

LineEnding :: enum {
	UNKNOWN;
	CRLF;
	LF;
}

// @Incomplete: Set from settings?
WINDOW_WIDTH  := 800;
WINDOW_HEIGHT := 600;
WINDOW_TITLE  :: "Tine"; // This is not Emacs

WINDOW_SCALE: f32;
scaling_changed := false;

MOUSE_DRAG_OFFSET :: 4.f;
MOUSE_DBL_CLICK_S :: 0.5;

CODE_COLOR_DEFAULT_INDEX   : u8 : 0;
CODE_COLOR_CURSOR_INDEX    : u8 : 1;
CODE_COLOR_KEYWORD_INDEX   : u8 : 2;
CODE_COLOR_COMMENT_INDEX   : u8 : 3;
CODE_COLOR_DIRECTIVE_INDEX : u8 : 4;
CODE_COLOR_STRING_INDEX    : u8 : 5;
CODE_COLOR_INVALID_INDEX   : u8 : 6;
CODE_COLOR_NUMBER_INDEX    : u8 : 7;
CODE_COLOR_ERROR_INDEX     : u8 : 9;
CODE_COLOR_WARNING_INDEX   : u8 : 10;

DEFAULT_FONT_SIZE              :: 20;
MAX_FONT_SIZE                  :: 128;
MIN_FONT_SIZE                  :: 4;
LINE_SPACING                   :: 1.3f;
BOTTOM_SCROLL_TRIGGER          :: 5;

DEFAULT_CONFIG_FILE :: "default.proj";
PROJECTS_DIRECTORY  :: "projects";
BUILD_SCRIPT        :: "build.bat";
FONT_DIRECTORY: string;

FONT_RESIZE_STEP :: 1;

CARET_BLINK_MS :: 500.f;

// Unicode awesome font codes.
ICON_BELL        : u32 : 0xF0A2;
ICON_FILE        : u32 : 0xF1C9;
ICON_CHANGES     : u32 : 0xF044;
ICON_FOLDER      : u32 : 0xF07B;
ICON_DRIVE       : u32 : 0xF0A0;
ICON_COMMAND     : u32 : 0x26A1;
ICON_PROJECT     : u32 : 0xF6D1;
ICON_READONLY    : u32 : 0xF023;
ICON_WARNING     : u32 : 0x26A0;
ICON_ERROR       : u32 : 0xF06A;

ICON_BUILD    : u32 : 0xF6E3;
ICON_MESSAGES : u32 : 0x2709;

// Static assets loaded directly into the executable data segment.
FONT                          :: "JetBrainsMono-Regular.ttf";
FONT_UI                       :: "SourceSans3-Regular.ttf";
FONT_UI_B                     :: "SourceSans3-Bold.ttf";

ICONS                         :: "fa-solid-900.ttf";
APPLICATION_ICON              :: "icon/icon-flip.png";
DEFAULT_PROJECT_FILE_TEMPLATE :: "default-config-file-template.proj";
HELP_FILE                     :: "README.md";

FONT_DATA                          :: file_to_stack(FONT);
FONT_UI_DATA                       :: file_to_stack(FONT_UI);
FONT_UI_B_DATA                     :: file_to_stack(FONT_UI_B);
ICON_DATA                          :: file_to_stack(ICONS);
DEFAULT_PROJECT_FILE_TEMPLATE_DATA :: file_to_stack(DEFAULT_PROJECT_FILE_TEMPLATE);
APPLICATION_ICON_DATA              :: file_to_stack(APPLICATION_ICON);
HELP_FILE_DATA                     :: file_to_stack(HELP_FILE);

MAX_VISIBLE_SEARCH_RESULTS_IN_EDITOR :: 1024;

PROJECT_IS_INDEXING_MESSAGE :: "Project indexing in progress, please wait.";

window: *glfw.Window;

font:      draw.Font;
font_ui:   draw.Font;
font_ui_b: draw.Font;
icons:     draw.Font;

current_font_hash: u32;

buffers: [..]Buffer;
editors: [..]Editor;

frame_delta_time: f32;

editor_start_time: s64;

active_editor  : s32 = -1;
command_editor : s32 = -1;

// Used for logs/errors/warnings etc.
messages_buffer_index : s32 = -1;
help_buffer_index: s32 = -1;

last_search_subject: string;

// Points to previous active text editor, this might be used in interactive modes where we need the text buffer
// as context (e.g. search mode).
last_active_text_editor : s32 = -1;

Split :: enum { FLOATING; LEFT; RIGHT; }

left:  s32 = -1;
right: s32 = -1;

Metric :: enum s64 {
	LINE_HEIGHT;
	TITLE_BAR_HEIGHT;
	ITEM_SPACING;
	TEXT_PADDING;
	TITLE_MAX_SIZE;
	SHADOW_SIZE;
	CORNER_ROUNDING;
}

metrics: [enum_count(Metric)]f32;

InputMode :: enum {
	TEXT;
	NUMBERS;
}

input_mode: InputMode;

Message :: struct {
	using std;

	kind:  PrintLogKind;
	text:  string;

	mutex: Mutex;
}

Mode :: enum {
	TEXT_EDIT;
	GOTO_LINE;
	OPEN_FROM_DRIVE;
	QUICK_OPEN;
	SAVE_TO_DRIVE;
	RUN_COMMAND;
	SEARCH_FILE;
	OPEN_PROJECT;
	SEARCH_IN_PROJECT;
	COMPLETION;
}

mode: Mode;

FileType :: enum {
	UNKNOWN;
	BL;
	C;
	PROJ;
	MD;
}

FILE_TYPE_NAME ::         [enum_count(FileType)]string_view.{ "Text", "BL", "C/C++", "Configuration", "Markdown" };
FILE_TYPE_COMMENT_WITH :: [enum_count(FileType)]string_view.{ "",     "//", "//",    "#",             ""         };
FILE_TYPE_REINDENT_ON ::  [enum_count(FileType)]string_view.{ "",     "}",  "}",     "",              ""         };

project: struct {
	using std;

	name:       string_view;
	filepath:   string_view;
	is_default: bool;

	included_directories: [..]string_view;
	included_extensions:  [..]string_view;
	excluded_directories: [..]string_view;

	is_indexing:   bool;
	indexed_files: [..]string_view;

	mutex: Mutex;
	string_cache: std.PoolAllocator;
}

// Global application settings loaded from the configuraiton file. These might be overriden by local project settings.
Settings :: struct {
	font_size: s32;
	tab_size:  s32;

	font: string;

	insert_spaces_instead_tabs:             bool;
	trim_trailing_whitespace_on_save:       bool;
	indent_on_paste:                        bool;
	indent_on_new_line:                     bool;
	vertical_move_tries_follow_indentation: bool;
	indent_on_tab:                          bool;
	use_lsp:                                bool;
	show_lsp_inline_diagnostics:            bool;
	block_caret:                            bool;
	word_wrap:                              bool;
	maximize_on_start:                      bool;
};

settings: Settings;

Colors :: struct {
	using glm;

	background_color                    : v4;
	foreground_color                    : v4;
	cursor_background_color             : v4;
	cursor_foreground_color             : v4;
	current_line_background_color       : v4;
	search_result_background_color      : v4;
	title_bar_color                     : v4;
	title_bar_active                    : v4;
	title_bar_text_color                : v4;
	command_background_color            : v4;
	command_foreground_color            : v4;
	command_title_color                 : v4;
	command_select_color                : v4;
	command_list_background_color       : v4;
	modification_indicator_color        : v4;
	selection_background_color          : v4;
	selection_background_inactive_color : v4;
	message_color                       : v4;
	warning_color                       : v4;
	error_color                         : v4;
	inline_error_background_color       : v4;
	inline_warning_background_color     : v4;

	// code
	code_comment   : v4;
	code_keyword   : v4;
	code_directive : v4;
	code_string    : v4;
	code_number    : v4;
	code_invalid   : v4;
	code_error     : v4;
	code_warning   : v4;
}

colors:           Colors;
code_color_table: [11]glm.v4;

//
// Build errors
//

ErrorLocation :: struct {
	kind: enum { ERROR; WARNING; };
	message:   string_view;
	file:      string_view;
	file_hash: u32;
	line_hash: u32;
	line:      s32;
	col:       s32;
	is_hidden: bool;
};

error_list:       [..]ErrorLocation;
error_list_index:     s64;
error_marker_visible: bool;

clear_error_list :: fn () {
	error_list.len   =  0;
	error_list_index = -1;
	error_marker_visible = false;
}

// Points to the directory containing editor executable (does not contain the last path separator).
exec_dir: string_view;

// Path where to store projects folder and default config, same as exec_dir on Windows.
data_dir: string;

//
// Mouse
//

MouseState :: enum #flags {
    LB_PRESS;
    LB_DOWN;
    LB_RELEASE;
	LB_DBL_PRESS;
	LB_DRAGGING_START;
	LB_DRAGGING;
}

MouseCursor :: enum {
	DEFAULT;
	IBEAM;
}

mouse: struct {
	px:     f32;
	py:     f32;
	scroll: f32;

	last_hover_elem_id:  u32;
	hover_elem_id:       u32;
	drag_target_elem_id: u32;

	state: MouseState;

	current_cursor: MouseCursor;
	beam_cursor:   *glfw.Cursor;

	prev_mouse_pos: glm.v2;
	prev_click_time_s: f64;
};

// We can speed up rendering and disable low-power mode in case some animation is running. Next
// frame will not wait for inputs.
force_redraw := false;

main :: fn () s32 {
	using glfw;
	using std;

	// Setup debug allocator in DEBUG mode.
	prev_allocator: *Allocator;
#if IS_DEBUG {
	debug_allocator = debug_allocator_make(application_context.allocator);
	prev_allocator  = set_allocator_allocator(auto &debug_allocator);
}
	defer set_allocator_allocator(prev_allocator);
	defer temporary_release();

	//debug_allocator_break(&debug_allocator, 3);

	MAIN_THREAD_ID = get_thread_id();
	FONT_DIRECTORY = get_fonts_directory();
	defer str_delete(&FONT_DIRECTORY);

	print_log("Font directory: '%'", FONT_DIRECTORY);

	editor_start_time = get_timestamp();
	print_log("Editor start time is %.", editor_start_time);

	// Resolve editor executable path.
	exec_path :: os_get_exec_path();
	defer str_delete(&exec_path);

	head :: path_split(exec_path);
	exec_dir = head;
	if exec_dir.len > 0 && exec_dir[exec_dir.len-1] == '/' {
		exec_dir.len -= 1;
	}

	if exec_dir.len == 0 {
		print_warn("Unable to resolve the root directory of the editor executable.");
	} else {
		print_log("Editor executable directory: '%'", exec_dir);
	}

	#if PLATFORM == Platform.WINDOWS {
		data_dir = str_new(exec_dir);
	} else {
		data_dir = get_home();
		str_append(&data_dir, "/.tine");
		if !file_exist(data_dir) {
			err :: create_dir(data_dir);
			if err {
				panic(err);
			} else {
				print_log("Tine directory created at '%'.", data_dir);
			}
		}
	}

	defer str_delete(&data_dir);

	print_log("Editor data directory: '%'", data_dir);

	default_logger :: set_logger(&logger);
	defer set_logger(default_logger);

	mutex_init(&message.mutex);
	defer mutex_terminate(&message.mutex);
	defer str_delete(&message.text);

	// must be before project...
	watch_init();
	defer watch_terminate();

	init_project();
	defer terminate_project();

	defer array_terminate(&key_binding);

    // Initialize GLFW.
	if glfw.Init() == 0 {
		print_glfw_error();
		panic("Cannot initialize glfw.\n");
	}
	defer glfw.Terminate();

    // Create GLFW window.
	WindowHint(CONTEXT_VERSION_MAJOR, 3);
	WindowHint(CONTEXT_VERSION_MINOR, 3);
	WindowHint(OPENGL_FORWARD_COMPAT, 1);
	WindowHint(OPENGL_PROFILE, OPENGL_CORE_PROFILE);

	WindowHint(DOUBLEBUFFER, TRUE);
	WindowHint(RESIZABLE, TRUE);
	WindowHint(SAMPLES, 2);

	window = CreateWindow(WINDOW_WIDTH, WINDOW_HEIGHT, strtoc(WINDOW_TITLE), null, null);
	defer DestroyWindow(window);

	if !window {
		print_glfw_error();
		panic("Cannot create GLFW window.\n");
	}

	set_icon();

	SetWindowSizeLimits(window, 640, 480, DONT_CARE, DONT_CARE);
	GetFramebufferSize(window, &WINDOW_WIDTH, &WINDOW_HEIGHT);
	GetWindowContentScale(window, &WINDOW_SCALE, null);

	MakeContextCurrent(window);

	SetKeyCallback(window, &key_callback);
	SetCharCallback(window, &character_callback);
	SetWindowSizeCallback(window, &window_size_callback);
	SetWindowContentScaleCallback(window, &window_scale_callback);
	SetWindowIconifyCallback(window, &window_iconify_callback);
	SetWindowFocusCallback(window, &window_focus_callback);
	SetMouseButtonCallback(window, &mouse_button_callback);
	SetScrollCallback(window, &scroll_callback);
	SetDropCallback(window, &drop_callback);

	draw.init(WINDOW_WIDTH, WINDOW_HEIGHT);
	defer draw.terminate();

	project_dir_path :: tprint("%/%", data_dir, PROJECTS_DIRECTORY);
	if !file_exist(project_dir_path) {
		err :: create_dir(project_dir_path);
		if err {
			print_err(err);
		} else {
			print_log("Projects directory created at '%'.", project_dir_path);
		}
	}

	show_help := false;

	// Check whether the default project file exists.
	if !file_exist(tprint("%/%", data_dir, DEFAULT_CONFIG_FILE)) {
		load_default_project_from_template();
		show_help = true;

		err :: create_default_project_file(data_dir, DEFAULT_CONFIG_FILE);
		if err { print_err(err); }
		print_log("Default project file created since it was not found.");
	} else {
		// Try to load it, note that in case of fail, we use default setting implicitly (even if the file
		// content is invalid).
		err :: load_default_project_file();
		if err { print_err(err); }
		print_log("Default project file loaded from disk.");
	}

	defer str_delete(&settings.font);

	rebuild_fonts();
    defer draw.font_terminate(&font);
    defer draw.font_terminate(&font_ui);
    defer draw.font_terminate(&font_ui_b);
	defer draw.font_terminate(&icons);

	listing_init();
	defer listing_terminate();

	// Initialize async job system.
	jobs_init();

	lsp_init();
	defer lsp_terminate();

	build_init();

	defer str_delete(&last_search_subject);
	defer array_terminate(&error_list);

	// Create command editor.
	command_editor = add_editor(add_command_buffer());
	// Messages buffer
	messages_buffer_index = add_messages_buffer("messages");

	loop i := 1; i < command_line_arguments.len; i += 1 {
		filepath :: command_line_arguments[i];
		buf_error :: open(filepath);
		if buf_error {
			print_err(buf_error);
		}
	}

	if active_editor == -1 {
		active_editor  = add_editor(add_buffer(), Split.LEFT);
		left = active_editor;
	}

	assert(left != -1);
	assert(active_editor != -1);

	// cursors
	mouse.beam_cursor = CreateStandardCursor(IBEAM_CURSOR);
	defer DestroyCursor(mouse.beam_cursor);

	SwapInterval(1);
	prev_time := GetTime();
	prev_frame_delta := -1.f #maybe_unused;
	fps, fps_sum: f32 #maybe_unused;
	fps_num: s32 #maybe_unused;

	if show_help {
		help();
	}

	if settings.maximize_on_start {
		MaximizeWindow(window);
	}

    loop WindowShouldClose(window) == 0 {
		current_time :: glfw.GetTime();
		frame_delta_time = auto (current_time - prev_time) * 1000.;
		prev_time = current_time;

		#if PLATFORM == Platform.DARWIN {
			// Limit maximum FPS on mac since vsync seems not work.
			if prev_frame_delta <= 33.f && prev_frame_delta > 0.f {
				os_sleep_ms(cast(u32) (33.f - prev_frame_delta));
			}
		}

		wait_s := 0.100;
		if low_power_mode && force_redraw == false {
			wait_s = 1.0;
		} else if force_redraw {
			wait_s = 0.016;
		}
		force_redraw = false;

		WaitEventsTimeout(wait_s);

		update_mouse();
		update_caret();

		if build.job_index == -1 {
			// Disable indexing in case there is ongoing compilation (which might produce multiple file-change events).
			changed_directory: string_view;
			change_kind: WatchFor;
			loop next_watcher_event(&changed_directory, &change_kind) {
				if check_project_changes(changed_directory, change_kind) { continue; }
			}
		}

		maybe_reindex_current_project();
		update_jobs(); // Also process all responses...

		draw_frame();
		scaling_changed = false;

		buf :: get_active_buffer_and_editor() #maybe_unused;
		title: string_view;
		#if IS_DEBUG {
			fps_num += 1;
			fps_sum += 1000.f/frame_delta_time;
			if fps_num == 10 {
				fps = fps_sum / auto fps_num;
				fps_sum = 0.f;
				fps_num = 0;
			}
			title = tprint("FPS: %", fps);
			SetWindowTitle(window, auto std.strtoc(title));
		} else {
			if project.is_default {
				title = buf.name;
			} else {
				title = tprint("% - %", project.name, buf.name);
			}
			SetWindowTitle(window, auto std.strtoc(title));
		}
		clear_mouse_events();
		prev_frame_delta = frame_delta_time;
    }

	// Terminate any possible active mode.
	set_mode(Mode.TEXT_EDIT);

	// Terminate all pending jobs. After that it's save to remove all buffers and editors.
	jobs_terminate();

	loop i := 0; i < editors.len; i += 1 { remove_editor(i); }
	loop i := 0; i < buffers.len; i += 1 { remove_buffer(i); }

	array_terminate(&editors);
	array_terminate(&buffers);

	print_log("DONE.");
    return 0;
}

in_bounds :: fn (arr: []?T, v: s64) bool #inline {
	return v >= 0 && v < arr.len;
}

lookup_font :: fn (font_name: string_view) string_view {
	using std;
	assert(font_name.len > 0);
	if file_exist(font_name)) {
		return font_name;
	}
	if FONT_DIRECTORY.len == 0 { return ""; }
	tmp :: tprint("%/%", FONT_DIRECTORY, font_name);
	if file_exist(tmp)) {
		return tmp;
	}
	return "";
}

rebuild_fonts :: fn () Error {
	size := settings.font_size;
	custom_font_path := "";
	font_hash: u32 = 0;

	if settings.font.len > 0 {
		custom_font_path = lookup_font(settings.font);
		if custom_font_path.len == 0 {
			print_err("Custom font '%' not found. Default expected font file location"
			    " is %. Note that the full path can be used too.",
			    settings.font,
			    FONT_DIRECTORY
			);
		} else {
			font_hash = std.str_hash(custom_font_path);
		}
	}

	assert(size >= MIN_FONT_SIZE && size <= MAX_FONT_SIZE);
	if (size == auto font.size) && (scaling_changed == false) && (current_font_hash == font_hash) {
		return OK;
	}

	print_log("Scale = %", WINDOW_SCALE);
	scaled_size :: cast(s32) std.round(WINDOW_SCALE * auto size);

    draw.font_terminate(&font);
    draw.font_terminate(&font_ui);
    draw.font_terminate(&font_ui_b);
	draw.font_terminate(&icons);

	char_set: [..]u32;
	defer array_terminate(&char_set);
	array_push_all(&char_set, draw.font_default_char_set());
	draw.font_generate_char_set("áčďéěíňóřšťúůýžÁČĎÉĚÍŇÓŘŠŤÚŮÝŽÄÖÜßäöü", &char_set);
	array_push(&char_set, 0x00A9);
	array_push(&char_set, 0x00AE);
	array_push(&char_set, 0x00A7);

	err: Error;

	// main font
	use_custom_font := custom_font_path.len > 0;
	if use_custom_font {
		print_log("Using custom font: %", custom_font_path);
		err = draw.font_init_at_size(&font, "", custom_font_path, scaled_size, char_set);
		if err {
			print_err(err);
			use_custom_font = false;
		} else {
			current_font_hash = font_hash;
		}
	}

	if !use_custom_font {
		err = draw.font_init_at_size_from_memory(&font, FONT_DATA, scaled_size, char_set);
		if err { panic(err); }
		current_font_hash = 0;
	}

	err = draw.font_init_at_size_from_memory(&font_ui, FONT_UI_DATA, scaled_size + 2);
    if err { panic(err); }

	err = draw.font_init_at_size_from_memory(&font_ui_b, FONT_UI_B_DATA, scaled_size + 2);
    if err { panic(err); }

	// Set tab size!
	font.tab_size = settings.tab_size;

	icon_set: [..]u32;
	defer array_terminate(&icon_set);

	draw.font_generate_char_set("X", &icon_set);
	// Use push all + array?
	array_push(&icon_set, ICON_BELL);
	array_push(&icon_set, ICON_FILE);
	array_push(&icon_set, ICON_CHANGES);
	array_push(&icon_set, ICON_FOLDER);
	array_push(&icon_set, ICON_DRIVE);
	array_push(&icon_set, ICON_COMMAND);
	array_push(&icon_set, ICON_PROJECT);
	array_push(&icon_set, ICON_READONLY);
	array_push(&icon_set, ICON_WARNING);
	array_push(&icon_set, ICON_ERROR);
	array_push(&icon_set, ICON_BUILD);
	array_push(&icon_set, ICON_MESSAGES);

    err = draw.font_init_at_size_from_memory(&icons, ICON_DATA, scaled_size, icon_set);
    if err { panic(err); }

	recalculate_metrics();
	return OK;
}

get_active_buffer_and_editor :: fn () (*Buffer, *Editor) #inline {
	editor :: &editors[active_editor];
	assert(editor.buffer_index != -1);
	buf :: &buffers[editor.buffer_index];
	assert(!buf.is_removed);

	return buf, editor;
}

get_last_active_buffer_and_editor :: fn () (*Buffer, *Editor) #inline {
	assert(last_active_text_editor != -1);
	editor :: &editors[last_active_text_editor];
	assert(editor.buffer_index != -1);
	buf :: &buffers[editor.buffer_index];
	assert(!buf.is_removed);

	return buf, editor;
}

set_mode :: fn (m: Mode) bool #inline {
	using Mode;
	if m == mode { return false; }

	switch mode {
		GOTO_LINE;
		TEXT_EDIT         { last_active_text_editor = active_editor; }
		OPEN_FROM_DRIVE   { open_from_drive_mode_terminate();        }
		QUICK_OPEN        { quick_open_mode_terminate();             }
		SAVE_TO_DRIVE     { save_to_drive_mode_terminate();          }
		RUN_COMMAND       { run_command_mode_terminate();            }
		SEARCH_FILE       { search_mode_terminate();                 }
		OPEN_PROJECT      { open_project_mode_terminate();           }
		SEARCH_IN_PROJECT { search_in_project_mode_terminate();      }
		COMPLETION        { completion_mode_terminate();             }

		default;
	}

	switch m {
		TEXT_EDIT {
			assert(last_active_text_editor != -1);
			assert(last_active_text_editor != command_editor);
			active_editor = last_active_text_editor;
			input_mode = InputMode.TEXT;
		}
		GOTO_LINE         { goto_mode_init();              }
		OPEN_FROM_DRIVE   { open_from_drive_mode_init();   }
		QUICK_OPEN        { quick_open_mode_init();        }
		SAVE_TO_DRIVE     { save_to_drive_mode_init();     }
		RUN_COMMAND       { run_command_mode_init();       }
		SEARCH_FILE       { search_mode_init();            }
		OPEN_PROJECT      { open_project_mode_init();      }
		SEARCH_IN_PROJECT { search_in_project_mode_init(); }
		COMPLETION        { completion_mode_init();        }

		default;
	}

	print_log("Mode % set.", m);
	mode = m;

	return true;
}

// Cancel the current mode (e.g. goto line) and switch the editor back to main text edit mode.
set_default_mode :: fn () #inline {
	set_mode(Mode.TEXT_EDIT);
}

get_command_editor_size :: fn () (w: f32, h: f32) #inline {
	using Metric;
	line_height  :: metrics[auto LINE_HEIGHT];
	text_padding :: metrics[auto TEXT_PADDING];
	return cast(f32) WINDOW_WIDTH, line_height + text_padding * 2.f;
}

last_message :: fn () (exists: bool, kind: PrintLogKind, text: string_view) {
	using std;
	mutex_lock(&message.mutex);
	defer mutex_unlock(&message.mutex);

	if message.text.len == 0 {
		return false, PrintLogKind.MESSAGE, "";
	}
	text_dup :: tprint(message.text);
	return true, message.kind, text_dup;
}

clear_message :: fn () {
	using std;
	mutex_lock(&message.mutex);
	defer mutex_unlock(&message.mutex);
	message.text.len = 0;
}

duplicate_editor :: fn (editor_index: s64) s64 {
	assert(editor_index != -1);
	return add_editor(editors[editor_index].buffer_index);
}

// Find any other editor open in the split.
find_next_in_the_split :: fn (split: Split) s32 {
	loop i := 0; i < editors.len; i += 1 {
		e :: &editors[i];
		if e.is_removed { continue; }
		if e.split == split { return e.index; }
	}
	return -1;
}

close_buffer :: fn (buffer_index: s32) {
	using Split;
	assert(buffer_index >= 0 && buffer_index < buffers.len);
	assert(!buffers[buffer_index].is_removed);

	loop i := 0; i < editors.len; i += 1 {
		e :: &editors[i];
		if e.is_removed { continue; }
		if e.buffer_index == buffer_index {
			remove_editor(e.index);
		}
	}

	if buffer_index == build.buffer_index {
		build.buffer_index = -1;
		// reset error list, we refer to the original buffer strings.
		clear_error_list();
	} else if buffer_index == help_buffer_index {
		help_buffer_index = -1;
	}

	// We should not remove buffer for messages.
	if buffer_index != messages_buffer_index {
		buf :: &buffers[buffer_index];
		if buf.lsp.version > 0 {
			lsp_close_document(buf);
		}
		remove_buffer(buffer_index);
	}

	activate_split: Split;
	if right != -1 && editors[right].is_removed {
		// We've closed buffer shown in the right split.
		if active_editor == right { activate_split = RIGHT; }
		right = find_next_in_the_split(Split.RIGHT);
	}

	assert(left != -1);
	if editors[left].is_removed {
		// We've closed buffer shown in the left split.
		if active_editor == left { activate_split = LEFT; }
		left = find_next_in_the_split(Split.LEFT);
	}

	// We should have one editor open at least...
	if left == -1 {
		left = find_or_create_editor_in_split(Split.LEFT, add_buffer());
		active_editor = left;
	}

	assert(left != -1);
	// Note that no editor might not be activated. (We're deleting buffer which is not in any active editor.)
	if activate_split == RIGHT {
		active_editor = right;
	} else if activate_split == LEFT {
		active_editor = left;
	}

	if active_editor == -1 {
		active_editor = left;
	}
	assert(active_editor != -1);
}

// Path must be normalized!
get_buffer_by_filepath :: fn (filepath: string_view) *Buffer {
	hash :: get_file_hash(filepath);

	// resolve buffer
	buffer_index := -1;
	loop i := 0; i < buffers.len; i += 1 {
		buf :: &buffers[i];
		if buf.is_removed { continue; }
		if buf.hash == hash {
			buffer_index = i;
			break;
		}
	}
	if buffer_index == -1 { return null; }
	return &buffers[buffer_index];
}

open :: fn (filepath: string_view, normalized := false) Error {
	using std;
	normalized_path := str_new(filepath, application_context.temporary_allocator);
	if !normalized {
		path_normalize(&normalized_path);
	} else {
		str_replace_all(&normalized_path, '\\', '/');
	}

	buf := get_buffer_by_filepath(normalized_path);
	if !buf {
		buf = &buffers[add_buffer()];
		buf_error :: load_buffer_from_file(buf, normalized_path);
		if buf_error {
			print_err(buf_error);
		}
		if is_lsp_running() && lsp_is_supported_document_type(buf) {
			lsp_open_document(buf);
		}
	}
	assert(buf);

	// resolve editor
	editor_index :: find_or_create_editor_in_split(get_active_split(), buf.index);
	active_editor = editor_index;

	return OK;
}

save :: fn (buf: *Buffer, filepath: string_view) Error {
	assert(filepath.len > 0);

	hash :: get_file_hash(filepath);
	loop i := 0; i < buffers.len; i += 1 {
		b :: &buffers[i];
		if b.is_removed { continue; }
		if b.hash == hash {
			// We might have already open file with the same name, so we have to close it to
			// prevent creation of duplicit buffers.
			close_buffer(i);
			break;
		}
	}
	return save_buffer_to_file(buf, filepath);
}

// Open file in the buffer or switch to already existing one and move the cursor to line and col.
open_location :: fn (filepath: string_view, line: s32, col: s32) Error {
	err :: open(filepath, true);
	if err { return err; }

	target_buf, target_editor :: get_active_buffer_and_editor();
	goto_line(target_editor, target_buf, line);
	if col >= 0 {
		move_right_by_num_characters(target_editor, target_buf, col);
	} else {
		jump_line_end(target_editor, target_buf);
	}
	center_view(target_editor);

	return OK;
}

open_project :: fn (directory: string_view, filepath: string_view) Error {
	kill_async_jobs();

	err_default :: load_default_project_file();
	if err_default { return err_default; }

	err_desired :: load_project_file(directory, filepath);
	if err_desired { return err_desired; }

	// Use the first path in the included directories as a working directory since it's supposed to be
	// a project root.
	if project.included_directories.len > 0 {
		std.set_cwd(project.included_directories[0]);
	}

	print_info("Project % loaded.", project.name);

	if settings.use_lsp {
		err :: start_lsp_server();
		if err { print_err(err); }
	}

	return OK;
}

get_active_split :: fn () Split #inline {
	using Split;
	if active_editor == -1 { return LEFT; }
	if left  == active_editor { return LEFT;  }
	if right == active_editor { return RIGHT; }
	assert(editors[active_editor].split == FLOATING);
	return FLOATING;
}

// Close the split and leaves the other always as the left one (if we close LEFT all editors
// from left are removed and RIGHT split is used as left one -> right one is left empty).
close_all_in_split :: fn (split: Split) {
	using Split;
	loop i := 0; i < editors.len; i += 1 {
		e :: &editors[i];
		if e.is_removed { continue; }
		if e.split == split {
			remove_editor(e.index);
		} else if e.split == RIGHT && split == LEFT {
			// If we're closing left split, we have to move all right editor to the left.
			e.split = LEFT;
		}
	}

	switch split {
		LEFT    { left  = right; right = -1; }
		RIGHT   { right = -1; }
		default { panic();    }
	}

	assert(left != -1);
	active_editor = left;
}

// Show given buffer in the split, in case any editor in the split already serves this buffer, it's activated;
// otherwise a new editor is created for the buffer. Returns index of used editor.
find_or_create_editor_in_split :: fn (split: Split, buffer_index: s32) s32 {
	assert(buffer_index != -1);

	editor_index : s32 = -1;

	// Lookup existing editor first.
	loop i := 0; i < editors.len; i += 1 {
		e :: &editors[i];
		if e.is_removed { continue; }
		if e.buffer_index == buffer_index && e.split == split {
			editor_index = e.index;
			break;
		}
	}

	if editor_index == -1 {
		editor_index = add_editor(buffer_index, split);
	}
	assert(editor_index > -1);

	using Split;
	switch split {
		LEFT    { left  = editor_index; }
		RIGHT   { right = editor_index; }
		default { panic();              }
	}

	active_editor = editor_index;
	return editor_index;
}

detect_filetype :: fn (filename: string_view) FileType {
	using FileType;
	using std;
	_, ext :: path_splitext(filename);
	extension :: str_new(ext, application_context.temporary_allocator);
	str_lower(&extension);

	if str_match_one_of(extension, [5]string_view.{ ".c", ".cpp", ".h", ".hpp", ".cc" }) {
		return C;
	}
	if str_match(extension, ".bl") {
		return BL;
	}
	if str_match(extension, ".proj") {
		return PROJ;
	}
	if str_match(extension, ".md") {
		return MD;
	}
	return FileType.UNKNOWN;
}

//
// Jobs
//

// @Cleanup: Move to separate file?

JobContext :: struct {
	state: enum { RUNNING; DONE; FAILED; KILLED; };
	kind: JobKind;
	name: string_view;

	pid: Pid;

	stdin:  IoStream;
	stdout: IoStream;

	pending:  [..]Request;
	complete: [..]Request;
	mutex:    std.Mutex;

	kill: bool;
	is_removed: bool;
}

Request :: struct {
	job_kind: JobKind;
	data: union {
		clang_format: struct {
			filepath:     string;
			src:          string;
			buffer_index: s32;
			buffer_hash:  u32;
		};
		build: struct {
			text: string;
		};
		lsp: struct {
			kind:         LspRequestKind;
			buffer_index: s32;
			src:          string;
			filepath:     string;
			cursor:       Cursor;
			version:      s32;
			dia:      [..]ErrorLocation;
			strs:     [..]string; // @Incomplete: Use also for src and filepath
		};
	}
}

JobKind :: enum {
	UNKNOWN;
	CLANG_FORMAT;
	BUILD;
	LSP;
}

Job :: std.Async2(JobContext, s32);
jobs: [..]Job;

jobs_init :: fn () {}

jobs_terminate :: fn () {
	using std;
	kill_async_jobs();
}

start_async_job :: fn (kind: JobKind, name: string_view, worker: *fn (ctx: *JobContext) s32) s32 {
	using std;

	ctx := JobContext.{
		state = JobContext.state.RUNNING,
		name  = name,
		kind  = kind,
	};
	mutex_init(&ctx.mutex);

	job: *Job;
	index := -1;
	loop i := 0; i < jobs.len; i += 1 {
		if jobs[i].worker_context.is_removed {
			job   = zeroinit(&jobs[i]);
			index = i;
		}
	}

	if !job {
		index = auto jobs.len;
		job   = zeroinit(array_push(&jobs));
	}
	async2(job, ctx, worker);
	assert(index >= 0);
	return index;
}

remove_async_job :: fn (index: s32) {
	using std;
	using JobContext.state;

	job :: &jobs[index];
	ctx :: &job.worker_context;

	assert(!ctx.is_removed);

	ctx.kill = true;
	async_wait(job);

	switch ctx.state {
		DONE   { print_info("Job '%' finished.", ctx.name); }
		KILLED { print_warn("Job '%' killed.", ctx.name); }
		FAILED;

		default { panic(); }
	}

	consume_job_results(job, true);

	if ctx.kind == JobKind.BUILD {
		build.job_index = -1;
	} else if ctx.kind == JobKind.LSP {
		remove_all_buffers_from_lsp();
		lsp.job_index = -1;
	}

	loop i := 0; i < ctx.pending.len; i += 1 {
		terminate_request(&ctx.pending[i]);
	}
	loop i := 0; i < ctx.complete.len; i += 1 {
		terminate_request(&ctx.complete[i]);
	}

	array_terminate(&ctx.pending);
	array_terminate(&ctx.complete);
	std.mutex_terminate(&ctx.mutex);

	ctx.is_removed = true;
}

kill_async_jobs :: fn () {
	using std;
	using JobContext.state;

	has_running_jobs := false;
	loop i := 0; i < jobs.len; i += 1 {
		job :: &jobs[i];
		if job.worker_context.is_removed { continue; }
		remove_async_job(i);
		has_running_jobs = true;
	}
	array_terminate(&jobs);
	zeroinit(&jobs);

	if !has_running_jobs {
		print_info("No asynchronous jobs are running.");
	}
}

consume_job_results :: fn (job: *Job, required := false) {
	using std;
	using JobContext.state;
	using JobKind;

	ctx :: &job.worker_context;
	assert(!ctx.is_removed);

	locked := false;
	if required {
		locked = true;
		mutex_lock(&ctx.mutex);
	} else {
		l, err :: mutex_try_lock(&ctx.mutex);
		if err {
			print_err(err);
		} else {
			locked = l;
		}
	}

	if locked {
		defer mutex_unlock(&ctx.mutex);

		result: Request #noinit;
		loop pop_result(ctx, &result) {
			assert(result.job_kind == ctx.kind);
			switch ctx.kind {
				CLANG_FORMAT { apply_format(ctx.state, &result);      }
				BUILD        { apply_build(ctx.state, &result);       }
				LSP          { apply_lsp_results(ctx.state, &result); }
				default { panic(); }
			}
			terminate_request(&result);
		}
	}
}

update_jobs :: fn () {
	using std;
	using JobContext.state;
	using JobKind;

	loop i := 0; i < jobs.len; i += 1 {
		job :: &jobs[i];
		ctx :: &job.worker_context;
		if ctx.is_removed { continue; }

		consume_job_results(job);

		if ctx.state != RUNNING {
			remove_async_job(i);
		}
	}
}

get_job_context :: fn (index: s32) *JobContext {
	assert(index >= 0 && index < jobs.len);
	return &jobs[index].worker_context;
}

push_request :: fn (ctx: *JobContext, request: *Request) {
	using std;
	assert(request.job_kind == ctx.kind);
	mutex_lock(&ctx.mutex);
	defer mutex_unlock(&ctx.mutex);
	r :: array_push(&ctx.pending);
	memcpy(auto r, auto request, sizeof(@request));
}

pop_request :: fn (ctx: *JobContext, request: *Request) bool {
	using std;
	mutex_lock(&ctx.mutex);
	defer mutex_unlock(&ctx.mutex);
	if array_pop_first(&ctx.pending, request) {
		assert(request.job_kind == ctx.kind);
		return true;
	}
	return false;
}

push_result :: fn (ctx: *JobContext, request: *Request) {
	using std;
	assert(request.job_kind == ctx.kind);
	mutex_lock(&ctx.mutex);
	defer mutex_unlock(&ctx.mutex);
	r :: array_push(&ctx.complete);
	memcpy(auto r, auto request, sizeof(@request));
}

pop_result :: fn (ctx: *JobContext, request: *Request) bool {
	using std;
	mutex_lock(&ctx.mutex);
	defer mutex_unlock(&ctx.mutex);
	if array_pop_first(&ctx.complete, request) {
		assert(request.job_kind == ctx.kind);
		return true;
	}
	return false;
}

terminate_request :: fn (request: *Request) {
	using std;
	using JobKind;
	switch request.job_kind {
		CLANG_FORMAT {
			str_delete(&request.data.clang_format.src);
			str_delete(&request.data.clang_format.filepath);
		}
		BUILD {
			str_delete(&request.data.build.text);
		}
		LSP {
			rd :: &request.data.lsp;
			str_delete(&rd.src);
			str_delete(&rd.filepath);
			array_terminate(&rd.dia);
			loop i := 0; i < rd.strs.len; i += 1 {
				str_delete(&rd.strs[i]);
			}
			array_terminate(&rd.strs);
		}
		default;
	}
}

check_main_thread :: fn (loc := #call_location) #enable_if IS_DEBUG {
	if MAIN_THREAD_ID != std.get_thread_id() {
		panic("Location: %:% is expected to be reached only from the main thread!", loc.file, loc.line);
	}
}

is_lmb_down :: fn () bool #inline {
	return is_flag(mouse.state, MouseState.LB_DOWN);
}

is_lmb_press :: fn () bool #inline {
	return is_flag(mouse.state, MouseState.LB_PRESS);
}

is_lmb_dbl_press :: fn () bool #inline {
	return is_flag(mouse.state, MouseState.LB_DBL_PRESS);
}

is_lmb_release :: fn () bool #inline {
	return is_flag(mouse.state, MouseState.LB_RELEASE);
}

is_lmb_dragging_start :: fn () bool #inline {
	return is_flag(mouse.state, MouseState.LB_DRAGGING_START);
}

is_lmb_dragging :: fn {
	fn  (elem_id: u32) bool #inline {
		return mouse.drag_target_elem_id == elem_id && is_flag(mouse.state, MouseState.LB_DRAGGING);
	};
	fn () bool #inline {
		return is_flag(mouse.state, MouseState.LB_DRAGGING);
	};
}

set_mouse_cursor :: fn (cursor := MouseCursor.DEFAULT) #inline {
	if mouse.current_cursor == cursor { return; }
	mouse.current_cursor = cursor;

	using MouseCursor;
	using glfw;
	switch cursor {
		DEFAULT { SetCursor(window, null);              }
		IBEAM   { SetCursor(window, mouse.beam_cursor); }
	}
}

caret: struct {
	visible:    bool;
	blink_t:    f32;
	no_binking: bool;
};

reset_caret_blinking :: fn () #inline {
	caret.blink_t    = 0.f;
	caret.visible    = true;
	caret.no_binking = false;
}

clipboard_read :: fn () string_view {
	cstr :: glfw.GetClipboardString(window);
	if !cstr { return ""; }
	return std.ctostr(auto cstr);
}

clipboard_write :: fn (str: string_view) {
	using std;
	if str.len == 0 { return; }
	// The input string might not be zero terminated.
	dup :: str_new(str, application_context.temporary_allocator);
	glfw.SetClipboardString(window, auto std.strtoc(dup));
}

#private

MAIN_THREAD_ID: u64;

message: Message;
debug_allocator: std.DebugAllocator;
ignore_char_input: bool;

// Might be changed when window is not focused.
low_power_mode: bool;

draw_frame :: fn () {
	using draw;

	clear_color(colors.foreground_color);

	{
		active_x: f32;
		x :: 0.f;
		y := 0.f;

		h := cast(f32) WINDOW_HEIGHT;
		w := cast(f32) WINDOW_WIDTH;

		// This is probably temporary solution fixing the issue when we cannot see the search hit
		// on the first line which is covered by the command buffer line.
		if active_editor == command_editor && mode == Mode.SEARCH_FILE {
			_, ch :: get_command_editor_size();
			y += ch;
			h -= ch;
		}

		assert(left != -1);
		if right != -1 {
			gap :: 2.f;
			w = (0.5f * cast(f32) WINDOW_WIDTH) - gap * 0.5f;

			lx :: x;
			rx :: w + gap;

			draw_text_editor(left,  lx, y, w, h);
			draw_text_editor(right, rx, y, w, h);

			if active_editor == left {
				active_x = lx;
			} else if active_editor == right {
				active_x = rx;
			}
		} else {
			draw_text_editor(left, x, y, w, h);
		}

		using Mode;
		switch mode {
			TEXT_EDIT;
			GOTO_LINE         { draw_goto_mode();              }
			OPEN_FROM_DRIVE   { draw_open_from_drive_mode();   }
			QUICK_OPEN        { draw_quick_open_mode();        }
			SAVE_TO_DRIVE     { draw_save_to_drive_mode();     }
			RUN_COMMAND       { draw_run_command_mode();       }
			SEARCH_FILE       { draw_search_mode();            }
			OPEN_PROJECT      { draw_open_project_mode();      }
			SEARCH_IN_PROJECT { draw_search_in_project_mode(); }
			COMPLETION        {
				draw_completion_mode(active_x, y);
			}

			default;
		}
	}

	flush();
    glfw.SwapBuffers(window);
    temporary_reset();
}

print_glfw_error :: fn () {
    cstr: *u8;
    glfw.GetError(&cstr);

    if cstr == null { return; }
    tmp := string_view.{ auto C.strlen(auto cstr), auto cstr };
    print_err("GLFW Error: %", tmp);
}

key_callback :: fn (_: *glfw.Window, k: s32, _: s32, action: s32, mods: s32) {
	using glfw;

	reset_caret_blinking();
	if is_lmb_dragging() { return; }

	key := k;
	if key == KEY_KP_ENTER {
		key = KEY_ENTER;
	}

	if action == PRESS || action == REPEAT {
		ignore_char_input = ((mods & MOD_CONTROL) == MOD_CONTROL) || ((mods & MOD_ALT) == MOD_ALT);
		loop i := 0; i < key_binding.len; i += 1 {
			m :: &key_binding[i];
			if m.key == key && m.mods == mods {
				buf, editor :: get_active_buffer_and_editor();
				clear_message();
				error_marker_visible = false;
				invoke_command(editor, buf, m.cmd);
				break;
			}
		}
	}
}

character_callback :: fn (_: *glfw.Window, codepoint: u32) {
	if ignore_char_input { return; }
	reset_caret_blinking();

	if input_mode == InputMode.NUMBERS && ((codepoint < cast(u32) '0') || (codepoint > cast(u32) '9')) {
		return;
	}
	if is_lmb_dragging() { return; }

	clear_message();

	buf, editor :: get_active_buffer_and_editor();
	if maybe_report_readonly(buf) { return; }

	cut_selection(editor, buf, editor.index != command_editor);

	position := get_cursor_position(buf, editor.cursor_index);
	if has_indentation_info(buf) && is_row_empty(buf, position) {
		indent_range(buf, position, position);
	}

	position = get_cursor_position(buf, editor.cursor_index);
	inserted :: insert_unicode_character(buf, position, codepoint);

	if has_indentation_info(buf) && std.str_match(FILE_TYPE_REINDENT_ON[auto buf.file_type], inserted) {
		indent_range(buf, position, position);
	}

	set_prev_executed_command(Command.UNKNOWN);
}

mouse_button_callback :: fn (_: *glfw.Window, button: s32, action: s32, _: s32) {
    using glfw;
	using MouseState;
    switch button {
        MOUSE_BUTTON_LEFT {
            if action == PRESS {
				set_flag(&mouse.state, LB_PRESS);
                set_flag(&mouse.state, LB_DOWN);
				// detect double-click
				if GetTime() - mouse.prev_click_time_s < MOUSE_DBL_CLICK_S {
					set_flag(&mouse.state, LB_DBL_PRESS);
				}
				mouse.prev_click_time_s = GetTime();
            } else if action == RELEASE {
                set_flag(&mouse.state, LB_RELEASE);
                clr_flag(&mouse.state, LB_DOWN);
            }
        }
        default;
    }
	set_prev_executed_command(Command.UNKNOWN);
	if action == PRESS {
		clear_message();
	}
}

scroll_callback :: fn (_: *glfw.Window, _: f64, yoff: f64) {
	reset_caret_blinking();
	mouse.scroll += auto yoff;
	clear_message();
}

window_iconify_callback :: fn (_: *glfw.Window, iconified: s32) {
	low_power_mode = iconified != 0;
}

window_size_callback :: fn (_: *glfw.Window, _: s32, _: s32) {
	glfw.GetFramebufferSize(window, &WINDOW_WIDTH, &WINDOW_HEIGHT);
	draw.set_viewport_size(WINDOW_WIDTH, WINDOW_HEIGHT);

	// Hide any possible completion popup.
	if mode == Mode.COMPLETION { set_mode(Mode.TEXT_EDIT); }

	draw_frame();
}

window_scale_callback :: fn (_: *glfw.Window, xscale: f32, _: f32) {
	WINDOW_SCALE = xscale;
	scaling_changed = true;
	rebuild_fonts();
	draw_frame();
}

window_focus_callback :: fn (_: *glfw.Window, focused: s32) {
	if focused > 0 {
		reset_caret_blinking();
		low_power_mode = false;
	} else {
		caret.no_binking = true;
		low_power_mode   = true;
		print_log("Focus out!");
	}
}

drop_callback :: fn (_: *glfw.Window, count: s32, paths: **u8) {
	p :: []*u8.{ count, paths };
	loop i := 0; i < p.len; i += 1 {
		filepath :: std.ctostr(auto p[i]);
		buf_error :: open(filepath);
		if buf_error {
			print_err(buf_error);
		}
	}
}

recalculate_metrics :: fn () {
	using Metric;
	metrics[auto TITLE_BAR_HEIGHT] = font_ui.height  * 1.6f;
	metrics[auto LINE_HEIGHT     ] = font.height  * LINE_SPACING;
	metrics[auto ITEM_SPACING    ] = icons.height * 1.2f;
	metrics[auto TEXT_PADDING    ] = font.height  * 0.2f;
	metrics[auto TITLE_MAX_SIZE  ] = font.height  * 25.f;
	metrics[auto SHADOW_SIZE     ] = WINDOW_SCALE * 10.f;
	metrics[auto CORNER_ROUNDING ] = WINDOW_SCALE * 4.f;
}

file_to_stack :: fn (filepath: string_view) []u8 #comptime {
	using std;
	using StreamLocator;

    stream, open_err :: open_file(filepath);
    defer close_file(&stream);
    if open_err {
        panic(open_err);
    }
	size, seek_end_err :: seek(&stream, END);
	if seek_end_err { panic(seek_end_err); }

	_, seek_begin_err :: seek(&stream, BEGIN);
	if seek_begin_err { panic(seek_begin_err); }

	data, alloc_err :: new_slice(u8, size, true);
	if alloc_err { panic(alloc_err); }

	read_err :: read_all(&stream, data.ptr, data.len, 2048);
	if read_err { panic(read_err); }
    return data;
}

set_allocator_allocator :: fn (allocator: *Allocator) *Allocator {
	if !allocator { return null; }
	prev_allocator :: application_context.allocator;
	if prev_allocator == &debug_allocator {
		std.dump_memory_leaks(auto prev_allocator);
		std.debug_allocator_release(auto prev_allocator);
	}
	application_context.allocator = allocator;
	return prev_allocator;
}

set_logger :: fn (func: PrintLogFn) PrintLogFn {
	prev_func :: application_context.print_log_fn;
	application_context.print_log_fn = func;
	return prev_func;
}

// Use this to prevent recursive looping when log is reported while we report logs...
log_reported := false;

logger :: fn (kind: PrintLogKind, file: string_view, line: s32, format: string_view, args: ...) {
	get_message_prefix :: fn (kind: PrintLogKind) string_view {
		using PrintLogKind;
		switch kind {
			WARNING { return "warning: "; }
			ERROR   { return "error: ";   }
			default;
		}
		return "";
	};

	// Prevent looping.
	if log_reported { return; }
	log_reported = true;

	defer fn () {
		log_reported = false;
	}();

	using std;
	using PrintLogKind;
	switch kind {
		INFO, WARNING, ERROR {
			mutex_lock(&message.mutex);
			defer mutex_unlock(&message.mutex);

			message.kind     = kind;
			message.text.len = 0;

			str_append(&message.text, tprint(format, args));
		}
		MESSAGE {
#if !IS_DEBUG { return; }
		}
		default;
	}

	switch kind {
		INFO, WARNING, ERROR, MESSAGE {
			index :: messages_buffer_index;
			if index >= 0 && index < buffers.len {
				buf :: &buffers[index];
				if !buf.is_removed {
					msg :: tprint(format, args);
					lock_buffer(buf);
					defer unlock_buffer(buf);
					append_readonly_buffer(buf, tprint("%%\n", get_message_prefix(kind), msg));
				}
			}
		}
		default;
	}
	__print_log_default(kind, file, line, format, args);
}

set_icon :: fn () {
	using glfw;
	using draw;
	image: Image;
	bit_depth: u8;
	format: TextureFormat;
	err :: png_load_from_memory(APPLICATION_ICON_DATA, &image.pixels, auto &image.width, auto &image.height, &bit_depth, &format);
	defer free(image.pixels);
	if err { panic(err); }
	images :: [1]Image.{ image };
	SetWindowIcon(window, 1, images.ptr);
}

clear_mouse_events :: fn () {
	mouse.scroll = 0.f;
	using MouseState;
	clr_flag(&mouse.state, LB_PRESS);
	clr_flag(&mouse.state, LB_RELEASE);
	clr_flag(&mouse.state, LB_DRAGGING_START);
	clr_flag(&mouse.state, LB_DBL_PRESS);
}

update_mouse :: fn () {
	using glfw;
	using MouseState;

	mpx, mpy: f64;
	GetCursorPos(window, &mpx, &mpy);

	scale: f32;
	#if PLATFORM == Platform.DARWIN {
		GetWindowContentScale(window, &scale, null);
	} else {
		scale = 1.f;
	}

	mouse.px = (cast(f32) mpx) * scale;
	mouse.py = (cast(f32) mpy) * scale;
	mouse.last_hover_elem_id = mouse.hover_elem_id;
	mouse.hover_elem_id = 0;

	using glm;
	if is_lmb_press() {
		mouse.prev_mouse_pos = v2.{ mouse.px, mouse.py };
	}

	if is_lmb_down() && is_lmb_dragging() == false && distance(v2.{ mouse.px, mouse.py }, mouse.prev_mouse_pos) > MOUSE_DRAG_OFFSET {
		mouse.state |= LB_DRAGGING | LB_DRAGGING_START;
		mouse.drag_target_elem_id = mouse.last_hover_elem_id;
	}
	if is_lmb_release() {
		clr_flag(&mouse.state, LB_DRAGGING);
		mouse.drag_target_elem_id = 0;
	}
}

update_caret :: fn () {
	if caret.no_binking {
		caret.visible = true;
		return;
	}

	caret.blink_t += frame_delta_time;
	if caret.blink_t > CARET_BLINK_MS {
		caret.blink_t = 0.f;
		caret.visible = !caret.visible;
	}
}

/*
TODO

4 release
- mouse support
  x current hover element recorder each frame
  - resize split
  x scroll buffers
  x select in buffer
    x double click select word
    - tripple click select line
  x set cursor position
  x switch active split
  x clicking in the lists
  x scroling in the lists
  - add scroll indicators for lister

x horizontal view switch if we go too far
x help + readme
- find and replace in file
x remap keyboard
x cursor blinking
- hot-reload non-project files
- hot-reload project configs
x clang-format
- add command to kill clang format
x stop cursor blinking when window is out of focus
x indentation on the last line in the file is broken when typing
- Show whole diag message on cursor hover.

4 work
- LSP for c++
  x goto definition
  x restart command
  x kill command
  x info in status bar (LSP (server name), warning and error count).
  x symbol suggestions
  x add opened files on server start! (remove buffer updates)
  x cleanup inline hints on server kill/crash
  x remove all tracked files on server kill (remove buffer updates...)
  - handle fatal errors
  - complete on tab
  - cleanup completion flow
    - messy completions sometimes
    - completion does not work until we enter some text
    - popup can overflow to right from the window
  - LSP cannot goto definition in file paths containing spaces (win api functions).

- process
  - macos port
  - get status of the process (wait pid???)

- save all command
- focus into the build output only in case it failed compilation?
x open file in a new split on the same position if it's already open in other split.
x merge quick-open and buffer-open
- Message should disapear after some time.
x Experiment with toggle ctrl?
- Crash on project reload during indexing?
- Indexing too often?
x Warnings/errors should not cover document title bar.
x fix cursor position after indentation!!!
x autoindent when we insert indentation char
x virtual whitespace indentation for empty lines (finally not used)
- change default font from settings
x move up and down should try to respect indentation
  x make settings entry for this
x autoindent on paste when enabled
  x allow this for the whole inserted block of code (we cannot do it right now, because the indentation
    info is not recomputed right away after insertion, so in case the clipboard text contains some chars changing
    indentation the result is invalid)
x Reduce framerate after some period of idle time? (note we wait for events and also limit max frame rate on mac).
x Open file from the command line sometimes fails, also filepath is not normalized.
- recursive search might output results into separate buffer and allow user to switch quickly locations (alt+n/alt+p).
x markdown syntax
  - improve?
x make startup maximization optional
- messages clear command
- jump to previous position
x add str_match_ignore_case
- prefer previous buffer in the split on close current one
x add command to kill current build
x error in project config has invalid line number...
- undo of large file change should restore cursor positions?
x reduce override of the clipboard by stuff from command buffer
- cut sometimes breaks new lines... (maybe breaks on paste when we have in clipboard different line endings?)
- word wrap
  - rendering lines
  - rendering selection & highlights
  - cursor navigation and position
  - cursor mouse press position
C list all running processes and kill them!
- highlight current word after timeout
- last search should stay in search in files command
x switch cpp/h (covered by LSP)
x numpad enter should also work
- filewatch reload opened files
	- hot reload current or default project file
	- reload openned files outside of project
- multithreaded features should reuse the same threads instead creating new ones everytime
- syntax for batch
x parse keys in settings
- draw module should prepare font glyphs into rectangle texture not into line...
- move line up and down
- dark/light colors switch
- not all commands needs to return value...
- add documentation into the global config file
- hide mouse cursor after some time without movement
- don't highlight entries under cursor until mouse was not moved to prevent confusion which item is selected.
x set window minimal size

*/

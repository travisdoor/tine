run_command_mode_init :: fn () {
	active_editor = command_editor;
	buf :: get_active_buffer_and_editor();
	clear_buffer(buf);

	input_mode               = InputMode.TEXT;
	notify_changes_to_buffer = buf.index;

	repeat_command_count = math.max(1, last_command_repeat_count);
	last_command_repeat_count = 0;

	list_commands(repeat_command_count > 1);
}

run_command_mode_terminate :: fn () {}

draw_run_command_mode :: fn () {
	assert(active_editor == command_editor);
	w, h :: get_command_editor_size();

	title := "Run: ";
	if repeat_command_count > 1 then title = tprint("Run [%x]: ", repeat_command_count);
	draw_command_editor(command_editor, 0.f, 0.f, w, h, title);

	using DrawListCols;
	list_h, clicked :: draw_list(0.f, h, w, TITLE | HINT | PREVIEW);
	draw_last_status_message(0.f, h + list_h, w);
	if clicked { commit(); }
}

//
// Commands
//

invoke_command_run_command_mode :: fn (buf: *Buffer #maybe_unused, cmd: Command) bool {
	assert(active_editor == command_editor);
	assert(editors[active_editor].buffer_index == buf.index);

	using Command;

	switch cmd {
		INSERT_NEW_LINE { commit(); }

		MOVE_UP   { list_item_up();   }
		MOVE_DOWN { list_item_down(); }

		default { return false; }
	}

	return true;
}

run_command_cmd_changed :: fn () {
	buf :: get_active_buffer_and_editor();
	cmd :: peek_row(buf, 0);
	if cmd.len == 0 {
		clear_list_filters();
		return;
	}

	filter_list(cmd);
}

#scope_private

repeat_command_count := 0;

commit :: fn () {
	set_mode(Mode.TEXT_EDIT);

	item :: get_selected_item_in_list();
	if !item { return; }

	target_buf, target_editor :: get_active_buffer_and_editor();
	loop i := 0; i < repeat_command_count; i += 1 {
		invoke_command(target_editor, target_buf, auto item.index);
	}
}


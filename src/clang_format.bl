request_format :: fn (buf: *Buffer) Error {
	if buf.file_type != FileType.C {
		return error("Buffer '%' is not recognized as C/C++ source file.", buf.name);
	}
	if buf.bytes.len == 0 then return OK;

	// set buffer temporarily as readonly
	buf.flags |= BufferFlags.READONLY;
	job_index :: start_async_job(JobKind.CLANG_FORMAT, "clang-format", &worker);

	request := Request.{ job_kind = JobKind.CLANG_FORMAT };
	rd :: &request.data.clang_format;
	rd.filepath     = str_make(buf.filepath);
	rd.src          = str_make(buf.bytes);
	rd.buffer_index = buf.index;
	rd.buffer_hash  = buf.hash;

	buf.has_pending_job += 1;

	push_request(get_job_context(job_index), &request);

	return OK;
}

apply_format :: fn (job_state: JobContext.state, request: *Request) {
	check_main_thread();

	rd :: &request.data.clang_format;

	// If clang-format took long time, it's possible the target buffer was removed or
	// the buffer slot was reused for a different file...
	buf :: &buffers[rd.buffer_index];
	if buf.is_removed             { return; }
	if buf.hash != rd.buffer_hash { return; }
	clr_flag(&buf.flags, BufferFlags.READONLY);
	buf.has_pending_job -= 1;
	if job_state == JobContext.state.DONE then change_content(buf, rd.src);
}

#scope_private

get_clang_format_executable :: fn () string_view {
	if settings.clang_format_executable.len > 0 then return settings.clang_format_executable;
	#if PLATFORM == Platform.WINDOWS {
		return "clang-format.exe";
	}
	return "clang-format";
}

worker :: fn (ctx: *JobContext) s32 {
	using JobContext.state;

	// wait for request
	request: Request #noinit;
	loop !pop_request(ctx, &request) {
		os_sleep_ms(10);
	}
	request_data :: &request.data.clang_format;
	executable   :: get_clang_format_executable();

	// We need to unlock the file and do other stuff even in case execution failed...
	defer push_result(ctx, &request);

	args :: [_]string_view.{ tprint("--assume-filename=\"%\"", request_data.filepath) };
	start_process(ctx, executable, args) catch {
		if $.code == ERR_NOT_FOUND {
			print_err("Cannot find '%' executable. Path to the executable must be included in your PATH environment variable.", executable);
		} else {
			print_err("Cannot execute '%' with error: %", executable, $);
		}
		ctx.state = FAILED;
		return 1;
	};

	defer stop_process(ctx);

	write_pipe(ctx.stdin, request_data.src) catch {
		print_err("The '%' failed with error: %", executable, $);
		ctx.state = FAILED;
		return 1;
	};

	// Submit the source to the clang-format.
	close_pipe(&ctx.stdin);
	request_data.src.len = 0;

	loop !ctx.kill {
		state :: poll_process(ctx) catch {
			print_err("The '%' failed with error: %", executable, $);
			ctx.state = FAILED;
			return 1;
		};

		using PollEvent;
		if is_flag(state, READ) {
			read_pipe(ctx.stdout, &request_data.src) catch {
				print_err("The '%' failed with error: %", executable, $);
				ctx.state = FAILED;
				return 1;
			};
		}
		if is_flag(state, CLOSED) {
			print_log("Closed");
			ctx.state = DONE;
			return 0;
		}
		os_sleep_ms(10);
	}

	ctx.state = KILLED;
	return 0;
}

build: struct {
	job_index:    s32;
	buffer_index: s32;
};

build_init :: fn () {
	build.job_index    = -1;
	build.buffer_index = -1;
}

request_build :: fn (args: string_view) Error {
	clear_error_list();

	// if !file_exist(BUILD_SCRIPT) {
	// 	cwd :: get_cwd();
	// 	defer str_delete(&cwd);
	// 	return error("Build script '%' not found in '%' (current working directory).", BUILD_SCRIPT, cwd);
	// }

	if build.job_index != -1 {
		return error("Build is already in progress, use 'build-kill' for interruption and try again.");
	}

	shell_executable_path :: if settings.shell_executable.len == 0 then DEFAULT_SHELL else settings.shell_executable;
	assert(shell_executable_path.len > 0, "Invalid shell executable!");

	// @Incomplete 2025-01-14: Check if shell_executable_path points to valid executable file?

	// shell_name :: path_splitext(path_split(shell_executable_path).tail).head;
	// if shell_name.len == 0 {
	// 	print_err("Invalid shell executable path: '%'.", shell_executable_path);
	// 	return 0;
	// }
	// #if PLATFORM == Platform.WINDOWS {
	// 	shell_name_uppercase :: str_new(shell_name, application_context.temporary_allocator);
	// 	str_upper(&shell_name_uppercase);
	// 	if str_match(shell_name_uppercase, "CMD") then array_push(&args, "/c");
	// }


	_, prev_editor :: get_active_buffer_and_editor();

	find_or_create_editor_with_buffer_in_other_split(&build.buffer_index, "build");
	buf :: &buffers[build.buffer_index];

	active_editor = prev_editor.index;

	clear_buffer(buf);
	job_index :: start_async_job(JobKind.BUILD, "build", &worker);

	request := Request.{ job_kind = JobKind.BUILD };
	request_data :: &request.data.build;
	request_data.shell = str_new(shell_executable_path);
	request_data.args  = sprint("\"%\"", args);

	push_request(get_job_context(job_index), &request);

	build.job_index = job_index;
	return OK;
}

apply_build :: fn (_: JobContext.state, request: *Request) {
	if build.buffer_index == -1 then return;
	assert(build.buffer_index >= 0 && build.buffer_index < buffers.len);
	buf :: &buffers[build.buffer_index];
	if buf.is_removed {
		kill_build();
	} else {
		request_data :: &request.data.build;
		append_readonly_buffer(buf, request_data.text);
	}
}

kill_build :: fn () {
	if build.job_index == -1 {
		print_warn("Build is not running.");
		return;
	}
	assert(build.job_index >= 0 && build.job_index < jobs.len);
	assert(!jobs[build.job_index].worker_context.is_removed);
	assert(jobs[build.job_index].worker_context.kind == JobKind.BUILD);
	remove_async_job(build.job_index);
}

#scope_private

worker :: fn (ctx: *JobContext) s32 {
	using JobContext.state;

	// wait for request
	request: Request #noinit;
	loop !pop_request(ctx, &request) {
		os_sleep_ms(10);
	}
	request_data :: &request.data.build;
	defer terminate_request(&request);

	shell_executable_path :: request_data.shell;
	args                  :: [_]string_view.{ "/c", request_data.args };

	print_log("Execute: % %", shell_executable_path, args);

	err :: start_process(ctx, shell_executable_path, args);
	if err {
		print_err(err);
		ctx.state = FAILED;
		return 0;
	}

	result :: Request.{ job_kind = JobKind.BUILD };
	result_data :: &result.data.build;

	result_data.text = sprint("Building project '%'.\n", project.name);
	push_result(ctx, &result);

	loop !ctx.kill {
		state, err :: poll_pipe(ctx.stdout);
		if err {
			print_err(err);
            ctx.state = FAILED;
            break;
		}

		using PollEvent;
		if is_flag(state, READ) {
			result_data.text = str_new();
			defer push_result(ctx, &result);

			err_read :: read_pipe(ctx.stdout, &result_data.text);
			if err_read {
				print_err(err_read);
				ctx.state = FAILED;
				break;
			}
		}
		if is_flag(state, CLOSED) {
			ctx.state = DONE;
			break;
		}

		os_sleep_ms(10);
	}

	switch ctx.state {
		DONE {
			result_data.text = str_new("\nDONE!\n");
			push_result(ctx, &result);
			return 0;
		}
		FAILED {
			return 0;
		}
		default;
	}

	err_kill :: kill_process(ctx.pid, 0);
	if err_kill {
		print_err(err_kill);
		ctx.state = FAILED;
		return 0;
	}

	result_data.text = str_new("\nJob killed.\n");
	push_result(ctx, &result);

	ctx.state = KILLED;
	return 0;
}

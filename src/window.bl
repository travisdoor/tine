WINDOW_WIDTH  := 800;
WINDOW_HEIGHT := 600;
WINDOW_SCALE  := 1.f;
WINDOW_TITLE  :: "Tine"; // This is not Emacs

window: *sdl.Window;

//
// Mouse
//

MouseState :: enum #flags {
	LB_PRESS;
	LB_DOWN;
	LB_RELEASE;
	LB_DBL_PRESS;
	LB_DRAGGING_START;
	LB_DRAGGING;
}

mouse: struct {
	position: v2;
	scroll:   f32;

	last_hover_elem_id:  u32;
	hover_elem_id:       u32;
	drag_target_elem_id: u32;

	state: MouseState;

	current_cursor: CursorShape;
};

init_window :: fn () {
	using sdl;

	#if PLATFORM == Platform.LINUX {
		SetHint(strtoc(HINT_VIDEO_DRIVER), strtoc("wayland, x11"));
		SetHint(strtoc(HINT_VIDEO_WAYLAND_PREFER_LIBDECOR), strtoc("1"));
	}

	if !Init(INIT_VIDEO) then panic(sdl_last_error());

	video_driver :: ctostr(sdl.GetCurrentVideoDriver());
	using WindowSystem;
	if str_match(video_driver, "x11") {
		WINDOW_SYSTEM = X11;
	} else if str_match(video_driver, "wayland") {
		WINDOW_SYSTEM = WAYLAND;
	} else if str_match(video_driver, "win32") {
		WINDOW_SYSTEM = WIN32;
	} else if str_match(video_driver, "cocoa") {
		WINDOW_SYSTEM = COCOA;
	}

	print_log("SDL Video: %", ctostr(sdl.GetCurrentVideoDriver()));

	using GLAttr;
	if !GL_SetAttribute(GL_CONTEXT_MAJOR_VERSION, 3) then panic(sdl_last_error());
	if !GL_SetAttribute(GL_CONTEXT_MINOR_VERSION, 3) then panic(sdl_last_error());
	if !GL_SetAttribute(GL_CONTEXT_PROFILE_MASK, GL_CONTEXT_PROFILE_CORE) then panic(sdl_last_error());
	if !GL_SetAttribute(GL_DOUBLEBUFFER, 1) then panic(sdl_last_error());
	if !GL_SetAttribute(GL_MULTISAMPLESAMPLES, 2) then panic(sdl_last_error());

	window = CreateWindow(strtoc(WINDOW_TITLE), WINDOW_WIDTH, WINDOW_HEIGHT, WINDOW_RESIZABLE | WINDOW_OPENGL | WINDOW_HIGH_PIXEL_DENSITY);
	if (!window) then panic(sdl_last_error());

	set_icon();

	if !sdl.EnableScreenSaver() then print_err(sdl_last_error());

	if !GetWindowSizeInPixels(window, &WINDOW_WIDTH, &WINDOW_HEIGHT) then print_err(sdl_last_error());
	print_log("Window size: %x%", WINDOW_WIDTH, WINDOW_HEIGHT);

	WINDOW_SCALE = GetWindowDisplayScale(window);
	print_log("Window scale: %", WINDOW_SCALE);

	gctx :: GL_CreateContext(window);
	if !gctx then panic(sdl_last_error());
	if !GL_MakeCurrent(window, gctx) then panic(sdl_last_error());

	if !GL_SetSwapInterval(1) then print_err(sdl_last_error());
	if !StartTextInput(window) then panic(sdl_last_error());

	if WINDOW_SYSTEM == WindowSystem.COCOA || WINDOW_SYSTEM == WindowSystem.WIN32 {
		AddEventWatch(&fn (_: *u8, event: *Event) bool {
				using sdl;
				check_main_thread();
				if event.type == EventType.EVENT_WINDOW_RESIZED {
					GetWindowSizeInPixels(window, &WINDOW_WIDTH, &WINDOW_HEIGHT);
					draw.set_viewport_size(WINDOW_WIDTH, WINDOW_HEIGHT);

					redraw_immediatelly();
				}
				return true;
			});
	}

	default_cursor = CreateSystemCursor(SystemCursor.SYSTEM_CURSOR_DEFAULT);
	ibeam_cursor   = CreateSystemCursor(SystemCursor.SYSTEM_CURSOR_TEXT);
}

terminate_window :: fn () {
	using sdl;

	DestroyCursor(default_cursor);
	DestroyCursor(ibeam_cursor);

	GL_DestroyContext(GL_GetCurrentContext());
	DestroyWindow(window);
	Quit();
}

begin_frame :: fn () {
	mouse.last_hover_elem_id = mouse.hover_elem_id;
	mouse.hover_elem_id = 0;
}

end_frame :: fn () {
	sdl.GL_SwapWindow(window);
}

handle_window_event_loop :: fn () {
	using sdl;

	clear_mouse_events();
	if mouse.last_hover_elem_id != mouse.hover_elem_id then redraw();

	event: Event;
	loop WaitEventTimeout(&event, if draw_next_frame then 0 else 16) {

		using EventType;
		switch event.type {
			EVENT_QUIT { schedule_exit(); }

			EVENT_WINDOW_RESIZED, EVENT_WINDOW_PIXEL_SIZE_CHANGED, EVENT_WINDOW_EXPOSED, EVENT_WINDOW_DISPLAY_SCALE_CHANGED {
				GetWindowSizeInPixels(window, &WINDOW_WIDTH, &WINDOW_HEIGHT);
				draw.set_viewport_size(WINDOW_WIDTH, WINDOW_HEIGHT);

				if event.type == EVENT_WINDOW_PIXEL_SIZE_CHANGED || event.type == EVENT_WINDOW_DISPLAY_SCALE_CHANGED{
					WINDOW_SCALE = GetWindowDisplayScale(window);
					rebuild_fonts(true);
				}

				// Hide any possible completion popup.
				if mode == Mode.COMPLETION then set_mode(Mode.TEXT_EDIT);
				redraw();
			}

			EVENT_KEY_DOWN {

				VALID_MOD_KEY_MASK :: KMOD_CTRL | KMOD_SHIFT | KMOD_ALT | KMOD_GUI;

				key  := event.key.key;
				mod  := event.key.mod & VALID_MOD_KEY_MASK;

				if key == K_KP_ENTER then key = K_RETURN;

				if (mod & KMOD_CTRL)  != 0 then mod |= KMOD_CTRL;
				if (mod & KMOD_SHIFT) != 0 then mod |= KMOD_SHIFT;
				if (mod & KMOD_ALT)   != 0 then mod |= KMOD_ALT;
				if (mod & KMOD_GUI)   != 0 then mod |= KMOD_GUI;

				redirect_as_text_input := false;

				reset_caret_blinking();
				if is_lmb_dragging() then continue;
				loop i := 0; i < key_binding.len; i += 1 {
					m :: &key_binding[i];
					if m.mods != mod then continue;
					// Special case for repeat command which is invoked directly when modifier key + number is pressed.
					// This way we can repeat commands more ergonomically without too much keystrokes.
					if key >= K_0 && key <= K_9 && m.cmd == Command.REPEAT {
						if mode == Mode.REPEAT then {
							// When repeat mode is active, just redirect keys as text input.
							tmp :: string_view.{ 1, auto &key };
							handle_text_input(tmp);
							break;
						} else {
							// We need to activate repeat mode first.
							redirect_as_text_input = true;
						}
					} else if m.key != key {
						continue;
					}

					buf, editor :: get_active_buffer_and_editor();
					clear_message();
					if mode == Mode.PEEK_ERROR then set_mode(Mode.TEXT_EDIT);
					invoke_command(editor, buf, m.cmd);

					if redirect_as_text_input {
						tmp :: string_view.{ 1, auto &key };
						handle_text_input(tmp);
					}

					break;
				}
			}

			EVENT_TEXT_INPUT {
				if is_lmb_dragging() then continue;
				if (GetModState() & (KMOD_CTRL | KMOD_ALT | KMOD_GUI)) != 0 then continue;
				clear_message();

				handle_text_input(ctostr(event.text.text));
			}

			EVENT_MOUSE_BUTTON_DOWN {
				button  :: event.button.button;
				clicks  :: event.button.clicks;

				switch button {
					BUTTON_LEFT {
						if clicks == 1 {
							set_flag(&mouse.state, MouseState.LB_PRESS | MouseState.LB_DOWN);
						} else if clicks == 2 {
							set_flag(&mouse.state, MouseState.LB_DBL_PRESS | MouseState.LB_DOWN);
						}
					}
				}

				set_prev_executed_command(Command.UNKNOWN);
				clear_message();
				if mode == Mode.PEEK_ERROR then set_mode(Mode.TEXT_EDIT);

				redraw();
			}

			EVENT_MOUSE_BUTTON_UP {
				button  :: event.button.button;

				clr_flag(&mouse.state, MouseState.LB_DRAGGING);
				mouse.drag_target_elem_id = 0;

				switch button {
					BUTTON_LEFT {
						set_flag(&mouse.state, MouseState.LB_RELEASE);
						clr_flag(&mouse.state, MouseState.LB_DOWN);
					}
				}

				redraw();
			}

			EVENT_MOUSE_MOTION {
				GetMouseState(&mouse.position.x, &mouse.position.y);
				using WindowSystem;
				if WINDOW_SYSTEM == WAYLAND || WINDOW_SYSTEM == COCOA {
					mouse.position.x *= WINDOW_SCALE;
					mouse.position.y *= WINDOW_SCALE;
				}

				if is_flag(mouse.state, MouseState.LB_DOWN) && !is_flag(mouse.state, MouseState.LB_DRAGGING) {
					mouse.state |= MouseState.LB_DRAGGING | MouseState.LB_DRAGGING_START;
					mouse.drag_target_elem_id = mouse.last_hover_elem_id;
				}

				redraw();
			}

			EVENT_MOUSE_WHEEL {
				reset_caret_blinking();
				mouse.scroll += auto event.wheel.y;
				clear_message();
				if mode == Mode.PEEK_ERROR then set_mode(Mode.TEXT_EDIT);
				redraw();
			}

			EVENT_DROP_FILE {
				filepath :: ctostr(auto event.drop.data);
				if filepath.len < 1 then continue;
				set_mode(Mode.TEXT_EDIT);
				open(filepath) catch print_err($);
				redraw();
			}

			EVENT_WINDOW_FOCUS_GAINED {
				reset_caret_blinking();
				focused = true;
				redraw();
			}

			EVENT_WINDOW_FOCUS_LOST {
				stop_macro_recording();
				focused = false;
				redraw();
			}

			EVENT_WINDOW_MINIMIZED {
				minimized = true;
			}

			EVENT_WINDOW_RESTORED {
				minimized = false;
			}

			default;
		}
	}
}

handle_text_input :: fn (text: string_view) {
	if text.len < 1 then return; // just in case
	if (input_mode == InputMode.NUMBERS) && (text[0] < '0' || text[0] > '9') then return;

	redraw();
	reset_caret_blinking();

	if mode == Mode.PEEK_ERROR then set_mode(Mode.TEXT_EDIT);

	buf, editor :: get_active_buffer_and_editor();
	if maybe_report_readonly(buf) then return;

	cut_selection(editor, buf, editor.index != command_editor);

	position := get_cursor_position(buf, editor.cursor_index);
	if has_indentation_info(buf) && is_row_empty(buf, position) {
		indent_range(buf, position, position);
	}

	position = get_cursor_position(buf, editor.cursor_index);
	insert_string(buf, position, text);

	if has_indentation_info(buf) && str_match(FILE_TYPE_REINDENT_ON[auto buf.file_type], text) {
		indent_range(buf, position, position);
	}

	set_prev_executed_command(Command.UNKNOWN);

	if macros.is_recording then add_macro_record(text);
}

schedule_exit :: fn () {
	running = false;
}

get_ticks :: fn () f64 #inline {
	ms :: sdl.GetTicks();
	return cast(f64)ms / 1000.;
}

maximize_window :: fn () #inline {
	if !sdl.MaximizeWindow(window) then print_err(sdl_last_error());
}

is_running :: fn () bool #inline {
	return running;
}

set_window_title :: fn (title: string_view) #inline {
	if !sdl.SetWindowTitle(window, strtoc(title)) then print_err(sdl_last_error());
}

//
// Clipboard
//

read_clipboard :: fn () string_view {
	using sdl;

	if !HasClipboardText() then return "";
	cstr :: GetClipboardText();
	defer sdl.free(auto cstr);
	return str_make(cstr, application_context.temporary_allocator);
}

write_clipboard :: fn (text: string_view) {
	using sdl;

	if text.len < 1 then return;
	SetClipboardText(strtoc(text));
}


//
// Key names
//

key_name :: fn (code: u32) string_view {
	if code >= cast(u32) '!' && code <= cast(u32) '~' && code != cast(u32) ';' {
		c :: auto C.toupper(auto code);
		return tprint("%", string_view.{ 1, auto &c });
	}
	loop i := 0; i < KEYCODE_TO_NAME.len; i += 1 {
		if KEYCODE_TO_NAME[i].code == code {
			return KEYCODE_TO_NAME[i].name;
		}
	}
	return "";
}

key_from_name :: fn (name: string_view) u32 {
	using sdl;

	if name.len == 1 {
		code := cast(s32) name[0];
		if code >= cast(s32) '!' && code <= cast(s32) '~' && code != cast(s32) ';' {
			return auto C.tolower(code);
		}
	}
	loop i := 0; i < KEYCODE_TO_NAME.len; i += 1 {
		if str_match_ignore_case(KEYCODE_TO_NAME[i].name, name) {
			return KEYCODE_TO_NAME[i].code;
		}
	}

	return K_UNKNOWN;
}

mod_name :: fn (mod: u32) string_view {
	using sdl;

	switch mod {
		KMOD_SHIFT      { return "Shift";    }
		KMOD_CTRL       { return "Ctrl";     }
		KMOD_ALT        { return "Alt";      }
		KMOD_GUI        { return "Super";    }
		KMOD_CAPS       { return "CapsLock"; }
		KMOD_NUM        { return "NumLock";  }
		default;
	}
	return "";
}

mod_from_name :: fn (mod: string_view) u32 {
	using sdl;

	if str_match_ignore_case(mod, "alt")      { return KMOD_ALT;      }
	if str_match_ignore_case(mod, "ctrl")     { return KMOD_CTRL;     }
	if str_match_ignore_case(mod, "shift")    { return KMOD_SHIFT;    }
	if str_match_ignore_case(mod, "super")    { return KMOD_GUI;      }
	if str_match_ignore_case(mod, "numlock")  { return KMOD_NUM;      }
	if str_match_ignore_case(mod, "capslock") { return KMOD_CAPS;     }

	return KMOD_NONE;
}

get_mods :: fn () []u32 #inline {
	return MODS;
}

CursorShape :: enum {
	DEFAULT;
	IBEAM;
}

set_cursor :: fn (cursor := CursorShape.DEFAULT) #inline {
	using sdl;

	if mouse.current_cursor == cursor then return;
	mouse.current_cursor = cursor;

	using CursorShape;
	switch cursor {
		DEFAULT { SetCursor(default_cursor); }
		IBEAM   { SetCursor(ibeam_cursor);   }
	}
}

is_focused :: fn () bool #inline {
	return focused;
}

is_minimized :: fn () bool #inline {
	return minimized;
}

#scope_private

sdl :: #import "sdl3";

WindowSystem :: enum {
	WIN32;
	COCOA;
	X11;
	WAYLAND;
	OTHER;
}

WINDOW_SYSTEM: WindowSystem;

MODS :: [_]u32.{ sdl.KMOD_CTRL, sdl.KMOD_SHIFT, sdl.KMOD_ALT, sdl.KMOD_GUI };
running := true;
focused := true;
minimized := false;

default_cursor: *sdl.Cursor;
ibeam_cursor:   *sdl.Cursor;

clear_mouse_events :: fn () {
	mouse.scroll = 0.f;
	using MouseState;
	clr_flag(&mouse.state, LB_PRESS);
	clr_flag(&mouse.state, LB_RELEASE);
	clr_flag(&mouse.state, LB_DRAGGING_START);
	clr_flag(&mouse.state, LB_DBL_PRESS);
}

sdl_last_error :: fn () Error #inline {
	return error(ctostr(sdl.GetError()));
}

set_icon :: fn () {
	w, h, pitch: u32;
	bit_depth: u8;
	pixels: *u8;
	format: draw.TextureFormat;
	draw.png_load_from_memory(APPLICATION_ICON_DATA, &pixels, &w, &h, &bit_depth, &format, &pitch) catch panic($);
	defer free(pixels);

	surface :: sdl.CreateSurfaceFrom(auto w, auto h, sdl.PixelFormat.PIXELFORMAT_RGBA32, pixels, auto pitch);
	defer sdl.DestroySurface(surface);
	if !sdl.SetWindowIcon(window, surface) then print_err(sdl_last_error());
}

KeyName :: struct { code: sdl.Keycode; name: string_view };

KEYCODE_TO_NAME :: [_]KeyName.{
	.{ sdl.K_SEMICOLON    ,"Semicolon"   },
	.{ sdl.K_SPACE        ,"Space"       },
	.{ sdl.K_ESCAPE       ,"Escape"      },
	.{ sdl.K_RETURN       ,"Enter"       },
	.{ sdl.K_TAB          ,"Tab"         },
	.{ sdl.K_BACKSPACE    ,"Backspace"   },
	.{ sdl.K_INSERT       ,"Insert"      },
	.{ sdl.K_DELETE       ,"Delete"      },
	.{ sdl.K_RIGHT        ,"ArrowRight"  },
	.{ sdl.K_LEFT         ,"ArrowLeft"   },
	.{ sdl.K_DOWN         ,"ArrowDown"   },
	.{ sdl.K_UP           ,"ArrowUp"     },
	.{ sdl.K_PAGEUP       ,"PageUp"      },
	.{ sdl.K_PAGEDOWN     ,"PageDown"    },
	.{ sdl.K_HOME         ,"Home"        },
	.{ sdl.K_END          ,"End"         },
	.{ sdl.K_CAPSLOCK     ,"CapsLock"    },
	.{ sdl.K_SCROLLLOCK   ,"ScrollLock"  },
	.{ sdl.K_NUMLOCKCLEAR ,"NumLock"     },
	.{ sdl.K_PRINTSCREEN  ,"PrintScreen" },
	.{ sdl.K_PAUSE        ,"Pause"       },
	.{ sdl.K_F1           ,"F1"          },
	.{ sdl.K_F2           ,"F2"          },
	.{ sdl.K_F3           ,"F3"          },
	.{ sdl.K_F4           ,"F4"          },
	.{ sdl.K_F5           ,"F5"          },
	.{ sdl.K_F6           ,"F6"          },
	.{ sdl.K_F7           ,"F7"          },
	.{ sdl.K_F8           ,"F8"          },
	.{ sdl.K_F9           ,"F9"          },
	.{ sdl.K_F10          ,"F10"         },
	.{ sdl.K_F11          ,"F11"         },
	.{ sdl.K_F12          ,"F12"         },
};

open_from_drive_mode_init :: fn () {
	// Activate command buffer.
	active_editor = command_editor;
	buf :: get_active_buffer_and_editor();
	clear_buffer(buf);

	input_mode               = InputMode.TEXT;
	notify_changes_to_buffer = buf.index;

	base_path = get_cwd();
	err :: list_directory(tprint("%/", base_path));
	if err {
		print_err(err);
	}
}

open_from_drive_mode_terminate :: fn () {
	active_editor = command_editor;
	str_terminate(&base_path);
}

draw_open_from_drive_mode :: fn () {
	get_title :: fn () string_view #inline {
		if base_path.len == 0 && PLATFORM == Platform.WINDOWS {
			return "Open: ";
		}
		if base_path.len == 1 && PLATFORM != Platform.WINDOWS {
			return "Open: /";
		}

		return tprint("Open: %/", base_path);
	};

	assert(active_editor == command_editor);
	w, h :: get_command_editor_size();

	draw_command_editor(command_editor, 0.f, 0.f, w, h, get_title());

	using DrawListCols;
	list_h, clicked :: draw_list(0.f, h, w, ICON | TITLE);
	draw_last_status_message(0.f, h + list_h, w);

	if clicked {
		commit();
	}
}

//
// Commands
//

invoke_command_open_from_drive_mode :: fn (buf: *Buffer, cmd: Command) bool {
	assert(active_editor == command_editor);
	assert(editors[active_editor].buffer_index == buf.index);
	editor :: &editors[active_editor];

	using Command;

	switch cmd {
		INSERT_NEW_LINE { commit(); }

		DELETE_CHAR_LEFT {
			position :: get_cursor_position(buf, editor.cursor_index);
			if position != 0 {
				// Command not handled.
				return false;
			}
			dir_up(&base_path);
		}

		MOVE_UP   { list_item_up();   }
		MOVE_DOWN { list_item_down(); }

		// Not handled.
		default { return false; }
	}

	return true;
}

open_from_drive_cmd_changed :: fn () {
	buf :: get_active_buffer_and_editor();
	user_path :: peek_row(buf, 0);
	head, tail :: parse_path(user_path);

	if head.len > 0 {
		new_base_path: string_view;

		if is_path_absolute(head) {
			new_base_path = head;
		} else {
			if base_path.len == 1 && PLATFORM != Platform.WINDOWS {
				new_base_path = tprint("/%", head);
			} else {
				new_base_path = tprint("%/%", base_path, head);
			}
		}

		is_dir, err :: is_directory(new_base_path);
		if err then print_err(err);

		if is_dir {
			base_path.len = 0;
			str_append(&base_path, new_base_path);
			err :: list_directory(base_path);
			if err then print_err(err);

			// 2025-02-17: Changing the buffer content will invoke change notification
			//             invoking this function again. So filtering should be properly
			//             updated.
			clear_buffer(buf);
			if tail.len > 0 then insert_string(buf, 0, tail);
			return;
		}
	}

	if tail.len == 0 {
		clear_list_filters();
		return;
	}

	filter_list(tail);
}

#scope_private

base_path: string;

commit :: fn () {
	buf :: get_active_buffer_and_editor();

	item :: get_selected_item_in_list();
	if !item { return; }

	path: string_view #noinit;
	if base_path.len == 0 && PLATFORM == Platform.WINDOWS {
		path = tprint(item.title);
	} else {
		path = tprint("%/%", base_path, item.title);
	}
	clear_buffer(buf);

	if (item.flags & ItemFlags.DIRECTORY) == ItemFlags.DIRECTORY {
		err :: list_directory(tprint("%/", path));
		if err {
			print_err(err);
			return;
		}

		base_path.len = 0;
		str_append(&base_path, path);

		//set_cwd(base_path);
	} else {
		set_mode(Mode.TEXT_EDIT);
		err :: open(path);
		if err { print_err(err); }
	}
}

parse_path :: fn (path: string_view) (head: string_view, tail: string_view) {
	delims: string_view;

	#if PLATFORM == Platform.WINDOWS {
		delims = "\\/";
	} else {
		delims = "/";
	}

	last_delim_index : s64 = -1;
	loop i := path.len-1; i >= 0; i -= 1 {
		loop j := 0; j < delims.len; j += 1 {
			if path[i] == delims[j] {
				last_delim_index = i;
				break;
			}
		}
	}

	if last_delim_index == -1 then return "", path;
	head := string_view.{ last_delim_index, path.ptr };

	if PLATFORM != Platform.WINDOWS && last_delim_index == 0 {
		head = .{ 1, path.ptr };
	}

	tail :: string_view.{ path.len - last_delim_index - 1, &path[last_delim_index+1] };

	return head, tail;
}

is_path_absolute :: fn (path: string_view) bool {
	if path.len < 1 then return false;

	#if PLATFORM == Platform.WINDOWS {
		if path.len < 2 then return false;
		return path[1] == ':';
	}

	return path[0] == '/';
}